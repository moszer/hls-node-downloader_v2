import {
  require_react
} from "./chunk-ZGRSIX2Q.js";
import {
  __commonJS,
  __toESM
} from "./chunk-ROME4SDB.js";

// node_modules/hls.js/dist/hls.js
var require_hls = __commonJS({
  "node_modules/hls.js/dist/hls.js"(exports, module) {
    typeof window !== "undefined" && function webpackUniversalModuleDefinition(root, factory) {
      if (typeof exports === "object" && typeof module === "object")
        module.exports = factory();
      else if (typeof define === "function" && define.amd)
        define([], factory);
      else if (typeof exports === "object")
        exports["Hls"] = factory();
      else
        root["Hls"] = factory();
    }(exports, function() {
      return (
        /******/
        function(modules) {
          var installedModules = {};
          function __webpack_require__(moduleId) {
            if (installedModules[moduleId]) {
              return installedModules[moduleId].exports;
            }
            var module2 = installedModules[moduleId] = {
              /******/
              i: moduleId,
              /******/
              l: false,
              /******/
              exports: {}
              /******/
            };
            modules[moduleId].call(module2.exports, module2, module2.exports, __webpack_require__);
            module2.l = true;
            return module2.exports;
          }
          __webpack_require__.m = modules;
          __webpack_require__.c = installedModules;
          __webpack_require__.d = function(exports2, name, getter) {
            if (!__webpack_require__.o(exports2, name)) {
              Object.defineProperty(exports2, name, { enumerable: true, get: getter });
            }
          };
          __webpack_require__.r = function(exports2) {
            if (typeof Symbol !== "undefined" && Symbol.toStringTag) {
              Object.defineProperty(exports2, Symbol.toStringTag, { value: "Module" });
            }
            Object.defineProperty(exports2, "__esModule", { value: true });
          };
          __webpack_require__.t = function(value, mode) {
            if (mode & 1)
              value = __webpack_require__(value);
            if (mode & 8)
              return value;
            if (mode & 4 && typeof value === "object" && value && value.__esModule)
              return value;
            var ns = /* @__PURE__ */ Object.create(null);
            __webpack_require__.r(ns);
            Object.defineProperty(ns, "default", { enumerable: true, value });
            if (mode & 2 && typeof value != "string")
              for (var key in value)
                __webpack_require__.d(ns, key, (function(key2) {
                  return value[key2];
                }).bind(null, key));
            return ns;
          };
          __webpack_require__.n = function(module2) {
            var getter = module2 && module2.__esModule ? (
              /******/
              function getDefault() {
                return module2["default"];
              }
            ) : (
              /******/
              function getModuleExports() {
                return module2;
              }
            );
            __webpack_require__.d(getter, "a", getter);
            return getter;
          };
          __webpack_require__.o = function(object, property) {
            return Object.prototype.hasOwnProperty.call(object, property);
          };
          __webpack_require__.p = "/dist/";
          return __webpack_require__(__webpack_require__.s = "./src/hls.ts");
        }({
          /***/
          "./node_modules/eventemitter3/index.js": (
            /*!*********************************************!*\
              !*** ./node_modules/eventemitter3/index.js ***!
              \*********************************************/
            /*! no static exports found */
            /*! ModuleConcatenation bailout: Module is not an ECMAScript module */
            /***/
            function(module2, exports2, __webpack_require__) {
              "use strict";
              var has = Object.prototype.hasOwnProperty, prefix = "~";
              function Events() {
              }
              if (Object.create) {
                Events.prototype = /* @__PURE__ */ Object.create(null);
                if (!new Events().__proto__)
                  prefix = false;
              }
              function EE(fn, context, once) {
                this.fn = fn;
                this.context = context;
                this.once = once || false;
              }
              function addListener(emitter, event, fn, context, once) {
                if (typeof fn !== "function") {
                  throw new TypeError("The listener must be a function");
                }
                var listener = new EE(fn, context || emitter, once), evt = prefix ? prefix + event : event;
                if (!emitter._events[evt])
                  emitter._events[evt] = listener, emitter._eventsCount++;
                else if (!emitter._events[evt].fn)
                  emitter._events[evt].push(listener);
                else
                  emitter._events[evt] = [emitter._events[evt], listener];
                return emitter;
              }
              function clearEvent(emitter, evt) {
                if (--emitter._eventsCount === 0)
                  emitter._events = new Events();
                else
                  delete emitter._events[evt];
              }
              function EventEmitter() {
                this._events = new Events();
                this._eventsCount = 0;
              }
              EventEmitter.prototype.eventNames = function eventNames() {
                var names = [], events, name;
                if (this._eventsCount === 0)
                  return names;
                for (name in events = this._events) {
                  if (has.call(events, name))
                    names.push(prefix ? name.slice(1) : name);
                }
                if (Object.getOwnPropertySymbols) {
                  return names.concat(Object.getOwnPropertySymbols(events));
                }
                return names;
              };
              EventEmitter.prototype.listeners = function listeners(event) {
                var evt = prefix ? prefix + event : event, handlers = this._events[evt];
                if (!handlers)
                  return [];
                if (handlers.fn)
                  return [handlers.fn];
                for (var i = 0, l = handlers.length, ee = new Array(l); i < l; i++) {
                  ee[i] = handlers[i].fn;
                }
                return ee;
              };
              EventEmitter.prototype.listenerCount = function listenerCount(event) {
                var evt = prefix ? prefix + event : event, listeners = this._events[evt];
                if (!listeners)
                  return 0;
                if (listeners.fn)
                  return 1;
                return listeners.length;
              };
              EventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {
                var evt = prefix ? prefix + event : event;
                if (!this._events[evt])
                  return false;
                var listeners = this._events[evt], len = arguments.length, args, i;
                if (listeners.fn) {
                  if (listeners.once)
                    this.removeListener(event, listeners.fn, void 0, true);
                  switch (len) {
                    case 1:
                      return listeners.fn.call(listeners.context), true;
                    case 2:
                      return listeners.fn.call(listeners.context, a1), true;
                    case 3:
                      return listeners.fn.call(listeners.context, a1, a2), true;
                    case 4:
                      return listeners.fn.call(listeners.context, a1, a2, a3), true;
                    case 5:
                      return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;
                    case 6:
                      return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;
                  }
                  for (i = 1, args = new Array(len - 1); i < len; i++) {
                    args[i - 1] = arguments[i];
                  }
                  listeners.fn.apply(listeners.context, args);
                } else {
                  var length = listeners.length, j;
                  for (i = 0; i < length; i++) {
                    if (listeners[i].once)
                      this.removeListener(event, listeners[i].fn, void 0, true);
                    switch (len) {
                      case 1:
                        listeners[i].fn.call(listeners[i].context);
                        break;
                      case 2:
                        listeners[i].fn.call(listeners[i].context, a1);
                        break;
                      case 3:
                        listeners[i].fn.call(listeners[i].context, a1, a2);
                        break;
                      case 4:
                        listeners[i].fn.call(listeners[i].context, a1, a2, a3);
                        break;
                      default:
                        if (!args)
                          for (j = 1, args = new Array(len - 1); j < len; j++) {
                            args[j - 1] = arguments[j];
                          }
                        listeners[i].fn.apply(listeners[i].context, args);
                    }
                  }
                }
                return true;
              };
              EventEmitter.prototype.on = function on(event, fn, context) {
                return addListener(this, event, fn, context, false);
              };
              EventEmitter.prototype.once = function once(event, fn, context) {
                return addListener(this, event, fn, context, true);
              };
              EventEmitter.prototype.removeListener = function removeListener(event, fn, context, once) {
                var evt = prefix ? prefix + event : event;
                if (!this._events[evt])
                  return this;
                if (!fn) {
                  clearEvent(this, evt);
                  return this;
                }
                var listeners = this._events[evt];
                if (listeners.fn) {
                  if (listeners.fn === fn && (!once || listeners.once) && (!context || listeners.context === context)) {
                    clearEvent(this, evt);
                  }
                } else {
                  for (var i = 0, events = [], length = listeners.length; i < length; i++) {
                    if (listeners[i].fn !== fn || once && !listeners[i].once || context && listeners[i].context !== context) {
                      events.push(listeners[i]);
                    }
                  }
                  if (events.length)
                    this._events[evt] = events.length === 1 ? events[0] : events;
                  else
                    clearEvent(this, evt);
                }
                return this;
              };
              EventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {
                var evt;
                if (event) {
                  evt = prefix ? prefix + event : event;
                  if (this._events[evt])
                    clearEvent(this, evt);
                } else {
                  this._events = new Events();
                  this._eventsCount = 0;
                }
                return this;
              };
              EventEmitter.prototype.off = EventEmitter.prototype.removeListener;
              EventEmitter.prototype.addListener = EventEmitter.prototype.on;
              EventEmitter.prefixed = prefix;
              EventEmitter.EventEmitter = EventEmitter;
              if (true) {
                module2.exports = EventEmitter;
              }
            }
          ),
          /***/
          "./node_modules/url-toolkit/src/url-toolkit.js": (
            /*!*****************************************************!*\
              !*** ./node_modules/url-toolkit/src/url-toolkit.js ***!
              \*****************************************************/
            /*! no static exports found */
            /*! ModuleConcatenation bailout: Module is not an ECMAScript module */
            /***/
            function(module2, exports2, __webpack_require__) {
              (function(root) {
                var URL_REGEX = /^((?:[a-zA-Z0-9+\-.]+:)?)(\/\/[^\/?#]*)?((?:[^\/?#]*\/)*[^;?#]*)?(;[^?#]*)?(\?[^#]*)?(#.*)?$/;
                var FIRST_SEGMENT_REGEX = /^([^\/?#]*)(.*)$/;
                var SLASH_DOT_REGEX = /(?:\/|^)\.(?=\/)/g;
                var SLASH_DOT_DOT_REGEX = /(?:\/|^)\.\.\/(?!\.\.\/)[^\/]*(?=\/)/g;
                var URLToolkit = {
                  // If opts.alwaysNormalize is true then the path will always be normalized even when it starts with / or //
                  // E.g
                  // With opts.alwaysNormalize = false (default, spec compliant)
                  // http://a.com/b/cd + /e/f/../g => http://a.com/e/f/../g
                  // With opts.alwaysNormalize = true (not spec compliant)
                  // http://a.com/b/cd + /e/f/../g => http://a.com/e/g
                  buildAbsoluteURL: function(baseURL, relativeURL, opts) {
                    opts = opts || {};
                    baseURL = baseURL.trim();
                    relativeURL = relativeURL.trim();
                    if (!relativeURL) {
                      if (!opts.alwaysNormalize) {
                        return baseURL;
                      }
                      var basePartsForNormalise = URLToolkit.parseURL(baseURL);
                      if (!basePartsForNormalise) {
                        throw new Error("Error trying to parse base URL.");
                      }
                      basePartsForNormalise.path = URLToolkit.normalizePath(
                        basePartsForNormalise.path
                      );
                      return URLToolkit.buildURLFromParts(basePartsForNormalise);
                    }
                    var relativeParts = URLToolkit.parseURL(relativeURL);
                    if (!relativeParts) {
                      throw new Error("Error trying to parse relative URL.");
                    }
                    if (relativeParts.scheme) {
                      if (!opts.alwaysNormalize) {
                        return relativeURL;
                      }
                      relativeParts.path = URLToolkit.normalizePath(relativeParts.path);
                      return URLToolkit.buildURLFromParts(relativeParts);
                    }
                    var baseParts = URLToolkit.parseURL(baseURL);
                    if (!baseParts) {
                      throw new Error("Error trying to parse base URL.");
                    }
                    if (!baseParts.netLoc && baseParts.path && baseParts.path[0] !== "/") {
                      var pathParts = FIRST_SEGMENT_REGEX.exec(baseParts.path);
                      baseParts.netLoc = pathParts[1];
                      baseParts.path = pathParts[2];
                    }
                    if (baseParts.netLoc && !baseParts.path) {
                      baseParts.path = "/";
                    }
                    var builtParts = {
                      // 2c) Otherwise, the embedded URL inherits the scheme of
                      // the base URL.
                      scheme: baseParts.scheme,
                      netLoc: relativeParts.netLoc,
                      path: null,
                      params: relativeParts.params,
                      query: relativeParts.query,
                      fragment: relativeParts.fragment
                    };
                    if (!relativeParts.netLoc) {
                      builtParts.netLoc = baseParts.netLoc;
                      if (relativeParts.path[0] !== "/") {
                        if (!relativeParts.path) {
                          builtParts.path = baseParts.path;
                          if (!relativeParts.params) {
                            builtParts.params = baseParts.params;
                            if (!relativeParts.query) {
                              builtParts.query = baseParts.query;
                            }
                          }
                        } else {
                          var baseURLPath = baseParts.path;
                          var newPath = baseURLPath.substring(0, baseURLPath.lastIndexOf("/") + 1) + relativeParts.path;
                          builtParts.path = URLToolkit.normalizePath(newPath);
                        }
                      }
                    }
                    if (builtParts.path === null) {
                      builtParts.path = opts.alwaysNormalize ? URLToolkit.normalizePath(relativeParts.path) : relativeParts.path;
                    }
                    return URLToolkit.buildURLFromParts(builtParts);
                  },
                  parseURL: function(url) {
                    var parts = URL_REGEX.exec(url);
                    if (!parts) {
                      return null;
                    }
                    return {
                      scheme: parts[1] || "",
                      netLoc: parts[2] || "",
                      path: parts[3] || "",
                      params: parts[4] || "",
                      query: parts[5] || "",
                      fragment: parts[6] || ""
                    };
                  },
                  normalizePath: function(path) {
                    path = path.split("").reverse().join("").replace(SLASH_DOT_REGEX, "");
                    while (path.length !== (path = path.replace(SLASH_DOT_DOT_REGEX, "")).length) {
                    }
                    return path.split("").reverse().join("");
                  },
                  buildURLFromParts: function(parts) {
                    return parts.scheme + parts.netLoc + parts.path + parts.params + parts.query + parts.fragment;
                  }
                };
                if (true)
                  module2.exports = URLToolkit;
                else {
                }
              })(this);
            }
          ),
          /***/
          "./node_modules/webworkify-webpack/index.js": (
            /*!**************************************************!*\
              !*** ./node_modules/webworkify-webpack/index.js ***!
              \**************************************************/
            /*! no static exports found */
            /*! ModuleConcatenation bailout: Module is not an ECMAScript module */
            /***/
            function(module2, exports2, __webpack_require__) {
              function webpackBootstrapFunc(modules) {
                var installedModules = {};
                function __webpack_require__2(moduleId) {
                  if (installedModules[moduleId])
                    return installedModules[moduleId].exports;
                  var module3 = installedModules[moduleId] = {
                    /******/
                    i: moduleId,
                    /******/
                    l: false,
                    /******/
                    exports: {}
                    /******/
                  };
                  modules[moduleId].call(module3.exports, module3, module3.exports, __webpack_require__2);
                  module3.l = true;
                  return module3.exports;
                }
                __webpack_require__2.m = modules;
                __webpack_require__2.c = installedModules;
                __webpack_require__2.i = function(value) {
                  return value;
                };
                __webpack_require__2.d = function(exports3, name, getter) {
                  if (!__webpack_require__2.o(exports3, name)) {
                    Object.defineProperty(exports3, name, {
                      /******/
                      configurable: false,
                      /******/
                      enumerable: true,
                      /******/
                      get: getter
                      /******/
                    });
                  }
                };
                __webpack_require__2.r = function(exports3) {
                  Object.defineProperty(exports3, "__esModule", { value: true });
                };
                __webpack_require__2.n = function(module3) {
                  var getter = module3 && module3.__esModule ? (
                    /******/
                    function getDefault() {
                      return module3["default"];
                    }
                  ) : (
                    /******/
                    function getModuleExports() {
                      return module3;
                    }
                  );
                  __webpack_require__2.d(getter, "a", getter);
                  return getter;
                };
                __webpack_require__2.o = function(object, property) {
                  return Object.prototype.hasOwnProperty.call(object, property);
                };
                __webpack_require__2.p = "/";
                __webpack_require__2.oe = function(err) {
                  console.error(err);
                  throw err;
                };
                var f = __webpack_require__2(__webpack_require__2.s = ENTRY_MODULE);
                return f.default || f;
              }
              var moduleNameReqExp = "[\\.|\\-|\\+|\\w|/|@]+";
              var dependencyRegExp = "\\(\\s*(/\\*.*?\\*/)?\\s*.*?(" + moduleNameReqExp + ").*?\\)";
              function quoteRegExp(str) {
                return (str + "").replace(/[.?*+^$[\]\\(){}|-]/g, "\\$&");
              }
              function isNumeric(n) {
                return !isNaN(1 * n);
              }
              function getModuleDependencies(sources, module3, queueName) {
                var retval = {};
                retval[queueName] = [];
                var fnString = module3.toString();
                var wrapperSignature = fnString.match(/^function\s?\w*\(\w+,\s*\w+,\s*(\w+)\)/);
                if (!wrapperSignature)
                  return retval;
                var webpackRequireName = wrapperSignature[1];
                var re = new RegExp("(\\\\n|\\W)" + quoteRegExp(webpackRequireName) + dependencyRegExp, "g");
                var match;
                while (match = re.exec(fnString)) {
                  if (match[3] === "dll-reference")
                    continue;
                  retval[queueName].push(match[3]);
                }
                re = new RegExp("\\(" + quoteRegExp(webpackRequireName) + '\\("(dll-reference\\s(' + moduleNameReqExp + '))"\\)\\)' + dependencyRegExp, "g");
                while (match = re.exec(fnString)) {
                  if (!sources[match[2]]) {
                    retval[queueName].push(match[1]);
                    sources[match[2]] = __webpack_require__(match[1]).m;
                  }
                  retval[match[2]] = retval[match[2]] || [];
                  retval[match[2]].push(match[4]);
                }
                var keys = Object.keys(retval);
                for (var i = 0; i < keys.length; i++) {
                  for (var j = 0; j < retval[keys[i]].length; j++) {
                    if (isNumeric(retval[keys[i]][j])) {
                      retval[keys[i]][j] = 1 * retval[keys[i]][j];
                    }
                  }
                }
                return retval;
              }
              function hasValuesInQueues(queues) {
                var keys = Object.keys(queues);
                return keys.reduce(function(hasValues, key) {
                  return hasValues || queues[key].length > 0;
                }, false);
              }
              function getRequiredModules(sources, moduleId) {
                var modulesQueue = {
                  main: [moduleId]
                };
                var requiredModules = {
                  main: []
                };
                var seenModules = {
                  main: {}
                };
                while (hasValuesInQueues(modulesQueue)) {
                  var queues = Object.keys(modulesQueue);
                  for (var i = 0; i < queues.length; i++) {
                    var queueName = queues[i];
                    var queue = modulesQueue[queueName];
                    var moduleToCheck = queue.pop();
                    seenModules[queueName] = seenModules[queueName] || {};
                    if (seenModules[queueName][moduleToCheck] || !sources[queueName][moduleToCheck])
                      continue;
                    seenModules[queueName][moduleToCheck] = true;
                    requiredModules[queueName] = requiredModules[queueName] || [];
                    requiredModules[queueName].push(moduleToCheck);
                    var newModules = getModuleDependencies(sources, sources[queueName][moduleToCheck], queueName);
                    var newModulesKeys = Object.keys(newModules);
                    for (var j = 0; j < newModulesKeys.length; j++) {
                      modulesQueue[newModulesKeys[j]] = modulesQueue[newModulesKeys[j]] || [];
                      modulesQueue[newModulesKeys[j]] = modulesQueue[newModulesKeys[j]].concat(newModules[newModulesKeys[j]]);
                    }
                  }
                }
                return requiredModules;
              }
              module2.exports = function(moduleId, options) {
                options = options || {};
                var sources = {
                  main: __webpack_require__.m
                };
                var requiredModules = options.all ? { main: Object.keys(sources.main) } : getRequiredModules(sources, moduleId);
                var src = "";
                Object.keys(requiredModules).filter(function(m) {
                  return m !== "main";
                }).forEach(function(module3) {
                  var entryModule = 0;
                  while (requiredModules[module3][entryModule]) {
                    entryModule++;
                  }
                  requiredModules[module3].push(entryModule);
                  sources[module3][entryModule] = "(function(module, exports, __webpack_require__) { module.exports = __webpack_require__; })";
                  src = src + "var " + module3 + " = (" + webpackBootstrapFunc.toString().replace("ENTRY_MODULE", JSON.stringify(entryModule)) + ")({" + requiredModules[module3].map(function(id) {
                    return "" + JSON.stringify(id) + ": " + sources[module3][id].toString();
                  }).join(",") + "});\n";
                });
                src = src + "new ((" + webpackBootstrapFunc.toString().replace("ENTRY_MODULE", JSON.stringify(moduleId)) + ")({" + requiredModules.main.map(function(id) {
                  return "" + JSON.stringify(id) + ": " + sources.main[id].toString();
                }).join(",") + "}))(self);";
                var blob = new window.Blob([src], { type: "text/javascript" });
                if (options.bare) {
                  return blob;
                }
                var URL = window.URL || window.webkitURL || window.mozURL || window.msURL;
                var workerUrl = URL.createObjectURL(blob);
                var worker = new window.Worker(workerUrl);
                worker.objectURL = workerUrl;
                return worker;
              };
            }
          ),
          /***/
          "./src/crypt/decrypter.js": (
            /*!********************************************!*\
              !*** ./src/crypt/decrypter.js + 3 modules ***!
              \********************************************/
            /*! exports provided: default */
            /*! ModuleConcatenation bailout: Cannot concat with ./src/errors.ts because of ./src/hls.ts */
            /*! ModuleConcatenation bailout: Cannot concat with ./src/events.js because of ./src/hls.ts */
            /*! ModuleConcatenation bailout: Cannot concat with ./src/utils/get-self-scope.js because of ./src/hls.ts */
            /*! ModuleConcatenation bailout: Cannot concat with ./src/utils/logger.js because of ./src/hls.ts */
            /***/
            function(module2, __webpack_exports__, __webpack_require__) {
              "use strict";
              __webpack_require__.r(__webpack_exports__);
              var AESCrypto = function() {
                function AESCrypto2(subtle, iv) {
                  this.subtle = subtle;
                  this.aesIV = iv;
                }
                var _proto = AESCrypto2.prototype;
                _proto.decrypt = function decrypt(data, key) {
                  return this.subtle.decrypt({
                    name: "AES-CBC",
                    iv: this.aesIV
                  }, key, data);
                };
                return AESCrypto2;
              }();
              var FastAESKey = function() {
                function FastAESKey2(subtle, key) {
                  this.subtle = subtle;
                  this.key = key;
                }
                var _proto = FastAESKey2.prototype;
                _proto.expandKey = function expandKey() {
                  return this.subtle.importKey("raw", this.key, {
                    name: "AES-CBC"
                  }, false, ["encrypt", "decrypt"]);
                };
                return FastAESKey2;
              }();
              var fast_aes_key = FastAESKey;
              function removePadding(buffer) {
                var outputBytes = buffer.byteLength;
                var paddingBytes = outputBytes && new DataView(buffer).getUint8(outputBytes - 1);
                if (paddingBytes) {
                  return buffer.slice(0, outputBytes - paddingBytes);
                } else {
                  return buffer;
                }
              }
              var AESDecryptor = function() {
                function AESDecryptor2() {
                  this.rcon = [0, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54];
                  this.subMix = [new Uint32Array(256), new Uint32Array(256), new Uint32Array(256), new Uint32Array(256)];
                  this.invSubMix = [new Uint32Array(256), new Uint32Array(256), new Uint32Array(256), new Uint32Array(256)];
                  this.sBox = new Uint32Array(256);
                  this.invSBox = new Uint32Array(256);
                  this.key = new Uint32Array(0);
                  this.initTable();
                }
                var _proto = AESDecryptor2.prototype;
                _proto.uint8ArrayToUint32Array_ = function uint8ArrayToUint32Array_(arrayBuffer) {
                  var view = new DataView(arrayBuffer);
                  var newArray = new Uint32Array(4);
                  for (var i = 0; i < 4; i++) {
                    newArray[i] = view.getUint32(i * 4);
                  }
                  return newArray;
                };
                _proto.initTable = function initTable() {
                  var sBox = this.sBox;
                  var invSBox = this.invSBox;
                  var subMix = this.subMix;
                  var subMix0 = subMix[0];
                  var subMix1 = subMix[1];
                  var subMix2 = subMix[2];
                  var subMix3 = subMix[3];
                  var invSubMix = this.invSubMix;
                  var invSubMix0 = invSubMix[0];
                  var invSubMix1 = invSubMix[1];
                  var invSubMix2 = invSubMix[2];
                  var invSubMix3 = invSubMix[3];
                  var d = new Uint32Array(256);
                  var x = 0;
                  var xi = 0;
                  var i = 0;
                  for (i = 0; i < 256; i++) {
                    if (i < 128) {
                      d[i] = i << 1;
                    } else {
                      d[i] = i << 1 ^ 283;
                    }
                  }
                  for (i = 0; i < 256; i++) {
                    var sx = xi ^ xi << 1 ^ xi << 2 ^ xi << 3 ^ xi << 4;
                    sx = sx >>> 8 ^ sx & 255 ^ 99;
                    sBox[x] = sx;
                    invSBox[sx] = x;
                    var x2 = d[x];
                    var x4 = d[x2];
                    var x8 = d[x4];
                    var t = d[sx] * 257 ^ sx * 16843008;
                    subMix0[x] = t << 24 | t >>> 8;
                    subMix1[x] = t << 16 | t >>> 16;
                    subMix2[x] = t << 8 | t >>> 24;
                    subMix3[x] = t;
                    t = x8 * 16843009 ^ x4 * 65537 ^ x2 * 257 ^ x * 16843008;
                    invSubMix0[sx] = t << 24 | t >>> 8;
                    invSubMix1[sx] = t << 16 | t >>> 16;
                    invSubMix2[sx] = t << 8 | t >>> 24;
                    invSubMix3[sx] = t;
                    if (!x) {
                      x = xi = 1;
                    } else {
                      x = x2 ^ d[d[d[x8 ^ x2]]];
                      xi ^= d[d[xi]];
                    }
                  }
                };
                _proto.expandKey = function expandKey(keyBuffer) {
                  var key = this.uint8ArrayToUint32Array_(keyBuffer);
                  var sameKey = true;
                  var offset = 0;
                  while (offset < key.length && sameKey) {
                    sameKey = key[offset] === this.key[offset];
                    offset++;
                  }
                  if (sameKey) {
                    return;
                  }
                  this.key = key;
                  var keySize = this.keySize = key.length;
                  if (keySize !== 4 && keySize !== 6 && keySize !== 8) {
                    throw new Error("Invalid aes key size=" + keySize);
                  }
                  var ksRows = this.ksRows = (keySize + 6 + 1) * 4;
                  var ksRow;
                  var invKsRow;
                  var keySchedule = this.keySchedule = new Uint32Array(ksRows);
                  var invKeySchedule = this.invKeySchedule = new Uint32Array(ksRows);
                  var sbox = this.sBox;
                  var rcon = this.rcon;
                  var invSubMix = this.invSubMix;
                  var invSubMix0 = invSubMix[0];
                  var invSubMix1 = invSubMix[1];
                  var invSubMix2 = invSubMix[2];
                  var invSubMix3 = invSubMix[3];
                  var prev;
                  var t;
                  for (ksRow = 0; ksRow < ksRows; ksRow++) {
                    if (ksRow < keySize) {
                      prev = keySchedule[ksRow] = key[ksRow];
                      continue;
                    }
                    t = prev;
                    if (ksRow % keySize === 0) {
                      t = t << 8 | t >>> 24;
                      t = sbox[t >>> 24] << 24 | sbox[t >>> 16 & 255] << 16 | sbox[t >>> 8 & 255] << 8 | sbox[t & 255];
                      t ^= rcon[ksRow / keySize | 0] << 24;
                    } else if (keySize > 6 && ksRow % keySize === 4) {
                      t = sbox[t >>> 24] << 24 | sbox[t >>> 16 & 255] << 16 | sbox[t >>> 8 & 255] << 8 | sbox[t & 255];
                    }
                    keySchedule[ksRow] = prev = (keySchedule[ksRow - keySize] ^ t) >>> 0;
                  }
                  for (invKsRow = 0; invKsRow < ksRows; invKsRow++) {
                    ksRow = ksRows - invKsRow;
                    if (invKsRow & 3) {
                      t = keySchedule[ksRow];
                    } else {
                      t = keySchedule[ksRow - 4];
                    }
                    if (invKsRow < 4 || ksRow <= 4) {
                      invKeySchedule[invKsRow] = t;
                    } else {
                      invKeySchedule[invKsRow] = invSubMix0[sbox[t >>> 24]] ^ invSubMix1[sbox[t >>> 16 & 255]] ^ invSubMix2[sbox[t >>> 8 & 255]] ^ invSubMix3[sbox[t & 255]];
                    }
                    invKeySchedule[invKsRow] = invKeySchedule[invKsRow] >>> 0;
                  }
                };
                _proto.networkToHostOrderSwap = function networkToHostOrderSwap(word) {
                  return word << 24 | (word & 65280) << 8 | (word & 16711680) >> 8 | word >>> 24;
                };
                _proto.decrypt = function decrypt(inputArrayBuffer, offset, aesIV, removePKCS7Padding) {
                  var nRounds = this.keySize + 6;
                  var invKeySchedule = this.invKeySchedule;
                  var invSBOX = this.invSBox;
                  var invSubMix = this.invSubMix;
                  var invSubMix0 = invSubMix[0];
                  var invSubMix1 = invSubMix[1];
                  var invSubMix2 = invSubMix[2];
                  var invSubMix3 = invSubMix[3];
                  var initVector = this.uint8ArrayToUint32Array_(aesIV);
                  var initVector0 = initVector[0];
                  var initVector1 = initVector[1];
                  var initVector2 = initVector[2];
                  var initVector3 = initVector[3];
                  var inputInt32 = new Int32Array(inputArrayBuffer);
                  var outputInt32 = new Int32Array(inputInt32.length);
                  var t0, t1, t2, t3;
                  var s0, s1, s2, s3;
                  var inputWords0, inputWords1, inputWords2, inputWords3;
                  var ksRow, i;
                  var swapWord = this.networkToHostOrderSwap;
                  while (offset < inputInt32.length) {
                    inputWords0 = swapWord(inputInt32[offset]);
                    inputWords1 = swapWord(inputInt32[offset + 1]);
                    inputWords2 = swapWord(inputInt32[offset + 2]);
                    inputWords3 = swapWord(inputInt32[offset + 3]);
                    s0 = inputWords0 ^ invKeySchedule[0];
                    s1 = inputWords3 ^ invKeySchedule[1];
                    s2 = inputWords2 ^ invKeySchedule[2];
                    s3 = inputWords1 ^ invKeySchedule[3];
                    ksRow = 4;
                    for (i = 1; i < nRounds; i++) {
                      t0 = invSubMix0[s0 >>> 24] ^ invSubMix1[s1 >> 16 & 255] ^ invSubMix2[s2 >> 8 & 255] ^ invSubMix3[s3 & 255] ^ invKeySchedule[ksRow];
                      t1 = invSubMix0[s1 >>> 24] ^ invSubMix1[s2 >> 16 & 255] ^ invSubMix2[s3 >> 8 & 255] ^ invSubMix3[s0 & 255] ^ invKeySchedule[ksRow + 1];
                      t2 = invSubMix0[s2 >>> 24] ^ invSubMix1[s3 >> 16 & 255] ^ invSubMix2[s0 >> 8 & 255] ^ invSubMix3[s1 & 255] ^ invKeySchedule[ksRow + 2];
                      t3 = invSubMix0[s3 >>> 24] ^ invSubMix1[s0 >> 16 & 255] ^ invSubMix2[s1 >> 8 & 255] ^ invSubMix3[s2 & 255] ^ invKeySchedule[ksRow + 3];
                      s0 = t0;
                      s1 = t1;
                      s2 = t2;
                      s3 = t3;
                      ksRow = ksRow + 4;
                    }
                    t0 = invSBOX[s0 >>> 24] << 24 ^ invSBOX[s1 >> 16 & 255] << 16 ^ invSBOX[s2 >> 8 & 255] << 8 ^ invSBOX[s3 & 255] ^ invKeySchedule[ksRow];
                    t1 = invSBOX[s1 >>> 24] << 24 ^ invSBOX[s2 >> 16 & 255] << 16 ^ invSBOX[s3 >> 8 & 255] << 8 ^ invSBOX[s0 & 255] ^ invKeySchedule[ksRow + 1];
                    t2 = invSBOX[s2 >>> 24] << 24 ^ invSBOX[s3 >> 16 & 255] << 16 ^ invSBOX[s0 >> 8 & 255] << 8 ^ invSBOX[s1 & 255] ^ invKeySchedule[ksRow + 2];
                    t3 = invSBOX[s3 >>> 24] << 24 ^ invSBOX[s0 >> 16 & 255] << 16 ^ invSBOX[s1 >> 8 & 255] << 8 ^ invSBOX[s2 & 255] ^ invKeySchedule[ksRow + 3];
                    ksRow = ksRow + 3;
                    outputInt32[offset] = swapWord(t0 ^ initVector0);
                    outputInt32[offset + 1] = swapWord(t3 ^ initVector1);
                    outputInt32[offset + 2] = swapWord(t2 ^ initVector2);
                    outputInt32[offset + 3] = swapWord(t1 ^ initVector3);
                    initVector0 = inputWords0;
                    initVector1 = inputWords1;
                    initVector2 = inputWords2;
                    initVector3 = inputWords3;
                    offset = offset + 4;
                  }
                  return removePKCS7Padding ? removePadding(outputInt32.buffer) : outputInt32.buffer;
                };
                _proto.destroy = function destroy() {
                  this.key = void 0;
                  this.keySize = void 0;
                  this.ksRows = void 0;
                  this.sBox = void 0;
                  this.invSBox = void 0;
                  this.subMix = void 0;
                  this.invSubMix = void 0;
                  this.keySchedule = void 0;
                  this.invKeySchedule = void 0;
                  this.rcon = void 0;
                };
                return AESDecryptor2;
              }();
              var aes_decryptor = AESDecryptor;
              var errors = __webpack_require__("./src/errors.ts");
              var logger = __webpack_require__("./src/utils/logger.js");
              var events = __webpack_require__("./src/events.js");
              var get_self_scope = __webpack_require__("./src/utils/get-self-scope.js");
              var global = Object(get_self_scope["getSelfScope"])();
              var decrypter_Decrypter = function() {
                function Decrypter(observer, config, _temp) {
                  var _ref = _temp === void 0 ? {} : _temp, _ref$removePKCS7Paddi = _ref.removePKCS7Padding, removePKCS7Padding = _ref$removePKCS7Paddi === void 0 ? true : _ref$removePKCS7Paddi;
                  this.logEnabled = true;
                  this.observer = observer;
                  this.config = config;
                  this.removePKCS7Padding = removePKCS7Padding;
                  if (removePKCS7Padding) {
                    try {
                      var browserCrypto = global.crypto;
                      if (browserCrypto) {
                        this.subtle = browserCrypto.subtle || browserCrypto.webkitSubtle;
                      }
                    } catch (e) {
                    }
                  }
                  this.disableWebCrypto = !this.subtle;
                }
                var _proto = Decrypter.prototype;
                _proto.isSync = function isSync() {
                  return this.disableWebCrypto && this.config.enableSoftwareAES;
                };
                _proto.decrypt = function decrypt(data, key, iv, callback) {
                  var _this = this;
                  if (this.disableWebCrypto && this.config.enableSoftwareAES) {
                    if (this.logEnabled) {
                      logger["logger"].log("JS AES decrypt");
                      this.logEnabled = false;
                    }
                    var decryptor = this.decryptor;
                    if (!decryptor) {
                      this.decryptor = decryptor = new aes_decryptor();
                    }
                    decryptor.expandKey(key);
                    callback(decryptor.decrypt(data, 0, iv, this.removePKCS7Padding));
                  } else {
                    if (this.logEnabled) {
                      logger["logger"].log("WebCrypto AES decrypt");
                      this.logEnabled = false;
                    }
                    var subtle = this.subtle;
                    if (this.key !== key) {
                      this.key = key;
                      this.fastAesKey = new fast_aes_key(subtle, key);
                    }
                    this.fastAesKey.expandKey().then(function(aesKey) {
                      var crypto = new AESCrypto(subtle, iv);
                      crypto.decrypt(data, aesKey).catch(function(err) {
                        _this.onWebCryptoError(err, data, key, iv, callback);
                      }).then(function(result) {
                        callback(result);
                      });
                    }).catch(function(err) {
                      _this.onWebCryptoError(err, data, key, iv, callback);
                    });
                  }
                };
                _proto.onWebCryptoError = function onWebCryptoError(err, data, key, iv, callback) {
                  if (this.config.enableSoftwareAES) {
                    logger["logger"].log("WebCrypto Error, disable WebCrypto API");
                    this.disableWebCrypto = true;
                    this.logEnabled = true;
                    this.decrypt(data, key, iv, callback);
                  } else {
                    logger["logger"].error("decrypting error : " + err.message);
                    this.observer.trigger(events["default"].ERROR, {
                      type: errors["ErrorTypes"].MEDIA_ERROR,
                      details: errors["ErrorDetails"].FRAG_DECRYPT_ERROR,
                      fatal: true,
                      reason: err.message
                    });
                  }
                };
                _proto.destroy = function destroy() {
                  var decryptor = this.decryptor;
                  if (decryptor) {
                    decryptor.destroy();
                    this.decryptor = void 0;
                  }
                };
                return Decrypter;
              }();
              var decrypter = __webpack_exports__["default"] = decrypter_Decrypter;
            }
          ),
          /***/
          "./src/demux/demuxer-inline.js": (
            /*!**************************************************!*\
              !*** ./src/demux/demuxer-inline.js + 12 modules ***!
              \**************************************************/
            /*! exports provided: default */
            /*! ModuleConcatenation bailout: Cannot concat with ./src/crypt/decrypter.js because of ./src/hls.ts */
            /*! ModuleConcatenation bailout: Cannot concat with ./src/demux/id3.js because of ./src/hls.ts */
            /*! ModuleConcatenation bailout: Cannot concat with ./src/demux/mp4demuxer.js because of ./src/hls.ts */
            /*! ModuleConcatenation bailout: Cannot concat with ./src/errors.ts because of ./src/hls.ts */
            /*! ModuleConcatenation bailout: Cannot concat with ./src/events.js because of ./src/hls.ts */
            /*! ModuleConcatenation bailout: Cannot concat with ./src/polyfills/number.js because of ./src/hls.ts */
            /*! ModuleConcatenation bailout: Cannot concat with ./src/utils/get-self-scope.js because of ./src/hls.ts */
            /*! ModuleConcatenation bailout: Cannot concat with ./src/utils/logger.js because of ./src/hls.ts */
            /***/
            function(module2, __webpack_exports__, __webpack_require__) {
              "use strict";
              __webpack_require__.r(__webpack_exports__);
              var events = __webpack_require__("./src/events.js");
              var errors = __webpack_require__("./src/errors.ts");
              var crypt_decrypter = __webpack_require__("./src/crypt/decrypter.js");
              var number = __webpack_require__("./src/polyfills/number.js");
              var logger = __webpack_require__("./src/utils/logger.js");
              var get_self_scope = __webpack_require__("./src/utils/get-self-scope.js");
              function getAudioConfig(observer, data, offset, audioCodec) {
                var adtsObjectType, adtsSampleingIndex, adtsExtensionSampleingIndex, adtsChanelConfig, config, userAgent = navigator.userAgent.toLowerCase(), manifestCodec = audioCodec, adtsSampleingRates = [96e3, 88200, 64e3, 48e3, 44100, 32e3, 24e3, 22050, 16e3, 12e3, 11025, 8e3, 7350];
                adtsObjectType = ((data[offset + 2] & 192) >>> 6) + 1;
                adtsSampleingIndex = (data[offset + 2] & 60) >>> 2;
                if (adtsSampleingIndex > adtsSampleingRates.length - 1) {
                  observer.trigger(events["default"].ERROR, {
                    type: errors["ErrorTypes"].MEDIA_ERROR,
                    details: errors["ErrorDetails"].FRAG_PARSING_ERROR,
                    fatal: true,
                    reason: "invalid ADTS sampling index:" + adtsSampleingIndex
                  });
                  return;
                }
                adtsChanelConfig = (data[offset + 2] & 1) << 2;
                adtsChanelConfig |= (data[offset + 3] & 192) >>> 6;
                logger["logger"].log("manifest codec:" + audioCodec + ",ADTS data:type:" + adtsObjectType + ",sampleingIndex:" + adtsSampleingIndex + "[" + adtsSampleingRates[adtsSampleingIndex] + "Hz],channelConfig:" + adtsChanelConfig);
                if (/firefox/i.test(userAgent)) {
                  if (adtsSampleingIndex >= 6) {
                    adtsObjectType = 5;
                    config = new Array(4);
                    adtsExtensionSampleingIndex = adtsSampleingIndex - 3;
                  } else {
                    adtsObjectType = 2;
                    config = new Array(2);
                    adtsExtensionSampleingIndex = adtsSampleingIndex;
                  }
                } else if (userAgent.indexOf("android") !== -1) {
                  adtsObjectType = 2;
                  config = new Array(2);
                  adtsExtensionSampleingIndex = adtsSampleingIndex;
                } else {
                  adtsObjectType = 5;
                  config = new Array(4);
                  if (audioCodec && (audioCodec.indexOf("mp4a.40.29") !== -1 || audioCodec.indexOf("mp4a.40.5") !== -1) || !audioCodec && adtsSampleingIndex >= 6) {
                    adtsExtensionSampleingIndex = adtsSampleingIndex - 3;
                  } else {
                    if (audioCodec && audioCodec.indexOf("mp4a.40.2") !== -1 && (adtsSampleingIndex >= 6 && adtsChanelConfig === 1 || /vivaldi/i.test(userAgent)) || !audioCodec && adtsChanelConfig === 1) {
                      adtsObjectType = 2;
                      config = new Array(2);
                    }
                    adtsExtensionSampleingIndex = adtsSampleingIndex;
                  }
                }
                config[0] = adtsObjectType << 3;
                config[0] |= (adtsSampleingIndex & 14) >> 1;
                config[1] |= (adtsSampleingIndex & 1) << 7;
                config[1] |= adtsChanelConfig << 3;
                if (adtsObjectType === 5) {
                  config[1] |= (adtsExtensionSampleingIndex & 14) >> 1;
                  config[2] = (adtsExtensionSampleingIndex & 1) << 7;
                  config[2] |= 2 << 2;
                  config[3] = 0;
                }
                return {
                  config,
                  samplerate: adtsSampleingRates[adtsSampleingIndex],
                  channelCount: adtsChanelConfig,
                  codec: "mp4a.40." + adtsObjectType,
                  manifestCodec
                };
              }
              function isHeaderPattern(data, offset) {
                return data[offset] === 255 && (data[offset + 1] & 246) === 240;
              }
              function getHeaderLength(data, offset) {
                return data[offset + 1] & 1 ? 7 : 9;
              }
              function getFullFrameLength(data, offset) {
                return (data[offset + 3] & 3) << 11 | data[offset + 4] << 3 | (data[offset + 5] & 224) >>> 5;
              }
              function isHeader(data, offset) {
                if (offset + 1 < data.length && isHeaderPattern(data, offset)) {
                  return true;
                }
                return false;
              }
              function adts_probe(data, offset) {
                if (isHeader(data, offset)) {
                  var headerLength = getHeaderLength(data, offset);
                  if (offset + headerLength >= data.length) {
                    return false;
                  }
                  var frameLength = getFullFrameLength(data, offset);
                  if (frameLength <= headerLength) {
                    return false;
                  }
                  var newOffset = offset + frameLength;
                  if (newOffset === data.length || newOffset + 1 < data.length && isHeaderPattern(data, newOffset)) {
                    return true;
                  }
                }
                return false;
              }
              function initTrackConfig(track, observer, data, offset, audioCodec) {
                if (!track.samplerate) {
                  var config = getAudioConfig(observer, data, offset, audioCodec);
                  track.config = config.config;
                  track.samplerate = config.samplerate;
                  track.channelCount = config.channelCount;
                  track.codec = config.codec;
                  track.manifestCodec = config.manifestCodec;
                  logger["logger"].log("parsed codec:" + track.codec + ",rate:" + config.samplerate + ",nb channel:" + config.channelCount);
                }
              }
              function getFrameDuration(samplerate) {
                return 1024 * 9e4 / samplerate;
              }
              function parseFrameHeader(data, offset, pts, frameIndex, frameDuration) {
                var headerLength, frameLength, stamp;
                var length = data.length;
                headerLength = getHeaderLength(data, offset);
                frameLength = getFullFrameLength(data, offset);
                frameLength -= headerLength;
                if (frameLength > 0 && offset + headerLength + frameLength <= length) {
                  stamp = pts + frameIndex * frameDuration;
                  return {
                    headerLength,
                    frameLength,
                    stamp
                  };
                }
                return void 0;
              }
              function appendFrame(track, data, offset, pts, frameIndex) {
                var frameDuration = getFrameDuration(track.samplerate);
                var header = parseFrameHeader(data, offset, pts, frameIndex, frameDuration);
                if (header) {
                  var stamp = header.stamp;
                  var headerLength = header.headerLength;
                  var frameLength = header.frameLength;
                  var aacSample = {
                    unit: data.subarray(offset + headerLength, offset + headerLength + frameLength),
                    pts: stamp,
                    dts: stamp
                  };
                  track.samples.push(aacSample);
                  return {
                    sample: aacSample,
                    length: frameLength + headerLength
                  };
                }
                return void 0;
              }
              var id3 = __webpack_require__("./src/demux/id3.js");
              var aacdemuxer_AACDemuxer = function() {
                function AACDemuxer(observer, remuxer, config) {
                  this.observer = observer;
                  this.config = config;
                  this.remuxer = remuxer;
                }
                var _proto = AACDemuxer.prototype;
                _proto.resetInitSegment = function resetInitSegment(initSegment, audioCodec, videoCodec, duration) {
                  this._audioTrack = {
                    container: "audio/adts",
                    type: "audio",
                    id: 0,
                    sequenceNumber: 0,
                    isAAC: true,
                    samples: [],
                    len: 0,
                    manifestCodec: audioCodec,
                    duration,
                    inputTimeScale: 9e4
                  };
                };
                _proto.resetTimeStamp = function resetTimeStamp() {
                };
                AACDemuxer.probe = function probe(data) {
                  if (!data) {
                    return false;
                  }
                  var id3Data = id3["default"].getID3Data(data, 0) || [];
                  var offset = id3Data.length;
                  for (var length = data.length; offset < length; offset++) {
                    if (adts_probe(data, offset)) {
                      logger["logger"].log("ADTS sync word found !");
                      return true;
                    }
                  }
                  return false;
                };
                _proto.append = function append(data, timeOffset, contiguous, accurateTimeOffset) {
                  var track = this._audioTrack;
                  var id3Data = id3["default"].getID3Data(data, 0) || [];
                  var timestamp = id3["default"].getTimeStamp(id3Data);
                  var pts = Object(number["isFiniteNumber"])(timestamp) ? timestamp * 90 : timeOffset * 9e4;
                  var frameIndex = 0;
                  var stamp = pts;
                  var length = data.length;
                  var offset = id3Data.length;
                  var id3Samples = [{
                    pts: stamp,
                    dts: stamp,
                    data: id3Data
                  }];
                  while (offset < length - 1) {
                    if (isHeader(data, offset) && offset + 5 < length) {
                      initTrackConfig(track, this.observer, data, offset, track.manifestCodec);
                      var frame = appendFrame(track, data, offset, pts, frameIndex);
                      if (frame) {
                        offset += frame.length;
                        stamp = frame.sample.pts;
                        frameIndex++;
                      } else {
                        logger["logger"].log("Unable to parse AAC frame");
                        break;
                      }
                    } else if (id3["default"].isHeader(data, offset)) {
                      id3Data = id3["default"].getID3Data(data, offset);
                      id3Samples.push({
                        pts: stamp,
                        dts: stamp,
                        data: id3Data
                      });
                      offset += id3Data.length;
                    } else {
                      offset++;
                    }
                  }
                  this.remuxer.remux(track, {
                    samples: []
                  }, {
                    samples: id3Samples,
                    inputTimeScale: 9e4
                  }, {
                    samples: []
                  }, timeOffset, contiguous, accurateTimeOffset);
                };
                _proto.destroy = function destroy() {
                };
                return AACDemuxer;
              }();
              var aacdemuxer = aacdemuxer_AACDemuxer;
              var mp4demuxer = __webpack_require__("./src/demux/mp4demuxer.js");
              var MpegAudio = {
                BitratesMap: [32, 64, 96, 128, 160, 192, 224, 256, 288, 320, 352, 384, 416, 448, 32, 48, 56, 64, 80, 96, 112, 128, 160, 192, 224, 256, 320, 384, 32, 40, 48, 56, 64, 80, 96, 112, 128, 160, 192, 224, 256, 320, 32, 48, 56, 64, 80, 96, 112, 128, 144, 160, 176, 192, 224, 256, 8, 16, 24, 32, 40, 48, 56, 64, 80, 96, 112, 128, 144, 160],
                SamplingRateMap: [44100, 48e3, 32e3, 22050, 24e3, 16e3, 11025, 12e3, 8e3],
                SamplesCoefficients: [
                  // MPEG 2.5
                  [
                    0,
                    // Reserved
                    72,
                    // Layer3
                    144,
                    // Layer2
                    12
                    // Layer1
                  ],
                  // Reserved
                  [
                    0,
                    // Reserved
                    0,
                    // Layer3
                    0,
                    // Layer2
                    0
                    // Layer1
                  ],
                  // MPEG 2
                  [
                    0,
                    // Reserved
                    72,
                    // Layer3
                    144,
                    // Layer2
                    12
                    // Layer1
                  ],
                  // MPEG 1
                  [
                    0,
                    // Reserved
                    144,
                    // Layer3
                    144,
                    // Layer2
                    12
                    // Layer1
                  ]
                ],
                BytesInSlot: [
                  0,
                  // Reserved
                  1,
                  // Layer3
                  1,
                  // Layer2
                  4
                  // Layer1
                ],
                appendFrame: function appendFrame2(track, data, offset, pts, frameIndex) {
                  if (offset + 24 > data.length) {
                    return void 0;
                  }
                  var header = this.parseHeader(data, offset);
                  if (header && offset + header.frameLength <= data.length) {
                    var frameDuration = header.samplesPerFrame * 9e4 / header.sampleRate;
                    var stamp = pts + frameIndex * frameDuration;
                    var sample = {
                      unit: data.subarray(offset, offset + header.frameLength),
                      pts: stamp,
                      dts: stamp
                    };
                    track.config = [];
                    track.channelCount = header.channelCount;
                    track.samplerate = header.sampleRate;
                    track.samples.push(sample);
                    return {
                      sample,
                      length: header.frameLength
                    };
                  }
                  return void 0;
                },
                parseHeader: function parseHeader(data, offset) {
                  var headerB = data[offset + 1] >> 3 & 3;
                  var headerC = data[offset + 1] >> 1 & 3;
                  var headerE = data[offset + 2] >> 4 & 15;
                  var headerF = data[offset + 2] >> 2 & 3;
                  var headerG = data[offset + 2] >> 1 & 1;
                  if (headerB !== 1 && headerE !== 0 && headerE !== 15 && headerF !== 3) {
                    var columnInBitrates = headerB === 3 ? 3 - headerC : headerC === 3 ? 3 : 4;
                    var bitRate = MpegAudio.BitratesMap[columnInBitrates * 14 + headerE - 1] * 1e3;
                    var columnInSampleRates = headerB === 3 ? 0 : headerB === 2 ? 1 : 2;
                    var sampleRate = MpegAudio.SamplingRateMap[columnInSampleRates * 3 + headerF];
                    var channelCount = data[offset + 3] >> 6 === 3 ? 1 : 2;
                    var sampleCoefficient = MpegAudio.SamplesCoefficients[headerB][headerC];
                    var bytesInSlot = MpegAudio.BytesInSlot[headerC];
                    var samplesPerFrame = sampleCoefficient * 8 * bytesInSlot;
                    var frameLength = parseInt(sampleCoefficient * bitRate / sampleRate + headerG, 10) * bytesInSlot;
                    return {
                      sampleRate,
                      channelCount,
                      frameLength,
                      samplesPerFrame
                    };
                  }
                  return void 0;
                },
                isHeaderPattern: function isHeaderPattern2(data, offset) {
                  return data[offset] === 255 && (data[offset + 1] & 224) === 224 && (data[offset + 1] & 6) !== 0;
                },
                isHeader: function isHeader2(data, offset) {
                  if (offset + 1 < data.length && this.isHeaderPattern(data, offset)) {
                    return true;
                  }
                  return false;
                },
                probe: function probe(data, offset) {
                  if (offset + 1 < data.length && this.isHeaderPattern(data, offset)) {
                    var headerLength = 4;
                    var header = this.parseHeader(data, offset);
                    var frameLength = headerLength;
                    if (header && header.frameLength) {
                      frameLength = header.frameLength;
                    }
                    var newOffset = offset + frameLength;
                    if (newOffset === data.length || newOffset + 1 < data.length && this.isHeaderPattern(data, newOffset)) {
                      return true;
                    }
                  }
                  return false;
                }
              };
              var mpegaudio = MpegAudio;
              var exp_golomb_ExpGolomb = function() {
                function ExpGolomb(data) {
                  this.data = data;
                  this.bytesAvailable = data.byteLength;
                  this.word = 0;
                  this.bitsAvailable = 0;
                }
                var _proto = ExpGolomb.prototype;
                _proto.loadWord = function loadWord() {
                  var data = this.data, bytesAvailable = this.bytesAvailable, position = data.byteLength - bytesAvailable, workingBytes = new Uint8Array(4), availableBytes = Math.min(4, bytesAvailable);
                  if (availableBytes === 0) {
                    throw new Error("no bytes available");
                  }
                  workingBytes.set(data.subarray(position, position + availableBytes));
                  this.word = new DataView(workingBytes.buffer).getUint32(0);
                  this.bitsAvailable = availableBytes * 8;
                  this.bytesAvailable -= availableBytes;
                };
                _proto.skipBits = function skipBits(count) {
                  var skipBytes;
                  if (this.bitsAvailable > count) {
                    this.word <<= count;
                    this.bitsAvailable -= count;
                  } else {
                    count -= this.bitsAvailable;
                    skipBytes = count >> 3;
                    count -= skipBytes >> 3;
                    this.bytesAvailable -= skipBytes;
                    this.loadWord();
                    this.word <<= count;
                    this.bitsAvailable -= count;
                  }
                };
                _proto.readBits = function readBits(size) {
                  var bits = Math.min(this.bitsAvailable, size), valu = this.word >>> 32 - bits;
                  if (size > 32) {
                    logger["logger"].error("Cannot read more than 32 bits at a time");
                  }
                  this.bitsAvailable -= bits;
                  if (this.bitsAvailable > 0) {
                    this.word <<= bits;
                  } else if (this.bytesAvailable > 0) {
                    this.loadWord();
                  }
                  bits = size - bits;
                  if (bits > 0 && this.bitsAvailable) {
                    return valu << bits | this.readBits(bits);
                  } else {
                    return valu;
                  }
                };
                _proto.skipLZ = function skipLZ() {
                  var leadingZeroCount;
                  for (leadingZeroCount = 0; leadingZeroCount < this.bitsAvailable; ++leadingZeroCount) {
                    if ((this.word & 2147483648 >>> leadingZeroCount) !== 0) {
                      this.word <<= leadingZeroCount;
                      this.bitsAvailable -= leadingZeroCount;
                      return leadingZeroCount;
                    }
                  }
                  this.loadWord();
                  return leadingZeroCount + this.skipLZ();
                };
                _proto.skipUEG = function skipUEG() {
                  this.skipBits(1 + this.skipLZ());
                };
                _proto.skipEG = function skipEG() {
                  this.skipBits(1 + this.skipLZ());
                };
                _proto.readUEG = function readUEG() {
                  var clz = this.skipLZ();
                  return this.readBits(clz + 1) - 1;
                };
                _proto.readEG = function readEG() {
                  var valu = this.readUEG();
                  if (1 & valu) {
                    return 1 + valu >>> 1;
                  } else {
                    return -1 * (valu >>> 1);
                  }
                };
                _proto.readBoolean = function readBoolean() {
                  return this.readBits(1) === 1;
                };
                _proto.readUByte = function readUByte() {
                  return this.readBits(8);
                };
                _proto.readUShort = function readUShort() {
                  return this.readBits(16);
                };
                _proto.readUInt = function readUInt() {
                  return this.readBits(32);
                };
                _proto.skipScalingList = function skipScalingList(count) {
                  var lastScale = 8, nextScale = 8, j, deltaScale;
                  for (j = 0; j < count; j++) {
                    if (nextScale !== 0) {
                      deltaScale = this.readEG();
                      nextScale = (lastScale + deltaScale + 256) % 256;
                    }
                    lastScale = nextScale === 0 ? lastScale : nextScale;
                  }
                };
                _proto.readSPS = function readSPS() {
                  var frameCropLeftOffset = 0, frameCropRightOffset = 0, frameCropTopOffset = 0, frameCropBottomOffset = 0, profileIdc, profileCompat, levelIdc, numRefFramesInPicOrderCntCycle, picWidthInMbsMinus1, picHeightInMapUnitsMinus1, frameMbsOnlyFlag, scalingListCount, i, readUByte = this.readUByte.bind(this), readBits = this.readBits.bind(this), readUEG = this.readUEG.bind(this), readBoolean = this.readBoolean.bind(this), skipBits = this.skipBits.bind(this), skipEG = this.skipEG.bind(this), skipUEG = this.skipUEG.bind(this), skipScalingList = this.skipScalingList.bind(this);
                  readUByte();
                  profileIdc = readUByte();
                  profileCompat = readBits(5);
                  skipBits(3);
                  levelIdc = readUByte();
                  skipUEG();
                  if (profileIdc === 100 || profileIdc === 110 || profileIdc === 122 || profileIdc === 244 || profileIdc === 44 || profileIdc === 83 || profileIdc === 86 || profileIdc === 118 || profileIdc === 128) {
                    var chromaFormatIdc = readUEG();
                    if (chromaFormatIdc === 3) {
                      skipBits(1);
                    }
                    skipUEG();
                    skipUEG();
                    skipBits(1);
                    if (readBoolean()) {
                      scalingListCount = chromaFormatIdc !== 3 ? 8 : 12;
                      for (i = 0; i < scalingListCount; i++) {
                        if (readBoolean()) {
                          if (i < 6) {
                            skipScalingList(16);
                          } else {
                            skipScalingList(64);
                          }
                        }
                      }
                    }
                  }
                  skipUEG();
                  var picOrderCntType = readUEG();
                  if (picOrderCntType === 0) {
                    readUEG();
                  } else if (picOrderCntType === 1) {
                    skipBits(1);
                    skipEG();
                    skipEG();
                    numRefFramesInPicOrderCntCycle = readUEG();
                    for (i = 0; i < numRefFramesInPicOrderCntCycle; i++) {
                      skipEG();
                    }
                  }
                  skipUEG();
                  skipBits(1);
                  picWidthInMbsMinus1 = readUEG();
                  picHeightInMapUnitsMinus1 = readUEG();
                  frameMbsOnlyFlag = readBits(1);
                  if (frameMbsOnlyFlag === 0) {
                    skipBits(1);
                  }
                  skipBits(1);
                  if (readBoolean()) {
                    frameCropLeftOffset = readUEG();
                    frameCropRightOffset = readUEG();
                    frameCropTopOffset = readUEG();
                    frameCropBottomOffset = readUEG();
                  }
                  var pixelRatio = [1, 1];
                  if (readBoolean()) {
                    if (readBoolean()) {
                      var aspectRatioIdc = readUByte();
                      switch (aspectRatioIdc) {
                        case 1:
                          pixelRatio = [1, 1];
                          break;
                        case 2:
                          pixelRatio = [12, 11];
                          break;
                        case 3:
                          pixelRatio = [10, 11];
                          break;
                        case 4:
                          pixelRatio = [16, 11];
                          break;
                        case 5:
                          pixelRatio = [40, 33];
                          break;
                        case 6:
                          pixelRatio = [24, 11];
                          break;
                        case 7:
                          pixelRatio = [20, 11];
                          break;
                        case 8:
                          pixelRatio = [32, 11];
                          break;
                        case 9:
                          pixelRatio = [80, 33];
                          break;
                        case 10:
                          pixelRatio = [18, 11];
                          break;
                        case 11:
                          pixelRatio = [15, 11];
                          break;
                        case 12:
                          pixelRatio = [64, 33];
                          break;
                        case 13:
                          pixelRatio = [160, 99];
                          break;
                        case 14:
                          pixelRatio = [4, 3];
                          break;
                        case 15:
                          pixelRatio = [3, 2];
                          break;
                        case 16:
                          pixelRatio = [2, 1];
                          break;
                        case 255: {
                          pixelRatio = [readUByte() << 8 | readUByte(), readUByte() << 8 | readUByte()];
                          break;
                        }
                      }
                    }
                  }
                  return {
                    width: Math.ceil((picWidthInMbsMinus1 + 1) * 16 - frameCropLeftOffset * 2 - frameCropRightOffset * 2),
                    height: (2 - frameMbsOnlyFlag) * (picHeightInMapUnitsMinus1 + 1) * 16 - (frameMbsOnlyFlag ? 2 : 4) * (frameCropTopOffset + frameCropBottomOffset),
                    pixelRatio
                  };
                };
                _proto.readSliceType = function readSliceType() {
                  this.readUByte();
                  this.readUEG();
                  return this.readUEG();
                };
                return ExpGolomb;
              }();
              var exp_golomb = exp_golomb_ExpGolomb;
              var sample_aes_SampleAesDecrypter = function() {
                function SampleAesDecrypter(observer, config, decryptdata, discardEPB) {
                  this.decryptdata = decryptdata;
                  this.discardEPB = discardEPB;
                  this.decrypter = new crypt_decrypter["default"](observer, config, {
                    removePKCS7Padding: false
                  });
                }
                var _proto = SampleAesDecrypter.prototype;
                _proto.decryptBuffer = function decryptBuffer(encryptedData, callback) {
                  this.decrypter.decrypt(encryptedData, this.decryptdata.key.buffer, this.decryptdata.iv.buffer, callback);
                };
                _proto.decryptAacSample = function decryptAacSample(samples, sampleIndex, callback, sync) {
                  var curUnit = samples[sampleIndex].unit;
                  var encryptedData = curUnit.subarray(16, curUnit.length - curUnit.length % 16);
                  var encryptedBuffer = encryptedData.buffer.slice(encryptedData.byteOffset, encryptedData.byteOffset + encryptedData.length);
                  var localthis = this;
                  this.decryptBuffer(encryptedBuffer, function(decryptedData) {
                    decryptedData = new Uint8Array(decryptedData);
                    curUnit.set(decryptedData, 16);
                    if (!sync) {
                      localthis.decryptAacSamples(samples, sampleIndex + 1, callback);
                    }
                  });
                };
                _proto.decryptAacSamples = function decryptAacSamples(samples, sampleIndex, callback) {
                  for (; ; sampleIndex++) {
                    if (sampleIndex >= samples.length) {
                      callback();
                      return;
                    }
                    if (samples[sampleIndex].unit.length < 32) {
                      continue;
                    }
                    var sync = this.decrypter.isSync();
                    this.decryptAacSample(samples, sampleIndex, callback, sync);
                    if (!sync) {
                      return;
                    }
                  }
                };
                _proto.getAvcEncryptedData = function getAvcEncryptedData(decodedData) {
                  var encryptedDataLen = Math.floor((decodedData.length - 48) / 160) * 16 + 16;
                  var encryptedData = new Int8Array(encryptedDataLen);
                  var outputPos = 0;
                  for (var inputPos = 32; inputPos <= decodedData.length - 16; inputPos += 160, outputPos += 16) {
                    encryptedData.set(decodedData.subarray(inputPos, inputPos + 16), outputPos);
                  }
                  return encryptedData;
                };
                _proto.getAvcDecryptedUnit = function getAvcDecryptedUnit(decodedData, decryptedData) {
                  decryptedData = new Uint8Array(decryptedData);
                  var inputPos = 0;
                  for (var outputPos = 32; outputPos <= decodedData.length - 16; outputPos += 160, inputPos += 16) {
                    decodedData.set(decryptedData.subarray(inputPos, inputPos + 16), outputPos);
                  }
                  return decodedData;
                };
                _proto.decryptAvcSample = function decryptAvcSample(samples, sampleIndex, unitIndex, callback, curUnit, sync) {
                  var decodedData = this.discardEPB(curUnit.data);
                  var encryptedData = this.getAvcEncryptedData(decodedData);
                  var localthis = this;
                  this.decryptBuffer(encryptedData.buffer, function(decryptedData) {
                    curUnit.data = localthis.getAvcDecryptedUnit(decodedData, decryptedData);
                    if (!sync) {
                      localthis.decryptAvcSamples(samples, sampleIndex, unitIndex + 1, callback);
                    }
                  });
                };
                _proto.decryptAvcSamples = function decryptAvcSamples(samples, sampleIndex, unitIndex, callback) {
                  for (; ; sampleIndex++, unitIndex = 0) {
                    if (sampleIndex >= samples.length) {
                      callback();
                      return;
                    }
                    var curUnits = samples[sampleIndex].units;
                    for (; ; unitIndex++) {
                      if (unitIndex >= curUnits.length) {
                        break;
                      }
                      var curUnit = curUnits[unitIndex];
                      if (curUnit.data.length <= 48 || curUnit.type !== 1 && curUnit.type !== 5) {
                        continue;
                      }
                      var sync = this.decrypter.isSync();
                      this.decryptAvcSample(samples, sampleIndex, unitIndex, callback, curUnit, sync);
                      if (!sync) {
                        return;
                      }
                    }
                  }
                };
                return SampleAesDecrypter;
              }();
              var sample_aes = sample_aes_SampleAesDecrypter;
              var RemuxerTrackIdConfig = {
                video: 1,
                audio: 2,
                id3: 3,
                text: 4
              };
              var tsdemuxer_TSDemuxer = function() {
                function TSDemuxer(observer, remuxer, config, typeSupported) {
                  this.observer = observer;
                  this.config = config;
                  this.typeSupported = typeSupported;
                  this.remuxer = remuxer;
                  this.sampleAes = null;
                  this.pmtUnknownTypes = {};
                }
                var _proto = TSDemuxer.prototype;
                _proto.setDecryptData = function setDecryptData(decryptdata) {
                  if (decryptdata != null && decryptdata.key != null && decryptdata.method === "SAMPLE-AES") {
                    this.sampleAes = new sample_aes(this.observer, this.config, decryptdata, this.discardEPB);
                  } else {
                    this.sampleAes = null;
                  }
                };
                TSDemuxer.probe = function probe(data) {
                  var syncOffset = TSDemuxer._syncOffset(data);
                  if (syncOffset < 0) {
                    return false;
                  } else {
                    if (syncOffset) {
                      logger["logger"].warn("MPEG2-TS detected but first sync word found @ offset " + syncOffset + ", junk ahead ?");
                    }
                    return true;
                  }
                };
                TSDemuxer._syncOffset = function _syncOffset(data) {
                  var scanwindow = Math.min(1e3, data.length - 3 * 188);
                  var i = 0;
                  while (i < scanwindow) {
                    if (data[i] === 71 && data[i + 188] === 71 && data[i + 2 * 188] === 71) {
                      return i;
                    } else {
                      i++;
                    }
                  }
                  return -1;
                };
                TSDemuxer.createTrack = function createTrack(type, duration) {
                  return {
                    container: type === "video" || type === "audio" ? "video/mp2t" : void 0,
                    type,
                    id: RemuxerTrackIdConfig[type],
                    pid: -1,
                    inputTimeScale: 9e4,
                    sequenceNumber: 0,
                    samples: [],
                    dropped: type === "video" ? 0 : void 0,
                    isAAC: type === "audio" ? true : void 0,
                    duration: type === "audio" ? duration : void 0
                  };
                };
                _proto.resetInitSegment = function resetInitSegment(initSegment, audioCodec, videoCodec, duration) {
                  this.pmtParsed = false;
                  this._pmtId = -1;
                  this.pmtUnknownTypes = {};
                  this._avcTrack = TSDemuxer.createTrack("video", duration);
                  this._audioTrack = TSDemuxer.createTrack("audio", duration);
                  this._id3Track = TSDemuxer.createTrack("id3", duration);
                  this._txtTrack = TSDemuxer.createTrack("text", duration);
                  this.aacOverFlow = null;
                  this.aacLastPTS = null;
                  this.avcSample = null;
                  this.audioCodec = audioCodec;
                  this.videoCodec = videoCodec;
                  this._duration = duration;
                };
                _proto.resetTimeStamp = function resetTimeStamp() {
                };
                _proto.append = function append(data, timeOffset, contiguous, accurateTimeOffset) {
                  var start, len = data.length, stt, pid, atf, offset, pes, unknownPIDs = false;
                  this.pmtUnknownTypes = {};
                  this.contiguous = contiguous;
                  var pmtParsed = this.pmtParsed, avcTrack = this._avcTrack, audioTrack = this._audioTrack, id3Track = this._id3Track, avcId = avcTrack.pid, audioId = audioTrack.pid, id3Id = id3Track.pid, pmtId = this._pmtId, avcData = avcTrack.pesData, audioData = audioTrack.pesData, id3Data = id3Track.pesData, parsePAT = this._parsePAT, parsePMT = this._parsePMT.bind(this), parsePES = this._parsePES, parseAVCPES = this._parseAVCPES.bind(this), parseAACPES = this._parseAACPES.bind(this), parseMPEGPES = this._parseMPEGPES.bind(this), parseID3PES = this._parseID3PES.bind(this);
                  var syncOffset = TSDemuxer._syncOffset(data);
                  len -= (len + syncOffset) % 188;
                  for (start = syncOffset; start < len; start += 188) {
                    if (data[start] === 71) {
                      stt = !!(data[start + 1] & 64);
                      pid = ((data[start + 1] & 31) << 8) + data[start + 2];
                      atf = (data[start + 3] & 48) >> 4;
                      if (atf > 1) {
                        offset = start + 5 + data[start + 4];
                        if (offset === start + 188) {
                          continue;
                        }
                      } else {
                        offset = start + 4;
                      }
                      switch (pid) {
                        case avcId:
                          if (stt) {
                            if (avcData && (pes = parsePES(avcData))) {
                              parseAVCPES(pes, false);
                            }
                            avcData = {
                              data: [],
                              size: 0
                            };
                          }
                          if (avcData) {
                            avcData.data.push(data.subarray(offset, start + 188));
                            avcData.size += start + 188 - offset;
                          }
                          break;
                        case audioId:
                          if (stt) {
                            if (audioData && (pes = parsePES(audioData))) {
                              if (audioTrack.isAAC) {
                                parseAACPES(pes);
                              } else {
                                parseMPEGPES(pes);
                              }
                            }
                            audioData = {
                              data: [],
                              size: 0
                            };
                          }
                          if (audioData) {
                            audioData.data.push(data.subarray(offset, start + 188));
                            audioData.size += start + 188 - offset;
                          }
                          break;
                        case id3Id:
                          if (stt) {
                            if (id3Data && (pes = parsePES(id3Data))) {
                              parseID3PES(pes);
                            }
                            id3Data = {
                              data: [],
                              size: 0
                            };
                          }
                          if (id3Data) {
                            id3Data.data.push(data.subarray(offset, start + 188));
                            id3Data.size += start + 188 - offset;
                          }
                          break;
                        case 0:
                          if (stt) {
                            offset += data[offset] + 1;
                          }
                          pmtId = this._pmtId = parsePAT(data, offset);
                          break;
                        case pmtId:
                          if (stt) {
                            offset += data[offset] + 1;
                          }
                          var parsedPIDs = parsePMT(data, offset, this.typeSupported.mpeg === true || this.typeSupported.mp3 === true, this.sampleAes != null);
                          avcId = parsedPIDs.avc;
                          if (avcId > 0) {
                            avcTrack.pid = avcId;
                          }
                          audioId = parsedPIDs.audio;
                          if (audioId > 0) {
                            audioTrack.pid = audioId;
                            audioTrack.isAAC = parsedPIDs.isAAC;
                          }
                          id3Id = parsedPIDs.id3;
                          if (id3Id > 0) {
                            id3Track.pid = id3Id;
                          }
                          if (unknownPIDs && !pmtParsed) {
                            logger["logger"].log("reparse from beginning");
                            unknownPIDs = false;
                            start = syncOffset - 188;
                          }
                          pmtParsed = this.pmtParsed = true;
                          break;
                        case 17:
                        case 8191:
                          break;
                        default:
                          unknownPIDs = true;
                          break;
                      }
                    } else {
                      this.observer.trigger(events["default"].ERROR, {
                        type: errors["ErrorTypes"].MEDIA_ERROR,
                        details: errors["ErrorDetails"].FRAG_PARSING_ERROR,
                        fatal: false,
                        reason: "TS packet did not start with 0x47"
                      });
                    }
                  }
                  if (avcData && (pes = parsePES(avcData))) {
                    parseAVCPES(pes, true);
                    avcTrack.pesData = null;
                  } else {
                    avcTrack.pesData = avcData;
                  }
                  if (audioData && (pes = parsePES(audioData))) {
                    if (audioTrack.isAAC) {
                      parseAACPES(pes);
                    } else {
                      parseMPEGPES(pes);
                    }
                    audioTrack.pesData = null;
                  } else {
                    if (audioData && audioData.size) {
                      logger["logger"].log("last AAC PES packet truncated,might overlap between fragments");
                    }
                    audioTrack.pesData = audioData;
                  }
                  if (id3Data && (pes = parsePES(id3Data))) {
                    parseID3PES(pes);
                    id3Track.pesData = null;
                  } else {
                    id3Track.pesData = id3Data;
                  }
                  if (this.sampleAes == null) {
                    this.remuxer.remux(audioTrack, avcTrack, id3Track, this._txtTrack, timeOffset, contiguous, accurateTimeOffset);
                  } else {
                    this.decryptAndRemux(audioTrack, avcTrack, id3Track, this._txtTrack, timeOffset, contiguous, accurateTimeOffset);
                  }
                };
                _proto.decryptAndRemux = function decryptAndRemux(audioTrack, videoTrack, id3Track, textTrack, timeOffset, contiguous, accurateTimeOffset) {
                  if (audioTrack.samples && audioTrack.isAAC) {
                    var localthis = this;
                    this.sampleAes.decryptAacSamples(audioTrack.samples, 0, function() {
                      localthis.decryptAndRemuxAvc(audioTrack, videoTrack, id3Track, textTrack, timeOffset, contiguous, accurateTimeOffset);
                    });
                  } else {
                    this.decryptAndRemuxAvc(audioTrack, videoTrack, id3Track, textTrack, timeOffset, contiguous, accurateTimeOffset);
                  }
                };
                _proto.decryptAndRemuxAvc = function decryptAndRemuxAvc(audioTrack, videoTrack, id3Track, textTrack, timeOffset, contiguous, accurateTimeOffset) {
                  if (videoTrack.samples) {
                    var localthis = this;
                    this.sampleAes.decryptAvcSamples(videoTrack.samples, 0, 0, function() {
                      localthis.remuxer.remux(audioTrack, videoTrack, id3Track, textTrack, timeOffset, contiguous, accurateTimeOffset);
                    });
                  } else {
                    this.remuxer.remux(audioTrack, videoTrack, id3Track, textTrack, timeOffset, contiguous, accurateTimeOffset);
                  }
                };
                _proto.destroy = function destroy() {
                  this._initPTS = this._initDTS = void 0;
                  this._duration = 0;
                };
                _proto._parsePAT = function _parsePAT(data, offset) {
                  return (data[offset + 10] & 31) << 8 | data[offset + 11];
                };
                _proto._trackUnknownPmt = function _trackUnknownPmt(type, logLevel, message) {
                  var result = this.pmtUnknownTypes[type] || 0;
                  if (result === 0) {
                    this.pmtUnknownTypes[type] = 0;
                    logLevel.call(logger["logger"], message);
                  }
                  this.pmtUnknownTypes[type]++;
                  return result;
                };
                _proto._parsePMT = function _parsePMT(data, offset, mpegSupported, isSampleAes) {
                  var sectionLength, tableEnd, programInfoLength, pid, result = {
                    audio: -1,
                    avc: -1,
                    id3: -1,
                    isAAC: true
                  };
                  sectionLength = (data[offset + 1] & 15) << 8 | data[offset + 2];
                  tableEnd = offset + 3 + sectionLength - 4;
                  programInfoLength = (data[offset + 10] & 15) << 8 | data[offset + 11];
                  offset += 12 + programInfoLength;
                  while (offset < tableEnd) {
                    pid = (data[offset + 1] & 31) << 8 | data[offset + 2];
                    switch (data[offset]) {
                      case 207:
                        if (!isSampleAes) {
                          this._trackUnknownPmt(data[offset], logger["logger"].warn, "ADTS AAC with AES-128-CBC frame encryption found in unencrypted stream");
                          break;
                        }
                      case 15:
                        if (result.audio === -1) {
                          result.audio = pid;
                        }
                        break;
                      case 21:
                        if (result.id3 === -1) {
                          result.id3 = pid;
                        }
                        break;
                      case 219:
                        if (!isSampleAes) {
                          this._trackUnknownPmt(data[offset], logger["logger"].warn, "H.264 with AES-128-CBC slice encryption found in unencrypted stream");
                          break;
                        }
                      case 27:
                        if (result.avc === -1) {
                          result.avc = pid;
                        }
                        break;
                      case 3:
                      case 4:
                        if (!mpegSupported) {
                          this._trackUnknownPmt(data[offset], logger["logger"].warn, "MPEG audio found, not supported in this browser");
                        } else if (result.audio === -1) {
                          result.audio = pid;
                          result.isAAC = false;
                        }
                        break;
                      case 36:
                        this._trackUnknownPmt(data[offset], logger["logger"].warn, "Unsupported HEVC stream type found");
                        break;
                      default:
                        this._trackUnknownPmt(data[offset], logger["logger"].log, "Unknown stream type:" + data[offset]);
                        break;
                    }
                    offset += ((data[offset + 3] & 15) << 8 | data[offset + 4]) + 5;
                  }
                  return result;
                };
                _proto._parsePES = function _parsePES(stream) {
                  var i = 0, frag, pesFlags, pesPrefix, pesLen, pesHdrLen, pesData, pesPts, pesDts, payloadStartOffset, data = stream.data;
                  if (!stream || stream.size === 0) {
                    return null;
                  }
                  while (data[0].length < 19 && data.length > 1) {
                    var newData = new Uint8Array(data[0].length + data[1].length);
                    newData.set(data[0]);
                    newData.set(data[1], data[0].length);
                    data[0] = newData;
                    data.splice(1, 1);
                  }
                  frag = data[0];
                  pesPrefix = (frag[0] << 16) + (frag[1] << 8) + frag[2];
                  if (pesPrefix === 1) {
                    pesLen = (frag[4] << 8) + frag[5];
                    if (pesLen && pesLen > stream.size - 6) {
                      return null;
                    }
                    pesFlags = frag[7];
                    if (pesFlags & 192) {
                      pesPts = (frag[9] & 14) * 536870912 + // 1 << 29
                      (frag[10] & 255) * 4194304 + // 1 << 22
                      (frag[11] & 254) * 16384 + // 1 << 14
                      (frag[12] & 255) * 128 + // 1 << 7
                      (frag[13] & 254) / 2;
                      if (pesFlags & 64) {
                        pesDts = (frag[14] & 14) * 536870912 + // 1 << 29
                        (frag[15] & 255) * 4194304 + // 1 << 22
                        (frag[16] & 254) * 16384 + // 1 << 14
                        (frag[17] & 255) * 128 + // 1 << 7
                        (frag[18] & 254) / 2;
                        if (pesPts - pesDts > 60 * 9e4) {
                          logger["logger"].warn(Math.round((pesPts - pesDts) / 9e4) + "s delta between PTS and DTS, align them");
                          pesPts = pesDts;
                        }
                      } else {
                        pesDts = pesPts;
                      }
                    }
                    pesHdrLen = frag[8];
                    payloadStartOffset = pesHdrLen + 9;
                    if (stream.size <= payloadStartOffset) {
                      return null;
                    }
                    stream.size -= payloadStartOffset;
                    pesData = new Uint8Array(stream.size);
                    for (var j = 0, dataLen = data.length; j < dataLen; j++) {
                      frag = data[j];
                      var len = frag.byteLength;
                      if (payloadStartOffset) {
                        if (payloadStartOffset > len) {
                          payloadStartOffset -= len;
                          continue;
                        } else {
                          frag = frag.subarray(payloadStartOffset);
                          len -= payloadStartOffset;
                          payloadStartOffset = 0;
                        }
                      }
                      pesData.set(frag, i);
                      i += len;
                    }
                    if (pesLen) {
                      pesLen -= pesHdrLen + 3;
                    }
                    return {
                      data: pesData,
                      pts: pesPts,
                      dts: pesDts,
                      len: pesLen
                    };
                  } else {
                    return null;
                  }
                };
                _proto.pushAccesUnit = function pushAccesUnit(avcSample, avcTrack) {
                  if (avcSample.units.length && avcSample.frame) {
                    var samples = avcTrack.samples;
                    var nbSamples = samples.length;
                    if (isNaN(avcSample.pts)) {
                      if (nbSamples) {
                        var lastSample = samples[nbSamples - 1];
                        avcSample.pts = lastSample.pts;
                        avcSample.dts = lastSample.dts;
                      } else {
                        avcTrack.dropped++;
                        return;
                      }
                    }
                    if (!this.config.forceKeyFrameOnDiscontinuity || avcSample.key === true || avcTrack.sps && (nbSamples || this.contiguous)) {
                      avcSample.id = nbSamples;
                      samples.push(avcSample);
                    } else {
                      avcTrack.dropped++;
                    }
                  }
                  if (avcSample.debug.length) {
                    logger["logger"].log(avcSample.pts + "/" + avcSample.dts + ":" + avcSample.debug);
                  }
                };
                _proto._parseAVCPES = function _parseAVCPES(pes, last) {
                  var _this = this;
                  var track = this._avcTrack, units = this._parseAVCNALu(pes.data), debug = false, expGolombDecoder, avcSample = this.avcSample, push, spsfound = false, i, pushAccesUnit = this.pushAccesUnit.bind(this), createAVCSample = function createAVCSample2(key, pts, dts, debug2) {
                    return {
                      key,
                      pts,
                      dts,
                      units: [],
                      debug: debug2
                    };
                  };
                  pes.data = null;
                  if (avcSample && units.length && !track.audFound) {
                    pushAccesUnit(avcSample, track);
                    avcSample = this.avcSample = createAVCSample(false, pes.pts, pes.dts, "");
                  }
                  units.forEach(function(unit) {
                    switch (unit.type) {
                      case 1:
                        push = true;
                        if (!avcSample) {
                          avcSample = _this.avcSample = createAVCSample(true, pes.pts, pes.dts, "");
                        }
                        if (debug) {
                          avcSample.debug += "NDR ";
                        }
                        avcSample.frame = true;
                        var data = unit.data;
                        if (spsfound && data.length > 4) {
                          var sliceType = new exp_golomb(data).readSliceType();
                          if (sliceType === 2 || sliceType === 4 || sliceType === 7 || sliceType === 9) {
                            avcSample.key = true;
                          }
                        }
                        break;
                      case 5:
                        push = true;
                        if (!avcSample) {
                          avcSample = _this.avcSample = createAVCSample(true, pes.pts, pes.dts, "");
                        }
                        if (debug) {
                          avcSample.debug += "IDR ";
                        }
                        avcSample.key = true;
                        avcSample.frame = true;
                        break;
                      case 6:
                        push = true;
                        if (debug && avcSample) {
                          avcSample.debug += "SEI ";
                        }
                        expGolombDecoder = new exp_golomb(_this.discardEPB(unit.data));
                        expGolombDecoder.readUByte();
                        var payloadType = 0;
                        var payloadSize = 0;
                        var endOfCaptions = false;
                        var b = 0;
                        while (!endOfCaptions && expGolombDecoder.bytesAvailable > 1) {
                          payloadType = 0;
                          do {
                            b = expGolombDecoder.readUByte();
                            payloadType += b;
                          } while (b === 255);
                          payloadSize = 0;
                          do {
                            b = expGolombDecoder.readUByte();
                            payloadSize += b;
                          } while (b === 255);
                          if (payloadType === 4 && expGolombDecoder.bytesAvailable !== 0) {
                            endOfCaptions = true;
                            var countryCode = expGolombDecoder.readUByte();
                            if (countryCode === 181) {
                              var providerCode = expGolombDecoder.readUShort();
                              if (providerCode === 49) {
                                var userStructure = expGolombDecoder.readUInt();
                                if (userStructure === 1195456820) {
                                  var userDataType = expGolombDecoder.readUByte();
                                  if (userDataType === 3) {
                                    var firstByte = expGolombDecoder.readUByte();
                                    var secondByte = expGolombDecoder.readUByte();
                                    var totalCCs = 31 & firstByte;
                                    var byteArray = [firstByte, secondByte];
                                    for (i = 0; i < totalCCs; i++) {
                                      byteArray.push(expGolombDecoder.readUByte());
                                      byteArray.push(expGolombDecoder.readUByte());
                                      byteArray.push(expGolombDecoder.readUByte());
                                    }
                                    _this._insertSampleInOrder(_this._txtTrack.samples, {
                                      type: 3,
                                      pts: pes.pts,
                                      bytes: byteArray
                                    });
                                  }
                                }
                              }
                            }
                          } else if (payloadType === 5 && expGolombDecoder.bytesAvailable !== 0) {
                            endOfCaptions = true;
                            if (payloadSize > 16) {
                              var uuidStrArray = [];
                              for (i = 0; i < 16; i++) {
                                uuidStrArray.push(expGolombDecoder.readUByte().toString(16));
                                if (i === 3 || i === 5 || i === 7 || i === 9) {
                                  uuidStrArray.push("-");
                                }
                              }
                              var length = payloadSize - 16;
                              var userDataPayloadBytes = new Uint8Array(length);
                              for (i = 0; i < length; i++) {
                                userDataPayloadBytes[i] = expGolombDecoder.readUByte();
                              }
                              _this._insertSampleInOrder(_this._txtTrack.samples, {
                                pts: pes.pts,
                                payloadType,
                                uuid: uuidStrArray.join(""),
                                userDataBytes: userDataPayloadBytes,
                                userData: Object(id3["utf8ArrayToStr"])(userDataPayloadBytes.buffer)
                              });
                            }
                          } else if (payloadSize < expGolombDecoder.bytesAvailable) {
                            for (i = 0; i < payloadSize; i++) {
                              expGolombDecoder.readUByte();
                            }
                          }
                        }
                        break;
                      case 7:
                        push = true;
                        spsfound = true;
                        if (debug && avcSample) {
                          avcSample.debug += "SPS ";
                        }
                        if (!track.sps) {
                          expGolombDecoder = new exp_golomb(unit.data);
                          var config = expGolombDecoder.readSPS();
                          track.width = config.width;
                          track.height = config.height;
                          track.pixelRatio = config.pixelRatio;
                          track.sps = [unit.data];
                          track.duration = _this._duration;
                          var codecarray = unit.data.subarray(1, 4);
                          var codecstring = "avc1.";
                          for (i = 0; i < 3; i++) {
                            var h = codecarray[i].toString(16);
                            if (h.length < 2) {
                              h = "0" + h;
                            }
                            codecstring += h;
                          }
                          track.codec = codecstring;
                        }
                        break;
                      case 8:
                        push = true;
                        if (debug && avcSample) {
                          avcSample.debug += "PPS ";
                        }
                        if (!track.pps) {
                          track.pps = [unit.data];
                        }
                        break;
                      case 9:
                        push = false;
                        track.audFound = true;
                        if (avcSample) {
                          pushAccesUnit(avcSample, track);
                        }
                        avcSample = _this.avcSample = createAVCSample(false, pes.pts, pes.dts, debug ? "AUD " : "");
                        break;
                      case 12:
                        push = false;
                        break;
                      default:
                        push = false;
                        if (avcSample) {
                          avcSample.debug += "unknown NAL " + unit.type + " ";
                        }
                        break;
                    }
                    if (avcSample && push) {
                      var _units = avcSample.units;
                      _units.push(unit);
                    }
                  });
                  if (last && avcSample) {
                    pushAccesUnit(avcSample, track);
                    this.avcSample = null;
                  }
                };
                _proto._insertSampleInOrder = function _insertSampleInOrder(arr, data) {
                  var len = arr.length;
                  if (len > 0) {
                    if (data.pts >= arr[len - 1].pts) {
                      arr.push(data);
                    } else {
                      for (var pos = len - 1; pos >= 0; pos--) {
                        if (data.pts < arr[pos].pts) {
                          arr.splice(pos, 0, data);
                          break;
                        }
                      }
                    }
                  } else {
                    arr.push(data);
                  }
                };
                _proto._getLastNalUnit = function _getLastNalUnit() {
                  var avcSample = this.avcSample, lastUnit;
                  if (!avcSample || avcSample.units.length === 0) {
                    var track = this._avcTrack, samples = track.samples;
                    avcSample = samples[samples.length - 1];
                  }
                  if (avcSample) {
                    var units = avcSample.units;
                    lastUnit = units[units.length - 1];
                  }
                  return lastUnit;
                };
                _proto._parseAVCNALu = function _parseAVCNALu(array) {
                  var i = 0, len = array.byteLength, value, overflow, track = this._avcTrack, state = track.naluState || 0, lastState = state;
                  var units = [], unit, unitType, lastUnitStart = -1, lastUnitType;
                  if (state === -1) {
                    lastUnitStart = 0;
                    lastUnitType = array[0] & 31;
                    state = 0;
                    i = 1;
                  }
                  while (i < len) {
                    value = array[i++];
                    if (!state) {
                      state = value ? 0 : 1;
                      continue;
                    }
                    if (state === 1) {
                      state = value ? 0 : 2;
                      continue;
                    }
                    if (!value) {
                      state = 3;
                    } else if (value === 1) {
                      if (lastUnitStart >= 0) {
                        unit = {
                          data: array.subarray(lastUnitStart, i - state - 1),
                          type: lastUnitType
                        };
                        units.push(unit);
                      } else {
                        var lastUnit = this._getLastNalUnit();
                        if (lastUnit) {
                          if (lastState && i <= 4 - lastState) {
                            if (lastUnit.state) {
                              lastUnit.data = lastUnit.data.subarray(0, lastUnit.data.byteLength - lastState);
                            }
                          }
                          overflow = i - state - 1;
                          if (overflow > 0) {
                            var tmp = new Uint8Array(lastUnit.data.byteLength + overflow);
                            tmp.set(lastUnit.data, 0);
                            tmp.set(array.subarray(0, overflow), lastUnit.data.byteLength);
                            lastUnit.data = tmp;
                          }
                        }
                      }
                      if (i < len) {
                        unitType = array[i] & 31;
                        lastUnitStart = i;
                        lastUnitType = unitType;
                        state = 0;
                      } else {
                        state = -1;
                      }
                    } else {
                      state = 0;
                    }
                  }
                  if (lastUnitStart >= 0 && state >= 0) {
                    unit = {
                      data: array.subarray(lastUnitStart, len),
                      type: lastUnitType,
                      state
                    };
                    units.push(unit);
                  }
                  if (units.length === 0) {
                    var _lastUnit = this._getLastNalUnit();
                    if (_lastUnit) {
                      var _tmp = new Uint8Array(_lastUnit.data.byteLength + array.byteLength);
                      _tmp.set(_lastUnit.data, 0);
                      _tmp.set(array, _lastUnit.data.byteLength);
                      _lastUnit.data = _tmp;
                    }
                  }
                  track.naluState = state;
                  return units;
                };
                _proto.discardEPB = function discardEPB(data) {
                  var length = data.byteLength, EPBPositions = [], i = 1, newLength, newData;
                  while (i < length - 2) {
                    if (data[i] === 0 && data[i + 1] === 0 && data[i + 2] === 3) {
                      EPBPositions.push(i + 2);
                      i += 2;
                    } else {
                      i++;
                    }
                  }
                  if (EPBPositions.length === 0) {
                    return data;
                  }
                  newLength = length - EPBPositions.length;
                  newData = new Uint8Array(newLength);
                  var sourceIndex = 0;
                  for (i = 0; i < newLength; sourceIndex++, i++) {
                    if (sourceIndex === EPBPositions[0]) {
                      sourceIndex++;
                      EPBPositions.shift();
                    }
                    newData[i] = data[sourceIndex];
                  }
                  return newData;
                };
                _proto._parseAACPES = function _parseAACPES(pes) {
                  var track = this._audioTrack, data = pes.data, pts = pes.pts, startOffset = 0, aacOverFlow = this.aacOverFlow, aacLastPTS = this.aacLastPTS, frameDuration, frameIndex, offset, stamp, len;
                  if (aacOverFlow) {
                    var tmp = new Uint8Array(aacOverFlow.byteLength + data.byteLength);
                    tmp.set(aacOverFlow, 0);
                    tmp.set(data, aacOverFlow.byteLength);
                    data = tmp;
                  }
                  for (offset = startOffset, len = data.length; offset < len - 1; offset++) {
                    if (isHeader(data, offset)) {
                      break;
                    }
                  }
                  if (offset) {
                    var reason, fatal;
                    if (offset < len - 1) {
                      reason = "AAC PES did not start with ADTS header,offset:" + offset;
                      fatal = false;
                    } else {
                      reason = "no ADTS header found in AAC PES";
                      fatal = true;
                    }
                    logger["logger"].warn("parsing error:" + reason);
                    this.observer.trigger(events["default"].ERROR, {
                      type: errors["ErrorTypes"].MEDIA_ERROR,
                      details: errors["ErrorDetails"].FRAG_PARSING_ERROR,
                      fatal,
                      reason
                    });
                    if (fatal) {
                      return;
                    }
                  }
                  initTrackConfig(track, this.observer, data, offset, this.audioCodec);
                  frameIndex = 0;
                  frameDuration = getFrameDuration(track.samplerate);
                  if (aacOverFlow && aacLastPTS) {
                    var newPTS = aacLastPTS + frameDuration;
                    if (Math.abs(newPTS - pts) > 1) {
                      logger["logger"].log("AAC: align PTS for overlapping frames by " + Math.round((newPTS - pts) / 90));
                      pts = newPTS;
                    }
                  }
                  while (offset < len) {
                    if (isHeader(data, offset)) {
                      if (offset + 5 < len) {
                        var frame = appendFrame(track, data, offset, pts, frameIndex);
                        if (frame) {
                          offset += frame.length;
                          stamp = frame.sample.pts;
                          frameIndex++;
                          continue;
                        }
                      }
                      break;
                    } else {
                      offset++;
                    }
                  }
                  if (offset < len) {
                    aacOverFlow = data.subarray(offset, len);
                  } else {
                    aacOverFlow = null;
                  }
                  this.aacOverFlow = aacOverFlow;
                  this.aacLastPTS = stamp;
                };
                _proto._parseMPEGPES = function _parseMPEGPES(pes) {
                  var data = pes.data;
                  var length = data.length;
                  var frameIndex = 0;
                  var offset = 0;
                  var pts = pes.pts;
                  while (offset < length) {
                    if (mpegaudio.isHeader(data, offset)) {
                      var frame = mpegaudio.appendFrame(this._audioTrack, data, offset, pts, frameIndex);
                      if (frame) {
                        offset += frame.length;
                        frameIndex++;
                      } else {
                        break;
                      }
                    } else {
                      offset++;
                    }
                  }
                };
                _proto._parseID3PES = function _parseID3PES(pes) {
                  this._id3Track.samples.push(pes);
                };
                return TSDemuxer;
              }();
              var tsdemuxer = tsdemuxer_TSDemuxer;
              var mp3demuxer_MP3Demuxer = function() {
                function MP3Demuxer(observer, remuxer, config) {
                  this.observer = observer;
                  this.config = config;
                  this.remuxer = remuxer;
                }
                var _proto = MP3Demuxer.prototype;
                _proto.resetInitSegment = function resetInitSegment(initSegment, audioCodec, videoCodec, duration) {
                  this._audioTrack = {
                    container: "audio/mpeg",
                    type: "audio",
                    id: -1,
                    sequenceNumber: 0,
                    isAAC: false,
                    samples: [],
                    len: 0,
                    manifestCodec: audioCodec,
                    duration,
                    inputTimeScale: 9e4
                  };
                };
                _proto.resetTimeStamp = function resetTimeStamp() {
                };
                MP3Demuxer.probe = function probe(data) {
                  var offset, length;
                  var id3Data = id3["default"].getID3Data(data, 0);
                  if (id3Data && id3["default"].getTimeStamp(id3Data) !== void 0) {
                    for (offset = id3Data.length, length = Math.min(data.length - 1, offset + 100); offset < length; offset++) {
                      if (mpegaudio.probe(data, offset)) {
                        logger["logger"].log("MPEG Audio sync word found !");
                        return true;
                      }
                    }
                  }
                  return false;
                };
                _proto.append = function append(data, timeOffset, contiguous, accurateTimeOffset) {
                  var id3Data = id3["default"].getID3Data(data, 0) || [];
                  var timestamp = id3["default"].getTimeStamp(id3Data);
                  var pts = timestamp !== void 0 ? 90 * timestamp : timeOffset * 9e4;
                  var offset = id3Data.length;
                  var length = data.length;
                  var frameIndex = 0, stamp = 0;
                  var track = this._audioTrack;
                  var id3Samples = [{
                    pts,
                    dts: pts,
                    data: id3Data
                  }];
                  while (offset < length) {
                    if (mpegaudio.isHeader(data, offset)) {
                      var frame = mpegaudio.appendFrame(track, data, offset, pts, frameIndex);
                      if (frame) {
                        offset += frame.length;
                        stamp = frame.sample.pts;
                        frameIndex++;
                      } else {
                        break;
                      }
                    } else if (id3["default"].isHeader(data, offset)) {
                      id3Data = id3["default"].getID3Data(data, offset);
                      id3Samples.push({
                        pts: stamp,
                        dts: stamp,
                        data: id3Data
                      });
                      offset += id3Data.length;
                    } else {
                      offset++;
                    }
                  }
                  this.remuxer.remux(track, {
                    samples: []
                  }, {
                    samples: id3Samples,
                    inputTimeScale: 9e4
                  }, {
                    samples: []
                  }, timeOffset, contiguous, accurateTimeOffset);
                };
                _proto.destroy = function destroy() {
                };
                return MP3Demuxer;
              }();
              var mp3demuxer = mp3demuxer_MP3Demuxer;
              var AAC = function() {
                function AAC2() {
                }
                AAC2.getSilentFrame = function getSilentFrame(codec, channelCount) {
                  switch (codec) {
                    case "mp4a.40.2":
                      if (channelCount === 1) {
                        return new Uint8Array([0, 200, 0, 128, 35, 128]);
                      } else if (channelCount === 2) {
                        return new Uint8Array([33, 0, 73, 144, 2, 25, 0, 35, 128]);
                      } else if (channelCount === 3) {
                        return new Uint8Array([0, 200, 0, 128, 32, 132, 1, 38, 64, 8, 100, 0, 142]);
                      } else if (channelCount === 4) {
                        return new Uint8Array([0, 200, 0, 128, 32, 132, 1, 38, 64, 8, 100, 0, 128, 44, 128, 8, 2, 56]);
                      } else if (channelCount === 5) {
                        return new Uint8Array([0, 200, 0, 128, 32, 132, 1, 38, 64, 8, 100, 0, 130, 48, 4, 153, 0, 33, 144, 2, 56]);
                      } else if (channelCount === 6) {
                        return new Uint8Array([0, 200, 0, 128, 32, 132, 1, 38, 64, 8, 100, 0, 130, 48, 4, 153, 0, 33, 144, 2, 0, 178, 0, 32, 8, 224]);
                      }
                      break;
                    default:
                      if (channelCount === 1) {
                        return new Uint8Array([1, 64, 34, 128, 163, 78, 230, 128, 186, 8, 0, 0, 0, 28, 6, 241, 193, 10, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 94]);
                      } else if (channelCount === 2) {
                        return new Uint8Array([1, 64, 34, 128, 163, 94, 230, 128, 186, 8, 0, 0, 0, 0, 149, 0, 6, 241, 161, 10, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 94]);
                      } else if (channelCount === 3) {
                        return new Uint8Array([1, 64, 34, 128, 163, 94, 230, 128, 186, 8, 0, 0, 0, 0, 149, 0, 6, 241, 161, 10, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 94]);
                      }
                      break;
                  }
                  return null;
                };
                return AAC2;
              }();
              var aac_helper = AAC;
              var UINT32_MAX = Math.pow(2, 32) - 1;
              var MP4 = function() {
                function MP42() {
                }
                MP42.init = function init() {
                  MP42.types = {
                    avc1: [],
                    // codingname
                    avcC: [],
                    btrt: [],
                    dinf: [],
                    dref: [],
                    esds: [],
                    ftyp: [],
                    hdlr: [],
                    mdat: [],
                    mdhd: [],
                    mdia: [],
                    mfhd: [],
                    minf: [],
                    moof: [],
                    moov: [],
                    mp4a: [],
                    ".mp3": [],
                    mvex: [],
                    mvhd: [],
                    pasp: [],
                    sdtp: [],
                    stbl: [],
                    stco: [],
                    stsc: [],
                    stsd: [],
                    stsz: [],
                    stts: [],
                    tfdt: [],
                    tfhd: [],
                    traf: [],
                    trak: [],
                    trun: [],
                    trex: [],
                    tkhd: [],
                    vmhd: [],
                    smhd: []
                  };
                  var i;
                  for (i in MP42.types) {
                    if (MP42.types.hasOwnProperty(i)) {
                      MP42.types[i] = [i.charCodeAt(0), i.charCodeAt(1), i.charCodeAt(2), i.charCodeAt(3)];
                    }
                  }
                  var videoHdlr = new Uint8Array([
                    0,
                    // version 0
                    0,
                    0,
                    0,
                    // flags
                    0,
                    0,
                    0,
                    0,
                    // pre_defined
                    118,
                    105,
                    100,
                    101,
                    // handler_type: 'vide'
                    0,
                    0,
                    0,
                    0,
                    // reserved
                    0,
                    0,
                    0,
                    0,
                    // reserved
                    0,
                    0,
                    0,
                    0,
                    // reserved
                    86,
                    105,
                    100,
                    101,
                    111,
                    72,
                    97,
                    110,
                    100,
                    108,
                    101,
                    114,
                    0
                    // name: 'VideoHandler'
                  ]);
                  var audioHdlr = new Uint8Array([
                    0,
                    // version 0
                    0,
                    0,
                    0,
                    // flags
                    0,
                    0,
                    0,
                    0,
                    // pre_defined
                    115,
                    111,
                    117,
                    110,
                    // handler_type: 'soun'
                    0,
                    0,
                    0,
                    0,
                    // reserved
                    0,
                    0,
                    0,
                    0,
                    // reserved
                    0,
                    0,
                    0,
                    0,
                    // reserved
                    83,
                    111,
                    117,
                    110,
                    100,
                    72,
                    97,
                    110,
                    100,
                    108,
                    101,
                    114,
                    0
                    // name: 'SoundHandler'
                  ]);
                  MP42.HDLR_TYPES = {
                    "video": videoHdlr,
                    "audio": audioHdlr
                  };
                  var dref = new Uint8Array([
                    0,
                    // version 0
                    0,
                    0,
                    0,
                    // flags
                    0,
                    0,
                    0,
                    1,
                    // entry_count
                    0,
                    0,
                    0,
                    12,
                    // entry_size
                    117,
                    114,
                    108,
                    32,
                    // 'url' type
                    0,
                    // version 0
                    0,
                    0,
                    1
                    // entry_flags
                  ]);
                  var stco = new Uint8Array([
                    0,
                    // version
                    0,
                    0,
                    0,
                    // flags
                    0,
                    0,
                    0,
                    0
                    // entry_count
                  ]);
                  MP42.STTS = MP42.STSC = MP42.STCO = stco;
                  MP42.STSZ = new Uint8Array([
                    0,
                    // version
                    0,
                    0,
                    0,
                    // flags
                    0,
                    0,
                    0,
                    0,
                    // sample_size
                    0,
                    0,
                    0,
                    0
                    // sample_count
                  ]);
                  MP42.VMHD = new Uint8Array([
                    0,
                    // version
                    0,
                    0,
                    1,
                    // flags
                    0,
                    0,
                    // graphicsmode
                    0,
                    0,
                    0,
                    0,
                    0,
                    0
                    // opcolor
                  ]);
                  MP42.SMHD = new Uint8Array([
                    0,
                    // version
                    0,
                    0,
                    0,
                    // flags
                    0,
                    0,
                    // balance
                    0,
                    0
                    // reserved
                  ]);
                  MP42.STSD = new Uint8Array([
                    0,
                    // version 0
                    0,
                    0,
                    0,
                    // flags
                    0,
                    0,
                    0,
                    1
                  ]);
                  var majorBrand = new Uint8Array([105, 115, 111, 109]);
                  var avc1Brand = new Uint8Array([97, 118, 99, 49]);
                  var minorVersion = new Uint8Array([0, 0, 0, 1]);
                  MP42.FTYP = MP42.box(MP42.types.ftyp, majorBrand, minorVersion, majorBrand, avc1Brand);
                  MP42.DINF = MP42.box(MP42.types.dinf, MP42.box(MP42.types.dref, dref));
                };
                MP42.box = function box(type) {
                  var payload = Array.prototype.slice.call(arguments, 1), size = 8, i = payload.length, len = i, result;
                  while (i--) {
                    size += payload[i].byteLength;
                  }
                  result = new Uint8Array(size);
                  result[0] = size >> 24 & 255;
                  result[1] = size >> 16 & 255;
                  result[2] = size >> 8 & 255;
                  result[3] = size & 255;
                  result.set(type, 4);
                  for (i = 0, size = 8; i < len; i++) {
                    result.set(payload[i], size);
                    size += payload[i].byteLength;
                  }
                  return result;
                };
                MP42.hdlr = function hdlr(type) {
                  return MP42.box(MP42.types.hdlr, MP42.HDLR_TYPES[type]);
                };
                MP42.mdat = function mdat(data) {
                  return MP42.box(MP42.types.mdat, data);
                };
                MP42.mdhd = function mdhd(timescale, duration) {
                  duration *= timescale;
                  var upperWordDuration = Math.floor(duration / (UINT32_MAX + 1));
                  var lowerWordDuration = Math.floor(duration % (UINT32_MAX + 1));
                  return MP42.box(MP42.types.mdhd, new Uint8Array([
                    1,
                    // version 1
                    0,
                    0,
                    0,
                    // flags
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    2,
                    // creation_time
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    3,
                    // modification_time
                    timescale >> 24 & 255,
                    timescale >> 16 & 255,
                    timescale >> 8 & 255,
                    timescale & 255,
                    // timescale
                    upperWordDuration >> 24,
                    upperWordDuration >> 16 & 255,
                    upperWordDuration >> 8 & 255,
                    upperWordDuration & 255,
                    lowerWordDuration >> 24,
                    lowerWordDuration >> 16 & 255,
                    lowerWordDuration >> 8 & 255,
                    lowerWordDuration & 255,
                    85,
                    196,
                    // 'und' language (undetermined)
                    0,
                    0
                  ]));
                };
                MP42.mdia = function mdia(track) {
                  return MP42.box(MP42.types.mdia, MP42.mdhd(track.timescale, track.duration), MP42.hdlr(track.type), MP42.minf(track));
                };
                MP42.mfhd = function mfhd(sequenceNumber) {
                  return MP42.box(MP42.types.mfhd, new Uint8Array([
                    0,
                    0,
                    0,
                    0,
                    // flags
                    sequenceNumber >> 24,
                    sequenceNumber >> 16 & 255,
                    sequenceNumber >> 8 & 255,
                    sequenceNumber & 255
                    // sequence_number
                  ]));
                };
                MP42.minf = function minf(track) {
                  if (track.type === "audio") {
                    return MP42.box(MP42.types.minf, MP42.box(MP42.types.smhd, MP42.SMHD), MP42.DINF, MP42.stbl(track));
                  } else {
                    return MP42.box(MP42.types.minf, MP42.box(MP42.types.vmhd, MP42.VMHD), MP42.DINF, MP42.stbl(track));
                  }
                };
                MP42.moof = function moof(sn, baseMediaDecodeTime, track) {
                  return MP42.box(MP42.types.moof, MP42.mfhd(sn), MP42.traf(track, baseMediaDecodeTime));
                };
                MP42.moov = function moov(tracks) {
                  var i = tracks.length, boxes = [];
                  while (i--) {
                    boxes[i] = MP42.trak(tracks[i]);
                  }
                  return MP42.box.apply(null, [MP42.types.moov, MP42.mvhd(tracks[0].timescale, tracks[0].duration)].concat(boxes).concat(MP42.mvex(tracks)));
                };
                MP42.mvex = function mvex(tracks) {
                  var i = tracks.length, boxes = [];
                  while (i--) {
                    boxes[i] = MP42.trex(tracks[i]);
                  }
                  return MP42.box.apply(null, [MP42.types.mvex].concat(boxes));
                };
                MP42.mvhd = function mvhd(timescale, duration) {
                  duration *= timescale;
                  var upperWordDuration = Math.floor(duration / (UINT32_MAX + 1));
                  var lowerWordDuration = Math.floor(duration % (UINT32_MAX + 1));
                  var bytes = new Uint8Array([
                    1,
                    // version 1
                    0,
                    0,
                    0,
                    // flags
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    2,
                    // creation_time
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    3,
                    // modification_time
                    timescale >> 24 & 255,
                    timescale >> 16 & 255,
                    timescale >> 8 & 255,
                    timescale & 255,
                    // timescale
                    upperWordDuration >> 24,
                    upperWordDuration >> 16 & 255,
                    upperWordDuration >> 8 & 255,
                    upperWordDuration & 255,
                    lowerWordDuration >> 24,
                    lowerWordDuration >> 16 & 255,
                    lowerWordDuration >> 8 & 255,
                    lowerWordDuration & 255,
                    0,
                    1,
                    0,
                    0,
                    // 1.0 rate
                    1,
                    0,
                    // 1.0 volume
                    0,
                    0,
                    // reserved
                    0,
                    0,
                    0,
                    0,
                    // reserved
                    0,
                    0,
                    0,
                    0,
                    // reserved
                    0,
                    1,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    1,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    64,
                    0,
                    0,
                    0,
                    // transformation: unity matrix
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    // pre_defined
                    255,
                    255,
                    255,
                    255
                    // next_track_ID
                  ]);
                  return MP42.box(MP42.types.mvhd, bytes);
                };
                MP42.sdtp = function sdtp(track) {
                  var samples = track.samples || [], bytes = new Uint8Array(4 + samples.length), flags, i;
                  for (i = 0; i < samples.length; i++) {
                    flags = samples[i].flags;
                    bytes[i + 4] = flags.dependsOn << 4 | flags.isDependedOn << 2 | flags.hasRedundancy;
                  }
                  return MP42.box(MP42.types.sdtp, bytes);
                };
                MP42.stbl = function stbl(track) {
                  return MP42.box(MP42.types.stbl, MP42.stsd(track), MP42.box(MP42.types.stts, MP42.STTS), MP42.box(MP42.types.stsc, MP42.STSC), MP42.box(MP42.types.stsz, MP42.STSZ), MP42.box(MP42.types.stco, MP42.STCO));
                };
                MP42.avc1 = function avc1(track) {
                  var sps = [], pps = [], i, data, len;
                  for (i = 0; i < track.sps.length; i++) {
                    data = track.sps[i];
                    len = data.byteLength;
                    sps.push(len >>> 8 & 255);
                    sps.push(len & 255);
                    sps = sps.concat(Array.prototype.slice.call(data));
                  }
                  for (i = 0; i < track.pps.length; i++) {
                    data = track.pps[i];
                    len = data.byteLength;
                    pps.push(len >>> 8 & 255);
                    pps.push(len & 255);
                    pps = pps.concat(Array.prototype.slice.call(data));
                  }
                  var avcc = MP42.box(MP42.types.avcC, new Uint8Array([
                    1,
                    // version
                    sps[3],
                    // profile
                    sps[4],
                    // profile compat
                    sps[5],
                    // level
                    252 | 3,
                    // lengthSizeMinusOne, hard-coded to 4 bytes
                    224 | track.sps.length
                    // 3bit reserved (111) + numOfSequenceParameterSets
                  ].concat(sps).concat([
                    track.pps.length
                    // numOfPictureParameterSets
                  ]).concat(pps))), width = track.width, height = track.height, hSpacing = track.pixelRatio[0], vSpacing = track.pixelRatio[1];
                  return MP42.box(
                    MP42.types.avc1,
                    new Uint8Array([
                      0,
                      0,
                      0,
                      // reserved
                      0,
                      0,
                      0,
                      // reserved
                      0,
                      1,
                      // data_reference_index
                      0,
                      0,
                      // pre_defined
                      0,
                      0,
                      // reserved
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      // pre_defined
                      width >> 8 & 255,
                      width & 255,
                      // width
                      height >> 8 & 255,
                      height & 255,
                      // height
                      0,
                      72,
                      0,
                      0,
                      // horizresolution
                      0,
                      72,
                      0,
                      0,
                      // vertresolution
                      0,
                      0,
                      0,
                      0,
                      // reserved
                      0,
                      1,
                      // frame_count
                      18,
                      100,
                      97,
                      105,
                      108,
                      // dailymotion/hls.js
                      121,
                      109,
                      111,
                      116,
                      105,
                      111,
                      110,
                      47,
                      104,
                      108,
                      115,
                      46,
                      106,
                      115,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      // compressorname
                      0,
                      24,
                      // depth = 24
                      17,
                      17
                    ]),
                    // pre_defined = -1
                    avcc,
                    MP42.box(MP42.types.btrt, new Uint8Array([
                      0,
                      28,
                      156,
                      128,
                      // bufferSizeDB
                      0,
                      45,
                      198,
                      192,
                      // maxBitrate
                      0,
                      45,
                      198,
                      192
                    ])),
                    // avgBitrate
                    MP42.box(MP42.types.pasp, new Uint8Array([
                      hSpacing >> 24,
                      // hSpacing
                      hSpacing >> 16 & 255,
                      hSpacing >> 8 & 255,
                      hSpacing & 255,
                      vSpacing >> 24,
                      // vSpacing
                      vSpacing >> 16 & 255,
                      vSpacing >> 8 & 255,
                      vSpacing & 255
                    ]))
                  );
                };
                MP42.esds = function esds(track) {
                  var configlen = track.config.length;
                  return new Uint8Array([
                    0,
                    // version 0
                    0,
                    0,
                    0,
                    // flags
                    3,
                    // descriptor_type
                    23 + configlen,
                    // length
                    0,
                    1,
                    // es_id
                    0,
                    // stream_priority
                    4,
                    // descriptor_type
                    15 + configlen,
                    // length
                    64,
                    // codec : mpeg4_audio
                    21,
                    // stream_type
                    0,
                    0,
                    0,
                    // buffer_size
                    0,
                    0,
                    0,
                    0,
                    // maxBitrate
                    0,
                    0,
                    0,
                    0,
                    // avgBitrate
                    5
                    // descriptor_type
                  ].concat([configlen]).concat(track.config).concat([6, 1, 2]));
                };
                MP42.mp4a = function mp4a(track) {
                  var samplerate = track.samplerate;
                  return MP42.box(MP42.types.mp4a, new Uint8Array([
                    0,
                    0,
                    0,
                    // reserved
                    0,
                    0,
                    0,
                    // reserved
                    0,
                    1,
                    // data_reference_index
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    // reserved
                    0,
                    track.channelCount,
                    // channelcount
                    0,
                    16,
                    // sampleSize:16bits
                    0,
                    0,
                    0,
                    0,
                    // reserved2
                    samplerate >> 8 & 255,
                    samplerate & 255,
                    //
                    0,
                    0
                  ]), MP42.box(MP42.types.esds, MP42.esds(track)));
                };
                MP42.mp3 = function mp3(track) {
                  var samplerate = track.samplerate;
                  return MP42.box(MP42.types[".mp3"], new Uint8Array([
                    0,
                    0,
                    0,
                    // reserved
                    0,
                    0,
                    0,
                    // reserved
                    0,
                    1,
                    // data_reference_index
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    // reserved
                    0,
                    track.channelCount,
                    // channelcount
                    0,
                    16,
                    // sampleSize:16bits
                    0,
                    0,
                    0,
                    0,
                    // reserved2
                    samplerate >> 8 & 255,
                    samplerate & 255,
                    //
                    0,
                    0
                  ]));
                };
                MP42.stsd = function stsd(track) {
                  if (track.type === "audio") {
                    if (!track.isAAC && track.codec === "mp3") {
                      return MP42.box(MP42.types.stsd, MP42.STSD, MP42.mp3(track));
                    }
                    return MP42.box(MP42.types.stsd, MP42.STSD, MP42.mp4a(track));
                  } else {
                    return MP42.box(MP42.types.stsd, MP42.STSD, MP42.avc1(track));
                  }
                };
                MP42.tkhd = function tkhd(track) {
                  var id = track.id, duration = track.duration * track.timescale, width = track.width, height = track.height, upperWordDuration = Math.floor(duration / (UINT32_MAX + 1)), lowerWordDuration = Math.floor(duration % (UINT32_MAX + 1));
                  return MP42.box(MP42.types.tkhd, new Uint8Array([
                    1,
                    // version 1
                    0,
                    0,
                    7,
                    // flags
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    2,
                    // creation_time
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    3,
                    // modification_time
                    id >> 24 & 255,
                    id >> 16 & 255,
                    id >> 8 & 255,
                    id & 255,
                    // track_ID
                    0,
                    0,
                    0,
                    0,
                    // reserved
                    upperWordDuration >> 24,
                    upperWordDuration >> 16 & 255,
                    upperWordDuration >> 8 & 255,
                    upperWordDuration & 255,
                    lowerWordDuration >> 24,
                    lowerWordDuration >> 16 & 255,
                    lowerWordDuration >> 8 & 255,
                    lowerWordDuration & 255,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    // reserved
                    0,
                    0,
                    // layer
                    0,
                    0,
                    // alternate_group
                    0,
                    0,
                    // non-audio track volume
                    0,
                    0,
                    // reserved
                    0,
                    1,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    1,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    64,
                    0,
                    0,
                    0,
                    // transformation: unity matrix
                    width >> 8 & 255,
                    width & 255,
                    0,
                    0,
                    // width
                    height >> 8 & 255,
                    height & 255,
                    0,
                    0
                    // height
                  ]));
                };
                MP42.traf = function traf(track, baseMediaDecodeTime) {
                  var sampleDependencyTable = MP42.sdtp(track), id = track.id, upperWordBaseMediaDecodeTime = Math.floor(baseMediaDecodeTime / (UINT32_MAX + 1)), lowerWordBaseMediaDecodeTime = Math.floor(baseMediaDecodeTime % (UINT32_MAX + 1));
                  return MP42.box(
                    MP42.types.traf,
                    MP42.box(MP42.types.tfhd, new Uint8Array([
                      0,
                      // version 0
                      0,
                      0,
                      0,
                      // flags
                      id >> 24,
                      id >> 16 & 255,
                      id >> 8 & 255,
                      id & 255
                      // track_ID
                    ])),
                    MP42.box(MP42.types.tfdt, new Uint8Array([
                      1,
                      // version 1
                      0,
                      0,
                      0,
                      // flags
                      upperWordBaseMediaDecodeTime >> 24,
                      upperWordBaseMediaDecodeTime >> 16 & 255,
                      upperWordBaseMediaDecodeTime >> 8 & 255,
                      upperWordBaseMediaDecodeTime & 255,
                      lowerWordBaseMediaDecodeTime >> 24,
                      lowerWordBaseMediaDecodeTime >> 16 & 255,
                      lowerWordBaseMediaDecodeTime >> 8 & 255,
                      lowerWordBaseMediaDecodeTime & 255
                    ])),
                    MP42.trun(track, sampleDependencyTable.length + 16 + // tfhd
                    20 + // tfdt
                    8 + // traf header
                    16 + // mfhd
                    8 + // moof header
                    8),
                    // mdat header
                    sampleDependencyTable
                  );
                };
                MP42.trak = function trak(track) {
                  track.duration = track.duration || 4294967295;
                  return MP42.box(MP42.types.trak, MP42.tkhd(track), MP42.mdia(track));
                };
                MP42.trex = function trex(track) {
                  var id = track.id;
                  return MP42.box(MP42.types.trex, new Uint8Array([
                    0,
                    // version 0
                    0,
                    0,
                    0,
                    // flags
                    id >> 24,
                    id >> 16 & 255,
                    id >> 8 & 255,
                    id & 255,
                    // track_ID
                    0,
                    0,
                    0,
                    1,
                    // default_sample_description_index
                    0,
                    0,
                    0,
                    0,
                    // default_sample_duration
                    0,
                    0,
                    0,
                    0,
                    // default_sample_size
                    0,
                    1,
                    0,
                    1
                    // default_sample_flags
                  ]));
                };
                MP42.trun = function trun(track, offset) {
                  var samples = track.samples || [], len = samples.length, arraylen = 12 + 16 * len, array = new Uint8Array(arraylen), i, sample, duration, size, flags, cts;
                  offset += 8 + arraylen;
                  array.set([
                    0,
                    // version 0
                    0,
                    15,
                    1,
                    // flags
                    len >>> 24 & 255,
                    len >>> 16 & 255,
                    len >>> 8 & 255,
                    len & 255,
                    // sample_count
                    offset >>> 24 & 255,
                    offset >>> 16 & 255,
                    offset >>> 8 & 255,
                    offset & 255
                    // data_offset
                  ], 0);
                  for (i = 0; i < len; i++) {
                    sample = samples[i];
                    duration = sample.duration;
                    size = sample.size;
                    flags = sample.flags;
                    cts = sample.cts;
                    array.set([
                      duration >>> 24 & 255,
                      duration >>> 16 & 255,
                      duration >>> 8 & 255,
                      duration & 255,
                      // sample_duration
                      size >>> 24 & 255,
                      size >>> 16 & 255,
                      size >>> 8 & 255,
                      size & 255,
                      // sample_size
                      flags.isLeading << 2 | flags.dependsOn,
                      flags.isDependedOn << 6 | flags.hasRedundancy << 4 | flags.paddingValue << 1 | flags.isNonSync,
                      flags.degradPrio & 240 << 8,
                      flags.degradPrio & 15,
                      // sample_flags
                      cts >>> 24 & 255,
                      cts >>> 16 & 255,
                      cts >>> 8 & 255,
                      cts & 255
                      // sample_composition_time_offset
                    ], 12 + 16 * i);
                  }
                  return MP42.box(MP42.types.trun, array);
                };
                MP42.initSegment = function initSegment(tracks) {
                  if (!MP42.types) {
                    MP42.init();
                  }
                  var movie = MP42.moov(tracks), result;
                  result = new Uint8Array(MP42.FTYP.byteLength + movie.byteLength);
                  result.set(MP42.FTYP);
                  result.set(movie, MP42.FTYP.byteLength);
                  return result;
                };
                return MP42;
              }();
              var mp4_generator = MP4;
              var MPEG_TS_CLOCK_FREQ_HZ = 9e4;
              function toTimescaleFromScale(value, destScale, srcScale, round) {
                if (srcScale === void 0) {
                  srcScale = 1;
                }
                if (round === void 0) {
                  round = false;
                }
                return toTimescaleFromBase(value, destScale, 1 / srcScale);
              }
              function toTimescaleFromBase(value, destScale, srcBase, round) {
                if (srcBase === void 0) {
                  srcBase = 1;
                }
                if (round === void 0) {
                  round = false;
                }
                var result = value * destScale * srcBase;
                return round ? Math.round(result) : result;
              }
              function toMsFromMpegTsClock(value, round) {
                if (round === void 0) {
                  round = false;
                }
                return toTimescaleFromBase(value, 1e3, 1 / MPEG_TS_CLOCK_FREQ_HZ, round);
              }
              function toMpegTsClockFromTimescale(value, srcScale) {
                if (srcScale === void 0) {
                  srcScale = 1;
                }
                return toTimescaleFromBase(value, MPEG_TS_CLOCK_FREQ_HZ, 1 / srcScale);
              }
              var MAX_SILENT_FRAME_DURATION_90KHZ = toMpegTsClockFromTimescale(10);
              var PTS_DTS_SHIFT_TOLERANCE_90KHZ = toMpegTsClockFromTimescale(0.2);
              var chromeVersion = null;
              var mp4_remuxer_MP4Remuxer = function() {
                function MP4Remuxer(observer, config, typeSupported, vendor) {
                  this.observer = observer;
                  this.config = config;
                  this.typeSupported = typeSupported;
                  this.ISGenerated = false;
                  if (chromeVersion === null) {
                    var result = navigator.userAgent.match(/Chrome\/(\d+)/i);
                    chromeVersion = result ? parseInt(result[1]) : 0;
                  }
                }
                var _proto = MP4Remuxer.prototype;
                _proto.destroy = function destroy() {
                };
                _proto.resetTimeStamp = function resetTimeStamp(defaultTimeStamp) {
                  this._initPTS = this._initDTS = defaultTimeStamp;
                };
                _proto.resetInitSegment = function resetInitSegment() {
                  this.ISGenerated = false;
                };
                _proto.getVideoStartPts = function getVideoStartPts(videoSamples) {
                  var rolloverDetected = false;
                  var startPTS = videoSamples.reduce(function(minPTS, sample) {
                    var delta = sample.pts - minPTS;
                    if (delta < -4294967296) {
                      rolloverDetected = true;
                      return PTSNormalize(minPTS, sample.pts);
                    } else if (delta > 0) {
                      return minPTS;
                    } else {
                      return sample.pts;
                    }
                  }, videoSamples[0].pts);
                  if (rolloverDetected) {
                    logger["logger"].debug("PTS rollover detected");
                  }
                  return startPTS;
                };
                _proto.remux = function remux(audioTrack, videoTrack, id3Track, textTrack, timeOffset, contiguous, accurateTimeOffset) {
                  if (!this.ISGenerated) {
                    this.generateIS(audioTrack, videoTrack, timeOffset);
                  }
                  if (this.ISGenerated) {
                    var nbAudioSamples = audioTrack.samples.length;
                    var nbVideoSamples = videoTrack.samples.length;
                    var audioTimeOffset = timeOffset;
                    var videoTimeOffset = timeOffset;
                    if (nbAudioSamples && nbVideoSamples) {
                      var startPTS = this.getVideoStartPts(videoTrack.samples);
                      var tsDelta = PTSNormalize(audioTrack.samples[0].pts, startPTS) - startPTS;
                      var audiovideoTimestampDelta = tsDelta / videoTrack.inputTimeScale;
                      audioTimeOffset += Math.max(0, audiovideoTimestampDelta);
                      videoTimeOffset += Math.max(0, -audiovideoTimestampDelta);
                    }
                    if (nbAudioSamples) {
                      if (!audioTrack.timescale) {
                        logger["logger"].warn("regenerate InitSegment as audio detected");
                        this.generateIS(audioTrack, videoTrack, timeOffset);
                      }
                      var audioData = this.remuxAudio(audioTrack, audioTimeOffset, contiguous, accurateTimeOffset);
                      if (nbVideoSamples) {
                        var audioTrackLength;
                        if (audioData) {
                          audioTrackLength = audioData.endPTS - audioData.startPTS;
                        }
                        if (!videoTrack.timescale) {
                          logger["logger"].warn("regenerate InitSegment as video detected");
                          this.generateIS(audioTrack, videoTrack, timeOffset);
                        }
                        this.remuxVideo(videoTrack, videoTimeOffset, contiguous, audioTrackLength);
                      }
                    } else {
                      if (nbVideoSamples) {
                        var videoData = this.remuxVideo(videoTrack, videoTimeOffset, contiguous, 0, accurateTimeOffset);
                        if (videoData && audioTrack.codec) {
                          this.remuxEmptyAudio(audioTrack, audioTimeOffset, contiguous, videoData);
                        }
                      }
                    }
                  }
                  if (id3Track.samples.length) {
                    this.remuxID3(id3Track, timeOffset);
                  }
                  if (textTrack.samples.length) {
                    this.remuxText(textTrack, timeOffset);
                  }
                  this.observer.trigger(events["default"].FRAG_PARSED);
                };
                _proto.generateIS = function generateIS(audioTrack, videoTrack, timeOffset) {
                  var observer = this.observer, audioSamples = audioTrack.samples, videoSamples = videoTrack.samples, typeSupported = this.typeSupported, container = "audio/mp4", tracks = {}, data = {
                    tracks
                  }, computePTSDTS = this._initPTS === void 0, initPTS, initDTS;
                  if (computePTSDTS) {
                    initPTS = initDTS = Infinity;
                  }
                  if (audioTrack.config && audioSamples.length) {
                    audioTrack.timescale = audioTrack.samplerate;
                    logger["logger"].log("audio sampling rate : " + audioTrack.samplerate);
                    if (!audioTrack.isAAC) {
                      if (typeSupported.mpeg) {
                        container = "audio/mpeg";
                        audioTrack.codec = "";
                      } else if (typeSupported.mp3) {
                        audioTrack.codec = "mp3";
                      }
                    }
                    tracks.audio = {
                      container,
                      codec: audioTrack.codec,
                      initSegment: !audioTrack.isAAC && typeSupported.mpeg ? new Uint8Array() : mp4_generator.initSegment([audioTrack]),
                      metadata: {
                        channelCount: audioTrack.channelCount
                      }
                    };
                    if (computePTSDTS) {
                      initPTS = initDTS = audioSamples[0].pts - Math.round(audioTrack.inputTimeScale * timeOffset);
                    }
                  }
                  if (videoTrack.sps && videoTrack.pps && videoSamples.length) {
                    var inputTimeScale = videoTrack.inputTimeScale;
                    videoTrack.timescale = inputTimeScale;
                    tracks.video = {
                      container: "video/mp4",
                      codec: videoTrack.codec,
                      initSegment: mp4_generator.initSegment([videoTrack]),
                      metadata: {
                        width: videoTrack.width,
                        height: videoTrack.height
                      }
                    };
                    if (computePTSDTS) {
                      var startPTS = this.getVideoStartPts(videoSamples);
                      var startOffset = Math.round(inputTimeScale * timeOffset);
                      initDTS = Math.min(initDTS, PTSNormalize(videoSamples[0].dts, startPTS) - startOffset);
                      initPTS = Math.min(initPTS, startPTS - startOffset);
                      this.observer.trigger(events["default"].INIT_PTS_FOUND, {
                        initPTS
                      });
                    }
                  } else if (computePTSDTS && tracks.audio) {
                    this.observer.trigger(events["default"].INIT_PTS_FOUND, {
                      initPTS
                    });
                  }
                  if (Object.keys(tracks).length) {
                    observer.trigger(events["default"].FRAG_PARSING_INIT_SEGMENT, data);
                    this.ISGenerated = true;
                    if (computePTSDTS) {
                      this._initPTS = initPTS;
                      this._initDTS = initDTS;
                    }
                  } else {
                    observer.trigger(events["default"].ERROR, {
                      type: errors["ErrorTypes"].MEDIA_ERROR,
                      details: errors["ErrorDetails"].FRAG_PARSING_ERROR,
                      fatal: false,
                      reason: "no audio/video samples found"
                    });
                  }
                };
                _proto.remuxVideo = function remuxVideo(track, timeOffset, contiguous, audioTrackLength) {
                  var timeScale = track.timescale;
                  var inputSamples = track.samples;
                  var outputSamples = [];
                  var nbSamples = inputSamples.length;
                  var initPTS = this._initPTS;
                  var offset = 8;
                  var mp4SampleDuration;
                  var mdat;
                  var moof;
                  var firstDTS;
                  var lastDTS;
                  var minPTS = Number.POSITIVE_INFINITY;
                  var maxPTS = Number.NEGATIVE_INFINITY;
                  var ptsDtsShift = 0;
                  var sortSamples = false;
                  var nextAvcDts = this.nextAvcDts;
                  if (nbSamples === 0) {
                    return;
                  }
                  if (!contiguous) {
                    var pts = timeOffset * timeScale;
                    var cts = inputSamples[0].pts - PTSNormalize(inputSamples[0].dts, inputSamples[0].pts);
                    nextAvcDts = pts - cts;
                  }
                  for (var i = 0; i < nbSamples; i++) {
                    var sample = inputSamples[i];
                    sample.pts = PTSNormalize(sample.pts - initPTS, nextAvcDts);
                    sample.dts = PTSNormalize(sample.dts - initPTS, nextAvcDts);
                    if (sample.dts > sample.pts) {
                      ptsDtsShift = Math.max(Math.min(ptsDtsShift, sample.pts - sample.dts), -1 * PTS_DTS_SHIFT_TOLERANCE_90KHZ);
                    }
                    if (sample.dts < inputSamples[i > 0 ? i - 1 : i].dts) {
                      sortSamples = true;
                    }
                  }
                  if (sortSamples) {
                    inputSamples.sort(function(a, b) {
                      var deltadts = a.dts - b.dts;
                      var deltapts = a.pts - b.pts;
                      return deltadts || deltapts || a.id - b.id;
                    });
                  }
                  firstDTS = inputSamples[0].dts;
                  lastDTS = inputSamples[nbSamples - 1].dts;
                  var averageSampleDuration = Math.round((lastDTS - firstDTS) / (nbSamples - 1));
                  if (ptsDtsShift < 0) {
                    if (ptsDtsShift < averageSampleDuration * -2) {
                      logger["logger"].warn("PTS < DTS detected in video samples, offsetting DTS from PTS by " + toMsFromMpegTsClock(-averageSampleDuration, true) + " ms");
                      var lastDts = ptsDtsShift;
                      for (var _i = 0; _i < nbSamples; _i++) {
                        inputSamples[_i].dts = lastDts = Math.max(lastDts, inputSamples[_i].pts - averageSampleDuration);
                        inputSamples[_i].pts = Math.max(lastDts, inputSamples[_i].pts);
                      }
                    } else {
                      logger["logger"].warn("PTS < DTS detected in video samples, shifting DTS by " + toMsFromMpegTsClock(ptsDtsShift, true) + " ms to overcome this issue");
                      for (var _i2 = 0; _i2 < nbSamples; _i2++) {
                        inputSamples[_i2].dts = inputSamples[_i2].dts + ptsDtsShift;
                      }
                    }
                    firstDTS = inputSamples[0].dts;
                    lastDTS = inputSamples[nbSamples - 1].dts;
                  }
                  if (contiguous) {
                    var delta = firstDTS - nextAvcDts;
                    var foundHole = delta > averageSampleDuration;
                    var foundOverlap = delta < -1;
                    if (foundHole || foundOverlap) {
                      if (foundHole) {
                        logger["logger"].warn("AVC: " + toMsFromMpegTsClock(delta, true) + " ms (" + delta + "dts) hole between fragments detected, filling it");
                      } else {
                        logger["logger"].warn("AVC: " + toMsFromMpegTsClock(-delta, true) + " ms (" + delta + "dts) overlapping between fragments detected");
                      }
                      firstDTS = nextAvcDts;
                      var firstPTS = inputSamples[0].pts - delta;
                      inputSamples[0].dts = firstDTS;
                      inputSamples[0].pts = firstPTS;
                      logger["logger"].log("Video: First PTS/DTS adjusted: " + toMsFromMpegTsClock(firstPTS, true) + "/" + toMsFromMpegTsClock(firstDTS, true) + ", delta: " + toMsFromMpegTsClock(delta, true) + " ms");
                    }
                  }
                  if (chromeVersion && chromeVersion < 75) {
                    firstDTS = Math.max(0, firstDTS);
                  }
                  var nbNalu = 0;
                  var naluLen = 0;
                  for (var _i3 = 0; _i3 < nbSamples; _i3++) {
                    var _sample = inputSamples[_i3];
                    var units = _sample.units;
                    var nbUnits = units.length;
                    var sampleLen = 0;
                    for (var j = 0; j < nbUnits; j++) {
                      sampleLen += units[j].data.length;
                    }
                    naluLen += sampleLen;
                    nbNalu += nbUnits;
                    _sample.length = sampleLen;
                    _sample.dts = Math.max(_sample.dts, firstDTS);
                    _sample.pts = Math.max(_sample.pts, _sample.dts, 0);
                    minPTS = Math.min(_sample.pts, minPTS);
                    maxPTS = Math.max(_sample.pts, maxPTS);
                  }
                  lastDTS = inputSamples[nbSamples - 1].dts;
                  var mdatSize = naluLen + 4 * nbNalu + 8;
                  try {
                    mdat = new Uint8Array(mdatSize);
                  } catch (err) {
                    this.observer.trigger(events["default"].ERROR, {
                      type: errors["ErrorTypes"].MUX_ERROR,
                      details: errors["ErrorDetails"].REMUX_ALLOC_ERROR,
                      fatal: false,
                      bytes: mdatSize,
                      reason: "fail allocating video mdat " + mdatSize
                    });
                    return;
                  }
                  var view = new DataView(mdat.buffer);
                  view.setUint32(0, mdatSize);
                  mdat.set(mp4_generator.types.mdat, 4);
                  for (var _i4 = 0; _i4 < nbSamples; _i4++) {
                    var avcSample = inputSamples[_i4];
                    var avcSampleUnits = avcSample.units;
                    var mp4SampleLength = 0;
                    var compositionTimeOffset = void 0;
                    for (var _j = 0, _nbUnits = avcSampleUnits.length; _j < _nbUnits; _j++) {
                      var unit = avcSampleUnits[_j];
                      var unitData = unit.data;
                      var unitDataLen = unit.data.byteLength;
                      view.setUint32(offset, unitDataLen);
                      offset += 4;
                      mdat.set(unitData, offset);
                      offset += unitDataLen;
                      mp4SampleLength += 4 + unitDataLen;
                    }
                    if (_i4 < nbSamples - 1) {
                      mp4SampleDuration = inputSamples[_i4 + 1].dts - avcSample.dts;
                    } else {
                      var config = this.config;
                      var lastFrameDuration = avcSample.dts - inputSamples[_i4 > 0 ? _i4 - 1 : _i4].dts;
                      if (config.stretchShortVideoTrack) {
                        var maxBufferHole = config.maxBufferHole;
                        var gapTolerance = Math.floor(maxBufferHole * timeScale);
                        var deltaToFrameEnd = (audioTrackLength ? minPTS + audioTrackLength * timeScale : this.nextAudioPts) - avcSample.pts;
                        if (deltaToFrameEnd > gapTolerance) {
                          mp4SampleDuration = deltaToFrameEnd - lastFrameDuration;
                          if (mp4SampleDuration < 0) {
                            mp4SampleDuration = lastFrameDuration;
                          }
                          logger["logger"].log("It is approximately " + toMsFromMpegTsClock(deltaToFrameEnd, false) + " ms to the next segment; using duration " + toMsFromMpegTsClock(mp4SampleDuration, false) + " ms for the last video frame.");
                        } else {
                          mp4SampleDuration = lastFrameDuration;
                        }
                      } else {
                        mp4SampleDuration = lastFrameDuration;
                      }
                    }
                    compositionTimeOffset = Math.round(avcSample.pts - avcSample.dts);
                    outputSamples.push({
                      size: mp4SampleLength,
                      // constant duration
                      duration: mp4SampleDuration,
                      cts: compositionTimeOffset,
                      flags: {
                        isLeading: 0,
                        isDependedOn: 0,
                        hasRedundancy: 0,
                        degradPrio: 0,
                        dependsOn: avcSample.key ? 2 : 1,
                        isNonSync: avcSample.key ? 0 : 1
                      }
                    });
                  }
                  this.nextAvcDts = lastDTS + mp4SampleDuration;
                  var dropped = track.dropped;
                  track.nbNalu = 0;
                  track.dropped = 0;
                  if (outputSamples.length && navigator.userAgent.toLowerCase().indexOf("chrome") > -1) {
                    var flags = outputSamples[0].flags;
                    flags.dependsOn = 2;
                    flags.isNonSync = 0;
                  }
                  track.samples = outputSamples;
                  moof = mp4_generator.moof(track.sequenceNumber++, firstDTS, track);
                  track.samples = [];
                  var data = {
                    data1: moof,
                    data2: mdat,
                    startPTS: minPTS / timeScale,
                    endPTS: (maxPTS + mp4SampleDuration) / timeScale,
                    startDTS: firstDTS / timeScale,
                    endDTS: this.nextAvcDts / timeScale,
                    type: "video",
                    hasAudio: false,
                    hasVideo: true,
                    nb: outputSamples.length,
                    dropped
                  };
                  this.observer.trigger(events["default"].FRAG_PARSING_DATA, data);
                  return data;
                };
                _proto.remuxAudio = function remuxAudio(track, timeOffset, contiguous, accurateTimeOffset) {
                  var inputTimeScale = track.inputTimeScale;
                  var mp4timeScale = track.timescale;
                  var scaleFactor = inputTimeScale / mp4timeScale;
                  var mp4SampleDuration = track.isAAC ? 1024 : 1152;
                  var inputSampleDuration = mp4SampleDuration * scaleFactor;
                  var initPTS = this._initPTS;
                  var rawMPEG = !track.isAAC && this.typeSupported.mpeg;
                  var mp4Sample;
                  var fillFrame;
                  var mdat;
                  var moof;
                  var firstPTS;
                  var lastPTS;
                  var offset = rawMPEG ? 0 : 8;
                  var inputSamples = track.samples;
                  var outputSamples = [];
                  var nextAudioPts = this.nextAudioPts;
                  contiguous |= inputSamples.length && nextAudioPts && (accurateTimeOffset && Math.abs(timeOffset - nextAudioPts / inputTimeScale) < 0.1 || Math.abs(inputSamples[0].pts - nextAudioPts - initPTS) < 20 * inputSampleDuration);
                  inputSamples.forEach(function(sample2) {
                    sample2.pts = sample2.dts = PTSNormalize(sample2.pts - initPTS, timeOffset * inputTimeScale);
                  });
                  inputSamples = inputSamples.filter(function(sample2) {
                    return sample2.pts >= 0;
                  });
                  if (inputSamples.length === 0) {
                    return;
                  }
                  if (!contiguous) {
                    if (!accurateTimeOffset) {
                      nextAudioPts = inputSamples[0].pts;
                    } else {
                      nextAudioPts = Math.max(0, timeOffset * inputTimeScale);
                    }
                  }
                  if (track.isAAC) {
                    var maxAudioFramesDrift = this.config.maxAudioFramesDrift;
                    for (var i = 0, nextPts = nextAudioPts; i < inputSamples.length; ) {
                      var sample = inputSamples[i];
                      var pts = sample.pts;
                      var delta = pts - nextPts;
                      if (delta <= -maxAudioFramesDrift * inputSampleDuration) {
                        if (contiguous || i > 0) {
                          logger["logger"].warn("Dropping 1 audio frame @ " + toMsFromMpegTsClock(nextPts, true) / 1e3 + "s due to " + toMsFromMpegTsClock(delta, true) + " ms overlap.");
                          inputSamples.splice(i, 1);
                        } else {
                          logger["logger"].warn("Audio frame @ " + toMsFromMpegTsClock(pts, true) / 1e3 + "s overlaps nextAudioPts by " + toMsFromMpegTsClock(delta, true) + " ms.");
                          nextPts = pts + inputSampleDuration;
                          i++;
                        }
                      } else if (delta >= maxAudioFramesDrift * inputSampleDuration && delta < MAX_SILENT_FRAME_DURATION_90KHZ && nextPts) {
                        var missing = Math.round(delta / inputSampleDuration);
                        logger["logger"].warn("Injecting " + missing + " audio frames @ " + toMsFromMpegTsClock(nextPts, true) / 1e3 + "s due to " + toMsFromMpegTsClock(delta, true) + " ms gap.");
                        for (var j = 0; j < missing; j++) {
                          var newStamp = Math.max(nextPts, 0);
                          fillFrame = aac_helper.getSilentFrame(track.manifestCodec || track.codec, track.channelCount);
                          if (!fillFrame) {
                            logger["logger"].log("Unable to get silent frame for given audio codec; duplicating last frame instead.");
                            fillFrame = sample.unit.subarray();
                          }
                          inputSamples.splice(i, 0, {
                            unit: fillFrame,
                            pts: newStamp,
                            dts: newStamp
                          });
                          nextPts += inputSampleDuration;
                          i++;
                        }
                        sample.pts = sample.dts = nextPts;
                        nextPts += inputSampleDuration;
                        i++;
                      } else {
                        if (Math.abs(delta) > 0.1 * inputSampleDuration) {
                        }
                        sample.pts = sample.dts = nextPts;
                        nextPts += inputSampleDuration;
                        i++;
                      }
                    }
                  }
                  var nbSamples = inputSamples.length;
                  var mdatSize = 0;
                  while (nbSamples--) {
                    mdatSize += inputSamples[nbSamples].unit.byteLength;
                  }
                  for (var _j2 = 0, _nbSamples = inputSamples.length; _j2 < _nbSamples; _j2++) {
                    var audioSample = inputSamples[_j2];
                    var unit = audioSample.unit;
                    var _pts = audioSample.pts;
                    if (lastPTS !== void 0 && mp4Sample) {
                      mp4Sample.duration = Math.round((_pts - lastPTS) / scaleFactor);
                    } else {
                      var _delta = _pts - nextAudioPts;
                      var numMissingFrames = 0;
                      if (contiguous && track.isAAC) {
                        if (_delta) {
                          if (_delta > 0 && _delta < MAX_SILENT_FRAME_DURATION_90KHZ) {
                            numMissingFrames = Math.round((_pts - nextAudioPts) / inputSampleDuration);
                            logger["logger"].log(toMsFromMpegTsClock(_delta, true) + " ms hole between AAC samples detected,filling it");
                            if (numMissingFrames > 0) {
                              fillFrame = aac_helper.getSilentFrame(track.manifestCodec || track.codec, track.channelCount);
                              if (!fillFrame) {
                                fillFrame = unit.subarray();
                              }
                              mdatSize += numMissingFrames * fillFrame.length;
                            }
                          } else if (_delta < -12) {
                            logger["logger"].log("drop overlapping AAC sample, expected/parsed/delta: " + toMsFromMpegTsClock(nextAudioPts, true) + " ms / " + toMsFromMpegTsClock(_pts, true) + " ms / " + toMsFromMpegTsClock(-_delta, true) + " ms");
                            mdatSize -= unit.byteLength;
                            continue;
                          }
                          _pts = nextAudioPts;
                        }
                      }
                      firstPTS = _pts;
                      if (mdatSize > 0) {
                        mdatSize += offset;
                        try {
                          mdat = new Uint8Array(mdatSize);
                        } catch (err) {
                          this.observer.trigger(events["default"].ERROR, {
                            type: errors["ErrorTypes"].MUX_ERROR,
                            details: errors["ErrorDetails"].REMUX_ALLOC_ERROR,
                            fatal: false,
                            bytes: mdatSize,
                            reason: "fail allocating audio mdat " + mdatSize
                          });
                          return;
                        }
                        if (!rawMPEG) {
                          var view = new DataView(mdat.buffer);
                          view.setUint32(0, mdatSize);
                          mdat.set(mp4_generator.types.mdat, 4);
                        }
                      } else {
                        return;
                      }
                      for (var _i5 = 0; _i5 < numMissingFrames; _i5++) {
                        fillFrame = aac_helper.getSilentFrame(track.manifestCodec || track.codec, track.channelCount);
                        if (!fillFrame) {
                          logger["logger"].log("Unable to get silent frame for given audio codec; duplicating this frame instead.");
                          fillFrame = unit.subarray();
                        }
                        mdat.set(fillFrame, offset);
                        offset += fillFrame.byteLength;
                        mp4Sample = {
                          size: fillFrame.byteLength,
                          cts: 0,
                          duration: 1024,
                          flags: {
                            isLeading: 0,
                            isDependedOn: 0,
                            hasRedundancy: 0,
                            degradPrio: 0,
                            dependsOn: 1
                          }
                        };
                        outputSamples.push(mp4Sample);
                      }
                    }
                    mdat.set(unit, offset);
                    var unitLen = unit.byteLength;
                    offset += unitLen;
                    mp4Sample = {
                      size: unitLen,
                      cts: 0,
                      duration: 0,
                      flags: {
                        isLeading: 0,
                        isDependedOn: 0,
                        hasRedundancy: 0,
                        degradPrio: 0,
                        dependsOn: 1
                      }
                    };
                    outputSamples.push(mp4Sample);
                    lastPTS = _pts;
                  }
                  var lastSampleDuration = 0;
                  nbSamples = outputSamples.length;
                  if (nbSamples >= 2) {
                    lastSampleDuration = outputSamples[nbSamples - 2].duration;
                    mp4Sample.duration = lastSampleDuration;
                  }
                  if (nbSamples) {
                    this.nextAudioPts = nextAudioPts = lastPTS + scaleFactor * lastSampleDuration;
                    track.samples = outputSamples;
                    if (rawMPEG) {
                      moof = new Uint8Array();
                    } else {
                      moof = mp4_generator.moof(track.sequenceNumber++, firstPTS / scaleFactor, track);
                    }
                    track.samples = [];
                    var start = firstPTS / inputTimeScale;
                    var end = nextAudioPts / inputTimeScale;
                    var audioData = {
                      data1: moof,
                      data2: mdat,
                      startPTS: start,
                      endPTS: end,
                      startDTS: start,
                      endDTS: end,
                      type: "audio",
                      hasAudio: true,
                      hasVideo: false,
                      nb: nbSamples
                    };
                    this.observer.trigger(events["default"].FRAG_PARSING_DATA, audioData);
                    return audioData;
                  }
                  return null;
                };
                _proto.remuxEmptyAudio = function remuxEmptyAudio(track, timeOffset, contiguous, videoData) {
                  var inputTimeScale = track.inputTimeScale;
                  var mp4timeScale = track.samplerate ? track.samplerate : inputTimeScale;
                  var scaleFactor = inputTimeScale / mp4timeScale;
                  var nextAudioPts = this.nextAudioPts;
                  var startDTS = (nextAudioPts !== void 0 ? nextAudioPts : videoData.startDTS * inputTimeScale) + this._initDTS;
                  var endDTS = videoData.endDTS * inputTimeScale + this._initDTS;
                  var sampleDuration = 1024;
                  var frameDuration = scaleFactor * sampleDuration;
                  var nbSamples = Math.ceil((endDTS - startDTS) / frameDuration);
                  var silentFrame = aac_helper.getSilentFrame(track.manifestCodec || track.codec, track.channelCount);
                  logger["logger"].warn("remux empty Audio");
                  if (!silentFrame) {
                    logger["logger"].trace("Unable to remuxEmptyAudio since we were unable to get a silent frame for given audio codec!");
                    return;
                  }
                  var samples = [];
                  for (var i = 0; i < nbSamples; i++) {
                    var stamp = startDTS + i * frameDuration;
                    samples.push({
                      unit: silentFrame,
                      pts: stamp,
                      dts: stamp
                    });
                  }
                  track.samples = samples;
                  this.remuxAudio(track, timeOffset, contiguous);
                };
                _proto.remuxID3 = function remuxID3(track, timeOffset) {
                  var length = track.samples.length;
                  if (!length) {
                    return;
                  }
                  var inputTimeScale = track.inputTimeScale;
                  var initPTS = this._initPTS;
                  var initDTS = this._initDTS;
                  for (var index = 0; index < length; index++) {
                    var sample = track.samples[index];
                    sample.pts = PTSNormalize(sample.pts - initPTS, timeOffset * inputTimeScale) / inputTimeScale;
                    sample.dts = PTSNormalize(sample.dts - initDTS, timeOffset * inputTimeScale) / inputTimeScale;
                  }
                  this.observer.trigger(events["default"].FRAG_PARSING_METADATA, {
                    samples: track.samples
                  });
                  track.samples = [];
                };
                _proto.remuxText = function remuxText(track, timeOffset) {
                  var length = track.samples.length;
                  var inputTimeScale = track.inputTimeScale;
                  var initPTS = this._initPTS;
                  if (length) {
                    for (var index = 0; index < length; index++) {
                      var sample = track.samples[index];
                      sample.pts = PTSNormalize(sample.pts - initPTS, timeOffset * inputTimeScale) / inputTimeScale;
                    }
                    track.samples.sort(function(a, b) {
                      return a.pts - b.pts;
                    });
                    this.observer.trigger(events["default"].FRAG_PARSING_USERDATA, {
                      samples: track.samples
                    });
                  }
                  track.samples = [];
                };
                return MP4Remuxer;
              }();
              function PTSNormalize(value, reference) {
                var offset;
                if (reference === void 0) {
                  return value;
                }
                if (reference < value) {
                  offset = -8589934592;
                } else {
                  offset = 8589934592;
                }
                while (Math.abs(value - reference) > 4294967296) {
                  value += offset;
                }
                return value;
              }
              var mp4_remuxer = mp4_remuxer_MP4Remuxer;
              var passthrough_remuxer_PassThroughRemuxer = function() {
                function PassThroughRemuxer(observer) {
                  this.observer = observer;
                }
                var _proto = PassThroughRemuxer.prototype;
                _proto.destroy = function destroy() {
                };
                _proto.resetTimeStamp = function resetTimeStamp() {
                };
                _proto.resetInitSegment = function resetInitSegment() {
                };
                _proto.remux = function remux(audioTrack, videoTrack, id3Track, textTrack, timeOffset, contiguous, accurateTimeOffset, rawData) {
                  var observer = this.observer;
                  var streamType = "";
                  if (audioTrack) {
                    streamType += "audio";
                  }
                  if (videoTrack) {
                    streamType += "video";
                  }
                  observer.trigger(events["default"].FRAG_PARSING_DATA, {
                    data1: rawData,
                    startPTS: timeOffset,
                    startDTS: timeOffset,
                    type: streamType,
                    hasAudio: !!audioTrack,
                    hasVideo: !!videoTrack,
                    nb: 1,
                    dropped: 0
                  });
                  observer.trigger(events["default"].FRAG_PARSED);
                };
                return PassThroughRemuxer;
              }();
              var passthrough_remuxer = passthrough_remuxer_PassThroughRemuxer;
              var global = Object(get_self_scope["getSelfScope"])();
              var now;
              try {
                now = global.performance.now.bind(global.performance);
              } catch (err) {
                logger["logger"].debug("Unable to use Performance API on this environment");
                now = global.Date.now;
              }
              var demuxer_inline_DemuxerInline = function() {
                function DemuxerInline(observer, typeSupported, config, vendor) {
                  this.observer = observer;
                  this.typeSupported = typeSupported;
                  this.config = config;
                  this.vendor = vendor;
                }
                var _proto = DemuxerInline.prototype;
                _proto.destroy = function destroy() {
                  var demuxer = this.demuxer;
                  if (demuxer) {
                    demuxer.destroy();
                  }
                };
                _proto.push = function push(data, decryptdata, initSegment, audioCodec, videoCodec, timeOffset, discontinuity, trackSwitch, contiguous, duration, accurateTimeOffset, defaultInitPTS) {
                  var _this = this;
                  if (data.byteLength > 0 && decryptdata != null && decryptdata.key != null && decryptdata.method === "AES-128") {
                    var decrypter = this.decrypter;
                    if (decrypter == null) {
                      decrypter = this.decrypter = new crypt_decrypter["default"](this.observer, this.config);
                    }
                    var startTime = now();
                    decrypter.decrypt(data, decryptdata.key.buffer, decryptdata.iv.buffer, function(decryptedData) {
                      var endTime = now();
                      _this.observer.trigger(events["default"].FRAG_DECRYPTED, {
                        stats: {
                          tstart: startTime,
                          tdecrypt: endTime
                        }
                      });
                      _this.pushDecrypted(new Uint8Array(decryptedData), decryptdata, new Uint8Array(initSegment), audioCodec, videoCodec, timeOffset, discontinuity, trackSwitch, contiguous, duration, accurateTimeOffset, defaultInitPTS);
                    });
                  } else {
                    this.pushDecrypted(new Uint8Array(data), decryptdata, new Uint8Array(initSegment), audioCodec, videoCodec, timeOffset, discontinuity, trackSwitch, contiguous, duration, accurateTimeOffset, defaultInitPTS);
                  }
                };
                _proto.pushDecrypted = function pushDecrypted(data, decryptdata, initSegment, audioCodec, videoCodec, timeOffset, discontinuity, trackSwitch, contiguous, duration, accurateTimeOffset, defaultInitPTS) {
                  var demuxer = this.demuxer;
                  var remuxer = this.remuxer;
                  if (!demuxer || // in case of continuity change, or track switch
                  // we might switch from content type (AAC container to TS container, or TS to fmp4 for example)
                  discontinuity || trackSwitch) {
                    var observer = this.observer;
                    var typeSupported = this.typeSupported;
                    var config = this.config;
                    var muxConfig = [{
                      demux: tsdemuxer,
                      remux: mp4_remuxer
                    }, {
                      demux: mp4demuxer["default"],
                      remux: passthrough_remuxer
                    }, {
                      demux: aacdemuxer,
                      remux: mp4_remuxer
                    }, {
                      demux: mp3demuxer,
                      remux: mp4_remuxer
                    }];
                    var mux;
                    for (var i = 0, len = muxConfig.length; i < len; i++) {
                      mux = muxConfig[i];
                      if (mux.demux.probe(data)) {
                        break;
                      }
                    }
                    if (!mux) {
                      observer.trigger(events["default"].ERROR, {
                        type: errors["ErrorTypes"].MEDIA_ERROR,
                        details: errors["ErrorDetails"].FRAG_PARSING_ERROR,
                        fatal: true,
                        reason: "no demux matching with content found"
                      });
                      return;
                    }
                    if (!remuxer || !(remuxer instanceof mux.remux)) {
                      remuxer = new mux.remux(observer, config, typeSupported, this.vendor);
                    }
                    if (!demuxer || !(demuxer instanceof mux.demux)) {
                      demuxer = new mux.demux(observer, remuxer, config, typeSupported);
                      this.probe = mux.demux.probe;
                    }
                    this.demuxer = demuxer;
                    this.remuxer = remuxer;
                  }
                  if (discontinuity || trackSwitch) {
                    demuxer.resetInitSegment(initSegment, audioCodec, videoCodec, duration);
                    remuxer.resetInitSegment();
                  }
                  if (discontinuity) {
                    demuxer.resetTimeStamp(defaultInitPTS);
                    remuxer.resetTimeStamp(defaultInitPTS);
                  }
                  if (typeof demuxer.setDecryptData === "function") {
                    demuxer.setDecryptData(decryptdata);
                  }
                  demuxer.append(data, timeOffset, contiguous, accurateTimeOffset);
                };
                return DemuxerInline;
              }();
              var demuxer_inline = __webpack_exports__["default"] = demuxer_inline_DemuxerInline;
            }
          ),
          /***/
          "./src/demux/demuxer-worker.js": (
            /*!*************************************!*\
              !*** ./src/demux/demuxer-worker.js ***!
              \*************************************/
            /*! exports provided: default */
            /*! ModuleConcatenation bailout: Module is referenced from these modules with unsupported syntax: ./src/demux/demuxer.js (referenced with require.resolve) */
            /***/
            function(module2, __webpack_exports__, __webpack_require__) {
              "use strict";
              __webpack_require__.r(__webpack_exports__);
              var _demux_demuxer_inline__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
                /*! ../demux/demuxer-inline */
                "./src/demux/demuxer-inline.js"
              );
              var _events__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
                /*! ../events */
                "./src/events.js"
              );
              var _utils_logger__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(
                /*! ../utils/logger */
                "./src/utils/logger.js"
              );
              var eventemitter3__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(
                /*! eventemitter3 */
                "./node_modules/eventemitter3/index.js"
              );
              var eventemitter3__WEBPACK_IMPORTED_MODULE_3___default = __webpack_require__.n(eventemitter3__WEBPACK_IMPORTED_MODULE_3__);
              var DemuxerWorker = function DemuxerWorker2(self2) {
                var observer = new eventemitter3__WEBPACK_IMPORTED_MODULE_3__["EventEmitter"]();
                observer.trigger = function trigger(event) {
                  for (var _len = arguments.length, data = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
                    data[_key - 1] = arguments[_key];
                  }
                  observer.emit.apply(observer, [event, event].concat(data));
                };
                observer.off = function off(event) {
                  for (var _len2 = arguments.length, data = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
                    data[_key2 - 1] = arguments[_key2];
                  }
                  observer.removeListener.apply(observer, [event].concat(data));
                };
                var forwardMessage = function forwardMessage2(ev, data) {
                  self2.postMessage({
                    event: ev,
                    data
                  });
                };
                self2.addEventListener("message", function(ev) {
                  var data = ev.data;
                  switch (data.cmd) {
                    case "init":
                      var config = JSON.parse(data.config);
                      self2.demuxer = new _demux_demuxer_inline__WEBPACK_IMPORTED_MODULE_0__["default"](observer, data.typeSupported, config, data.vendor);
                      Object(_utils_logger__WEBPACK_IMPORTED_MODULE_2__["enableLogs"])(config.debug);
                      forwardMessage("init", null);
                      break;
                    case "demux":
                      self2.demuxer.push(data.data, data.decryptdata, data.initSegment, data.audioCodec, data.videoCodec, data.timeOffset, data.discontinuity, data.trackSwitch, data.contiguous, data.duration, data.accurateTimeOffset, data.defaultInitPTS);
                      break;
                    default:
                      break;
                  }
                });
                observer.on(_events__WEBPACK_IMPORTED_MODULE_1__["default"].FRAG_DECRYPTED, forwardMessage);
                observer.on(_events__WEBPACK_IMPORTED_MODULE_1__["default"].FRAG_PARSING_INIT_SEGMENT, forwardMessage);
                observer.on(_events__WEBPACK_IMPORTED_MODULE_1__["default"].FRAG_PARSED, forwardMessage);
                observer.on(_events__WEBPACK_IMPORTED_MODULE_1__["default"].ERROR, forwardMessage);
                observer.on(_events__WEBPACK_IMPORTED_MODULE_1__["default"].FRAG_PARSING_METADATA, forwardMessage);
                observer.on(_events__WEBPACK_IMPORTED_MODULE_1__["default"].FRAG_PARSING_USERDATA, forwardMessage);
                observer.on(_events__WEBPACK_IMPORTED_MODULE_1__["default"].INIT_PTS_FOUND, forwardMessage);
                observer.on(_events__WEBPACK_IMPORTED_MODULE_1__["default"].FRAG_PARSING_DATA, function(ev, data) {
                  var transferable = [];
                  var message = {
                    event: ev,
                    data
                  };
                  if (data.data1) {
                    message.data1 = data.data1.buffer;
                    transferable.push(data.data1.buffer);
                    delete data.data1;
                  }
                  if (data.data2) {
                    message.data2 = data.data2.buffer;
                    transferable.push(data.data2.buffer);
                    delete data.data2;
                  }
                  self2.postMessage(message, transferable);
                });
              };
              __webpack_exports__["default"] = DemuxerWorker;
            }
          ),
          /***/
          "./src/demux/id3.js": (
            /*!**************************!*\
              !*** ./src/demux/id3.js ***!
              \**************************/
            /*! exports provided: default, utf8ArrayToStr */
            /***/
            function(module2, __webpack_exports__, __webpack_require__) {
              "use strict";
              __webpack_require__.r(__webpack_exports__);
              __webpack_require__.d(__webpack_exports__, "utf8ArrayToStr", function() {
                return utf8ArrayToStr;
              });
              var _utils_get_self_scope__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
                /*! ../utils/get-self-scope */
                "./src/utils/get-self-scope.js"
              );
              var ID3 = function() {
                function ID32() {
                }
                ID32.isHeader = function isHeader(data, offset) {
                  if (offset + 10 <= data.length) {
                    if (data[offset] === 73 && data[offset + 1] === 68 && data[offset + 2] === 51) {
                      if (data[offset + 3] < 255 && data[offset + 4] < 255) {
                        if (data[offset + 6] < 128 && data[offset + 7] < 128 && data[offset + 8] < 128 && data[offset + 9] < 128) {
                          return true;
                        }
                      }
                    }
                  }
                  return false;
                };
                ID32.isFooter = function isFooter(data, offset) {
                  if (offset + 10 <= data.length) {
                    if (data[offset] === 51 && data[offset + 1] === 68 && data[offset + 2] === 73) {
                      if (data[offset + 3] < 255 && data[offset + 4] < 255) {
                        if (data[offset + 6] < 128 && data[offset + 7] < 128 && data[offset + 8] < 128 && data[offset + 9] < 128) {
                          return true;
                        }
                      }
                    }
                  }
                  return false;
                };
                ID32.getID3Data = function getID3Data(data, offset) {
                  var front = offset;
                  var length = 0;
                  while (ID32.isHeader(data, offset)) {
                    length += 10;
                    var size = ID32._readSize(data, offset + 6);
                    length += size;
                    if (ID32.isFooter(data, offset + 10)) {
                      length += 10;
                    }
                    offset += length;
                  }
                  if (length > 0) {
                    return data.subarray(front, front + length);
                  }
                  return void 0;
                };
                ID32._readSize = function _readSize(data, offset) {
                  var size = 0;
                  size = (data[offset] & 127) << 21;
                  size |= (data[offset + 1] & 127) << 14;
                  size |= (data[offset + 2] & 127) << 7;
                  size |= data[offset + 3] & 127;
                  return size;
                };
                ID32.getTimeStamp = function getTimeStamp(data) {
                  var frames = ID32.getID3Frames(data);
                  for (var i = 0; i < frames.length; i++) {
                    var frame = frames[i];
                    if (ID32.isTimeStampFrame(frame)) {
                      return ID32._readTimeStamp(frame);
                    }
                  }
                  return void 0;
                };
                ID32.isTimeStampFrame = function isTimeStampFrame(frame) {
                  return frame && frame.key === "PRIV" && frame.info === "com.apple.streaming.transportStreamTimestamp";
                };
                ID32._getFrameData = function _getFrameData(data) {
                  var type = String.fromCharCode(data[0], data[1], data[2], data[3]);
                  var size = ID32._readSize(data, 4);
                  var offset = 10;
                  return {
                    type,
                    size,
                    data: data.subarray(offset, offset + size)
                  };
                };
                ID32.getID3Frames = function getID3Frames(id3Data) {
                  var offset = 0;
                  var frames = [];
                  while (ID32.isHeader(id3Data, offset)) {
                    var size = ID32._readSize(id3Data, offset + 6);
                    offset += 10;
                    var end = offset + size;
                    while (offset + 8 < end) {
                      var frameData = ID32._getFrameData(id3Data.subarray(offset));
                      var frame = ID32._decodeFrame(frameData);
                      if (frame) {
                        frames.push(frame);
                      }
                      offset += frameData.size + 10;
                    }
                    if (ID32.isFooter(id3Data, offset)) {
                      offset += 10;
                    }
                  }
                  return frames;
                };
                ID32._decodeFrame = function _decodeFrame(frame) {
                  if (frame.type === "PRIV") {
                    return ID32._decodePrivFrame(frame);
                  } else if (frame.type[0] === "W") {
                    return ID32._decodeURLFrame(frame);
                  }
                  return ID32._decodeTextFrame(frame);
                };
                ID32._readTimeStamp = function _readTimeStamp(timeStampFrame) {
                  if (timeStampFrame.data.byteLength === 8) {
                    var data = new Uint8Array(timeStampFrame.data);
                    var pts33Bit = data[3] & 1;
                    var timestamp = (data[4] << 23) + (data[5] << 15) + (data[6] << 7) + data[7];
                    timestamp /= 45;
                    if (pts33Bit) {
                      timestamp += 4772185884e-2;
                    }
                    return Math.round(timestamp);
                  }
                  return void 0;
                };
                ID32._decodePrivFrame = function _decodePrivFrame(frame) {
                  if (frame.size < 2) {
                    return void 0;
                  }
                  var owner = ID32._utf8ArrayToStr(frame.data, true);
                  var privateData = new Uint8Array(frame.data.subarray(owner.length + 1));
                  return {
                    key: frame.type,
                    info: owner,
                    data: privateData.buffer
                  };
                };
                ID32._decodeTextFrame = function _decodeTextFrame(frame) {
                  if (frame.size < 2) {
                    return void 0;
                  }
                  if (frame.type === "TXXX") {
                    var index = 1;
                    var description = ID32._utf8ArrayToStr(frame.data.subarray(index), true);
                    index += description.length + 1;
                    var value = ID32._utf8ArrayToStr(frame.data.subarray(index));
                    return {
                      key: frame.type,
                      info: description,
                      data: value
                    };
                  } else {
                    var text = ID32._utf8ArrayToStr(frame.data.subarray(1));
                    return {
                      key: frame.type,
                      data: text
                    };
                  }
                };
                ID32._decodeURLFrame = function _decodeURLFrame(frame) {
                  if (frame.type === "WXXX") {
                    if (frame.size < 2) {
                      return void 0;
                    }
                    var index = 1;
                    var description = ID32._utf8ArrayToStr(frame.data.subarray(index), true);
                    index += description.length + 1;
                    var value = ID32._utf8ArrayToStr(frame.data.subarray(index));
                    return {
                      key: frame.type,
                      info: description,
                      data: value
                    };
                  } else {
                    var url = ID32._utf8ArrayToStr(frame.data);
                    return {
                      key: frame.type,
                      data: url
                    };
                  }
                };
                ID32._utf8ArrayToStr = function _utf8ArrayToStr(array, exitOnNull) {
                  if (exitOnNull === void 0) {
                    exitOnNull = false;
                  }
                  var decoder2 = getTextDecoder();
                  if (decoder2) {
                    var decoded = decoder2.decode(array);
                    if (exitOnNull) {
                      var idx = decoded.indexOf("\0");
                      return idx !== -1 ? decoded.substring(0, idx) : decoded;
                    }
                    return decoded.replace(/\0/g, "");
                  }
                  var len = array.length;
                  var c;
                  var char2;
                  var char3;
                  var out = "";
                  var i = 0;
                  while (i < len) {
                    c = array[i++];
                    if (c === 0 && exitOnNull) {
                      return out;
                    } else if (c === 0 || c === 3) {
                      continue;
                    }
                    switch (c >> 4) {
                      case 0:
                      case 1:
                      case 2:
                      case 3:
                      case 4:
                      case 5:
                      case 6:
                      case 7:
                        out += String.fromCharCode(c);
                        break;
                      case 12:
                      case 13:
                        char2 = array[i++];
                        out += String.fromCharCode((c & 31) << 6 | char2 & 63);
                        break;
                      case 14:
                        char2 = array[i++];
                        char3 = array[i++];
                        out += String.fromCharCode((c & 15) << 12 | (char2 & 63) << 6 | (char3 & 63) << 0);
                        break;
                      default:
                    }
                  }
                  return out;
                };
                return ID32;
              }();
              var decoder;
              function getTextDecoder() {
                var global = Object(_utils_get_self_scope__WEBPACK_IMPORTED_MODULE_0__["getSelfScope"])();
                if (!decoder && typeof global.TextDecoder !== "undefined") {
                  decoder = new global.TextDecoder("utf-8");
                }
                return decoder;
              }
              var utf8ArrayToStr = ID3._utf8ArrayToStr;
              __webpack_exports__["default"] = ID3;
            }
          ),
          /***/
          "./src/demux/mp4demuxer.js": (
            /*!*********************************!*\
              !*** ./src/demux/mp4demuxer.js ***!
              \*********************************/
            /*! exports provided: default */
            /***/
            function(module2, __webpack_exports__, __webpack_require__) {
              "use strict";
              __webpack_require__.r(__webpack_exports__);
              var _utils_logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
                /*! ../utils/logger */
                "./src/utils/logger.js"
              );
              var _events__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
                /*! ../events */
                "./src/events.js"
              );
              var UINT32_MAX = Math.pow(2, 32) - 1;
              var MP4Demuxer = function() {
                function MP4Demuxer2(observer, remuxer) {
                  this.observer = observer;
                  this.remuxer = remuxer;
                }
                var _proto = MP4Demuxer2.prototype;
                _proto.resetTimeStamp = function resetTimeStamp(initPTS) {
                  this.initPTS = initPTS;
                };
                _proto.resetInitSegment = function resetInitSegment(initSegment, audioCodec, videoCodec, duration) {
                  if (initSegment && initSegment.byteLength) {
                    var initData = this.initData = MP4Demuxer2.parseInitSegment(initSegment);
                    if (audioCodec == null) {
                      audioCodec = "mp4a.40.5";
                    }
                    if (videoCodec == null) {
                      videoCodec = "avc1.42e01e";
                    }
                    var tracks = {};
                    if (initData.audio && initData.video) {
                      tracks.audiovideo = {
                        container: "video/mp4",
                        codec: audioCodec + "," + videoCodec,
                        initSegment: duration ? initSegment : null
                      };
                    } else {
                      if (initData.audio) {
                        tracks.audio = {
                          container: "audio/mp4",
                          codec: audioCodec,
                          initSegment: duration ? initSegment : null
                        };
                      }
                      if (initData.video) {
                        tracks.video = {
                          container: "video/mp4",
                          codec: videoCodec,
                          initSegment: duration ? initSegment : null
                        };
                      }
                    }
                    this.observer.trigger(_events__WEBPACK_IMPORTED_MODULE_1__["default"].FRAG_PARSING_INIT_SEGMENT, {
                      tracks
                    });
                  } else {
                    if (audioCodec) {
                      this.audioCodec = audioCodec;
                    }
                    if (videoCodec) {
                      this.videoCodec = videoCodec;
                    }
                  }
                };
                MP4Demuxer2.probe = function probe(data) {
                  return MP4Demuxer2.findBox({
                    data,
                    start: 0,
                    end: Math.min(data.length, 16384)
                  }, ["moof"]).length > 0;
                };
                MP4Demuxer2.bin2str = function bin2str(buffer) {
                  return String.fromCharCode.apply(null, buffer);
                };
                MP4Demuxer2.readUint16 = function readUint16(buffer, offset) {
                  if (buffer.data) {
                    offset += buffer.start;
                    buffer = buffer.data;
                  }
                  var val = buffer[offset] << 8 | buffer[offset + 1];
                  return val < 0 ? 65536 + val : val;
                };
                MP4Demuxer2.readUint32 = function readUint32(buffer, offset) {
                  if (buffer.data) {
                    offset += buffer.start;
                    buffer = buffer.data;
                  }
                  var val = buffer[offset] << 24 | buffer[offset + 1] << 16 | buffer[offset + 2] << 8 | buffer[offset + 3];
                  return val < 0 ? 4294967296 + val : val;
                };
                MP4Demuxer2.writeUint32 = function writeUint32(buffer, offset, value) {
                  if (buffer.data) {
                    offset += buffer.start;
                    buffer = buffer.data;
                  }
                  buffer[offset] = value >> 24;
                  buffer[offset + 1] = value >> 16 & 255;
                  buffer[offset + 2] = value >> 8 & 255;
                  buffer[offset + 3] = value & 255;
                };
                MP4Demuxer2.findBox = function findBox(data, path) {
                  var results = [], i, size, type, end, subresults, start, endbox;
                  if (data.data) {
                    start = data.start;
                    end = data.end;
                    data = data.data;
                  } else {
                    start = 0;
                    end = data.byteLength;
                  }
                  if (!path.length) {
                    return null;
                  }
                  for (i = start; i < end; ) {
                    size = MP4Demuxer2.readUint32(data, i);
                    type = MP4Demuxer2.bin2str(data.subarray(i + 4, i + 8));
                    endbox = size > 1 ? i + size : end;
                    if (type === path[0]) {
                      if (path.length === 1) {
                        results.push({
                          data,
                          start: i + 8,
                          end: endbox
                        });
                      } else {
                        subresults = MP4Demuxer2.findBox({
                          data,
                          start: i + 8,
                          end: endbox
                        }, path.slice(1));
                        if (subresults.length) {
                          results = results.concat(subresults);
                        }
                      }
                    }
                    i = endbox;
                  }
                  return results;
                };
                MP4Demuxer2.parseSegmentIndex = function parseSegmentIndex(initSegment) {
                  var moov = MP4Demuxer2.findBox(initSegment, ["moov"])[0];
                  var moovEndOffset = moov ? moov.end : null;
                  var index = 0;
                  var sidx = MP4Demuxer2.findBox(initSegment, ["sidx"]);
                  var references;
                  if (!sidx || !sidx[0]) {
                    return null;
                  }
                  references = [];
                  sidx = sidx[0];
                  var version = sidx.data[0];
                  index = version === 0 ? 8 : 16;
                  var timescale = MP4Demuxer2.readUint32(sidx, index);
                  index += 4;
                  var earliestPresentationTime = 0;
                  var firstOffset = 0;
                  if (version === 0) {
                    index += 8;
                  } else {
                    index += 16;
                  }
                  index += 2;
                  var startByte = sidx.end + firstOffset;
                  var referencesCount = MP4Demuxer2.readUint16(sidx, index);
                  index += 2;
                  for (var i = 0; i < referencesCount; i++) {
                    var referenceIndex = index;
                    var referenceInfo = MP4Demuxer2.readUint32(sidx, referenceIndex);
                    referenceIndex += 4;
                    var referenceSize = referenceInfo & 2147483647;
                    var referenceType = (referenceInfo & 2147483648) >>> 31;
                    if (referenceType === 1) {
                      console.warn("SIDX has hierarchical references (not supported)");
                      return;
                    }
                    var subsegmentDuration = MP4Demuxer2.readUint32(sidx, referenceIndex);
                    referenceIndex += 4;
                    references.push({
                      referenceSize,
                      subsegmentDuration,
                      // unscaled
                      info: {
                        duration: subsegmentDuration / timescale,
                        start: startByte,
                        end: startByte + referenceSize - 1
                      }
                    });
                    startByte += referenceSize;
                    referenceIndex += 4;
                    index = referenceIndex;
                  }
                  return {
                    earliestPresentationTime,
                    timescale,
                    version,
                    referencesCount,
                    references,
                    moovEndOffset
                  };
                };
                MP4Demuxer2.parseInitSegment = function parseInitSegment(initSegment) {
                  var result = [];
                  var traks = MP4Demuxer2.findBox(initSegment, ["moov", "trak"]);
                  traks.forEach(function(trak) {
                    var tkhd = MP4Demuxer2.findBox(trak, ["tkhd"])[0];
                    if (tkhd) {
                      var version = tkhd.data[tkhd.start];
                      var index = version === 0 ? 12 : 20;
                      var trackId = MP4Demuxer2.readUint32(tkhd, index);
                      var mdhd = MP4Demuxer2.findBox(trak, ["mdia", "mdhd"])[0];
                      if (mdhd) {
                        version = mdhd.data[mdhd.start];
                        index = version === 0 ? 12 : 20;
                        var timescale = MP4Demuxer2.readUint32(mdhd, index);
                        var hdlr = MP4Demuxer2.findBox(trak, ["mdia", "hdlr"])[0];
                        if (hdlr) {
                          var hdlrType = MP4Demuxer2.bin2str(hdlr.data.subarray(hdlr.start + 8, hdlr.start + 12));
                          var type = {
                            "soun": "audio",
                            "vide": "video"
                          }[hdlrType];
                          if (type) {
                            var codecBox = MP4Demuxer2.findBox(trak, ["mdia", "minf", "stbl", "stsd"]);
                            if (codecBox.length) {
                              codecBox = codecBox[0];
                              var codecType = MP4Demuxer2.bin2str(codecBox.data.subarray(codecBox.start + 12, codecBox.start + 16));
                              _utils_logger__WEBPACK_IMPORTED_MODULE_0__["logger"].log("MP4Demuxer:" + type + ":" + codecType + " found");
                            }
                            result[trackId] = {
                              timescale,
                              type
                            };
                            result[type] = {
                              timescale,
                              id: trackId
                            };
                          }
                        }
                      }
                    }
                  });
                  return result;
                };
                MP4Demuxer2.getStartDTS = function getStartDTS(initData, fragment) {
                  var trafs, baseTimes, result;
                  trafs = MP4Demuxer2.findBox(fragment, ["moof", "traf"]);
                  baseTimes = [].concat.apply([], trafs.map(function(traf) {
                    return MP4Demuxer2.findBox(traf, ["tfhd"]).map(function(tfhd) {
                      var id, scale, baseTime;
                      id = MP4Demuxer2.readUint32(tfhd, 4);
                      scale = initData[id].timescale || 9e4;
                      baseTime = MP4Demuxer2.findBox(traf, ["tfdt"]).map(function(tfdt) {
                        var version, result2;
                        version = tfdt.data[tfdt.start];
                        result2 = MP4Demuxer2.readUint32(tfdt, 4);
                        if (version === 1) {
                          result2 *= Math.pow(2, 32);
                          result2 += MP4Demuxer2.readUint32(tfdt, 8);
                        }
                        return result2;
                      })[0];
                      return baseTime / scale;
                    });
                  }));
                  result = Math.min.apply(null, baseTimes);
                  return isFinite(result) ? result : 0;
                };
                MP4Demuxer2.offsetStartDTS = function offsetStartDTS(initData, fragment, timeOffset) {
                  MP4Demuxer2.findBox(fragment, ["moof", "traf"]).map(function(traf) {
                    return MP4Demuxer2.findBox(traf, ["tfhd"]).map(function(tfhd) {
                      var id = MP4Demuxer2.readUint32(tfhd, 4);
                      var timescale = initData[id].timescale || 9e4;
                      MP4Demuxer2.findBox(traf, ["tfdt"]).map(function(tfdt) {
                        var version = tfdt.data[tfdt.start];
                        var baseMediaDecodeTime = MP4Demuxer2.readUint32(tfdt, 4);
                        if (version === 0) {
                          MP4Demuxer2.writeUint32(tfdt, 4, baseMediaDecodeTime - timeOffset * timescale);
                        } else {
                          baseMediaDecodeTime *= Math.pow(2, 32);
                          baseMediaDecodeTime += MP4Demuxer2.readUint32(tfdt, 8);
                          baseMediaDecodeTime -= timeOffset * timescale;
                          baseMediaDecodeTime = Math.max(baseMediaDecodeTime, 0);
                          var upper = Math.floor(baseMediaDecodeTime / (UINT32_MAX + 1));
                          var lower = Math.floor(baseMediaDecodeTime % (UINT32_MAX + 1));
                          MP4Demuxer2.writeUint32(tfdt, 4, upper);
                          MP4Demuxer2.writeUint32(tfdt, 8, lower);
                        }
                      });
                    });
                  });
                };
                _proto.append = function append(data, timeOffset, contiguous, accurateTimeOffset) {
                  var initData = this.initData;
                  if (!initData) {
                    this.resetInitSegment(data, this.audioCodec, this.videoCodec, false);
                    initData = this.initData;
                  }
                  var startDTS, initPTS = this.initPTS;
                  if (initPTS === void 0) {
                    var _startDTS = MP4Demuxer2.getStartDTS(initData, data);
                    this.initPTS = initPTS = _startDTS - timeOffset;
                    this.observer.trigger(_events__WEBPACK_IMPORTED_MODULE_1__["default"].INIT_PTS_FOUND, {
                      initPTS
                    });
                  }
                  MP4Demuxer2.offsetStartDTS(initData, data, initPTS);
                  startDTS = MP4Demuxer2.getStartDTS(initData, data);
                  this.remuxer.remux(initData.audio, initData.video, null, null, startDTS, contiguous, accurateTimeOffset, data);
                };
                _proto.destroy = function destroy() {
                };
                return MP4Demuxer2;
              }();
              __webpack_exports__["default"] = MP4Demuxer;
            }
          ),
          /***/
          "./src/errors.ts": (
            /*!***********************!*\
              !*** ./src/errors.ts ***!
              \***********************/
            /*! exports provided: ErrorTypes, ErrorDetails */
            /***/
            function(module2, __webpack_exports__, __webpack_require__) {
              "use strict";
              __webpack_require__.r(__webpack_exports__);
              __webpack_require__.d(__webpack_exports__, "ErrorTypes", function() {
                return ErrorTypes;
              });
              __webpack_require__.d(__webpack_exports__, "ErrorDetails", function() {
                return ErrorDetails;
              });
              var ErrorTypes;
              (function(ErrorTypes2) {
                ErrorTypes2["NETWORK_ERROR"] = "networkError";
                ErrorTypes2["MEDIA_ERROR"] = "mediaError";
                ErrorTypes2["KEY_SYSTEM_ERROR"] = "keySystemError";
                ErrorTypes2["MUX_ERROR"] = "muxError";
                ErrorTypes2["OTHER_ERROR"] = "otherError";
              })(ErrorTypes || (ErrorTypes = {}));
              var ErrorDetails;
              (function(ErrorDetails2) {
                ErrorDetails2["KEY_SYSTEM_NO_KEYS"] = "keySystemNoKeys";
                ErrorDetails2["KEY_SYSTEM_NO_ACCESS"] = "keySystemNoAccess";
                ErrorDetails2["KEY_SYSTEM_NO_SESSION"] = "keySystemNoSession";
                ErrorDetails2["KEY_SYSTEM_LICENSE_REQUEST_FAILED"] = "keySystemLicenseRequestFailed";
                ErrorDetails2["KEY_SYSTEM_NO_INIT_DATA"] = "keySystemNoInitData";
                ErrorDetails2["MANIFEST_LOAD_ERROR"] = "manifestLoadError";
                ErrorDetails2["MANIFEST_LOAD_TIMEOUT"] = "manifestLoadTimeOut";
                ErrorDetails2["MANIFEST_PARSING_ERROR"] = "manifestParsingError";
                ErrorDetails2["MANIFEST_INCOMPATIBLE_CODECS_ERROR"] = "manifestIncompatibleCodecsError";
                ErrorDetails2["LEVEL_EMPTY_ERROR"] = "levelEmptyError";
                ErrorDetails2["LEVEL_LOAD_ERROR"] = "levelLoadError";
                ErrorDetails2["LEVEL_LOAD_TIMEOUT"] = "levelLoadTimeOut";
                ErrorDetails2["LEVEL_SWITCH_ERROR"] = "levelSwitchError";
                ErrorDetails2["AUDIO_TRACK_LOAD_ERROR"] = "audioTrackLoadError";
                ErrorDetails2["AUDIO_TRACK_LOAD_TIMEOUT"] = "audioTrackLoadTimeOut";
                ErrorDetails2["FRAG_LOAD_ERROR"] = "fragLoadError";
                ErrorDetails2["FRAG_LOAD_TIMEOUT"] = "fragLoadTimeOut";
                ErrorDetails2["FRAG_DECRYPT_ERROR"] = "fragDecryptError";
                ErrorDetails2["FRAG_PARSING_ERROR"] = "fragParsingError";
                ErrorDetails2["REMUX_ALLOC_ERROR"] = "remuxAllocError";
                ErrorDetails2["KEY_LOAD_ERROR"] = "keyLoadError";
                ErrorDetails2["KEY_LOAD_TIMEOUT"] = "keyLoadTimeOut";
                ErrorDetails2["BUFFER_ADD_CODEC_ERROR"] = "bufferAddCodecError";
                ErrorDetails2["BUFFER_APPEND_ERROR"] = "bufferAppendError";
                ErrorDetails2["BUFFER_APPENDING_ERROR"] = "bufferAppendingError";
                ErrorDetails2["BUFFER_STALLED_ERROR"] = "bufferStalledError";
                ErrorDetails2["BUFFER_FULL_ERROR"] = "bufferFullError";
                ErrorDetails2["BUFFER_SEEK_OVER_HOLE"] = "bufferSeekOverHole";
                ErrorDetails2["BUFFER_NUDGE_ON_STALL"] = "bufferNudgeOnStall";
                ErrorDetails2["INTERNAL_EXCEPTION"] = "internalException";
              })(ErrorDetails || (ErrorDetails = {}));
            }
          ),
          /***/
          "./src/events.js": (
            /*!***********************!*\
              !*** ./src/events.js ***!
              \***********************/
            /*! exports provided: default */
            /***/
            function(module2, __webpack_exports__, __webpack_require__) {
              "use strict";
              __webpack_require__.r(__webpack_exports__);
              var HlsEvents = {
                // fired before MediaSource is attaching to media element - data: { media }
                MEDIA_ATTACHING: "hlsMediaAttaching",
                // fired when MediaSource has been succesfully attached to media element - data: { }
                MEDIA_ATTACHED: "hlsMediaAttached",
                // fired before detaching MediaSource from media element - data: { }
                MEDIA_DETACHING: "hlsMediaDetaching",
                // fired when MediaSource has been detached from media element - data: { }
                MEDIA_DETACHED: "hlsMediaDetached",
                // fired when we buffer is going to be reset - data: { }
                BUFFER_RESET: "hlsBufferReset",
                // fired when we know about the codecs that we need buffers for to push into - data: {tracks : { container, codec, levelCodec, initSegment, metadata }}
                BUFFER_CODECS: "hlsBufferCodecs",
                // fired when sourcebuffers have been created - data: { tracks : tracks }
                BUFFER_CREATED: "hlsBufferCreated",
                // fired when we append a segment to the buffer - data: { segment: segment object }
                BUFFER_APPENDING: "hlsBufferAppending",
                // fired when we are done with appending a media segment to the buffer - data : { parent : segment parent that triggered BUFFER_APPENDING, pending : nb of segments waiting for appending for this segment parent}
                BUFFER_APPENDED: "hlsBufferAppended",
                // fired when the stream is finished and we want to notify the media buffer that there will be no more data - data: { }
                BUFFER_EOS: "hlsBufferEos",
                // fired when the media buffer should be flushed - data { startOffset, endOffset }
                BUFFER_FLUSHING: "hlsBufferFlushing",
                // fired when the media buffer has been flushed - data: { }
                BUFFER_FLUSHED: "hlsBufferFlushed",
                // fired to signal that a manifest loading starts - data: { url : manifestURL}
                MANIFEST_LOADING: "hlsManifestLoading",
                // fired after manifest has been loaded - data: { levels : [available quality levels], audioTracks : [ available audio tracks], url : manifestURL, stats : { trequest, tfirst, tload, mtime}}
                MANIFEST_LOADED: "hlsManifestLoaded",
                // fired after manifest has been parsed - data: { levels : [available quality levels], firstLevel : index of first quality level appearing in Manifest}
                MANIFEST_PARSED: "hlsManifestParsed",
                // fired when a level switch is requested - data: { level : id of new level }
                LEVEL_SWITCHING: "hlsLevelSwitching",
                // fired when a level switch is effective - data: { level : id of new level }
                LEVEL_SWITCHED: "hlsLevelSwitched",
                // fired when a level playlist loading starts - data: { url : level URL, level : id of level being loaded}
                LEVEL_LOADING: "hlsLevelLoading",
                // fired when a level playlist loading finishes - data: { details : levelDetails object, level : id of loaded level, stats : { trequest, tfirst, tload, mtime} }
                LEVEL_LOADED: "hlsLevelLoaded",
                // fired when a level's details have been updated based on previous details, after it has been loaded - data: { details : levelDetails object, level : id of updated level }
                LEVEL_UPDATED: "hlsLevelUpdated",
                // fired when a level's PTS information has been updated after parsing a fragment - data: { details : levelDetails object, level : id of updated level, drift: PTS drift observed when parsing last fragment }
                LEVEL_PTS_UPDATED: "hlsLevelPtsUpdated",
                // fired to notify that levels have changed after removing a level - data: { levels : [available quality levels] }
                LEVELS_UPDATED: "hlsLevelsUpdated",
                // fired to notify that audio track lists has been updated - data: { audioTracks : audioTracks }
                AUDIO_TRACKS_UPDATED: "hlsAudioTracksUpdated",
                // fired when an audio track switching is requested - data: { id : audio track id }
                AUDIO_TRACK_SWITCHING: "hlsAudioTrackSwitching",
                // fired when an audio track switch actually occurs - data: { id : audio track id }
                AUDIO_TRACK_SWITCHED: "hlsAudioTrackSwitched",
                // fired when an audio track loading starts - data: { url : audio track URL, id : audio track id }
                AUDIO_TRACK_LOADING: "hlsAudioTrackLoading",
                // fired when an audio track loading finishes - data: { details : levelDetails object, id : audio track id, stats : { trequest, tfirst, tload, mtime } }
                AUDIO_TRACK_LOADED: "hlsAudioTrackLoaded",
                // fired to notify that subtitle track lists has been updated - data: { subtitleTracks : subtitleTracks }
                SUBTITLE_TRACKS_UPDATED: "hlsSubtitleTracksUpdated",
                // fired when an subtitle track switch occurs - data: { id : subtitle track id }
                SUBTITLE_TRACK_SWITCH: "hlsSubtitleTrackSwitch",
                // fired when a subtitle track loading starts - data: { url : subtitle track URL, id : subtitle track id }
                SUBTITLE_TRACK_LOADING: "hlsSubtitleTrackLoading",
                // fired when a subtitle track loading finishes - data: { details : levelDetails object, id : subtitle track id, stats : { trequest, tfirst, tload, mtime } }
                SUBTITLE_TRACK_LOADED: "hlsSubtitleTrackLoaded",
                // fired when a subtitle fragment has been processed - data: { success : boolean, frag : the processed frag }
                SUBTITLE_FRAG_PROCESSED: "hlsSubtitleFragProcessed",
                // fired when a set of VTTCues to be managed externally has been parsed - data: { type: string, track: string, cues: [ VTTCue ] }
                CUES_PARSED: "hlsCuesParsed",
                // fired when a text track to be managed externally is found - data: { tracks: [ { label: string, kind: string, default: boolean } ] }
                NON_NATIVE_TEXT_TRACKS_FOUND: "hlsNonNativeTextTracksFound",
                // fired when the first timestamp is found - data: { id : demuxer id, initPTS: initPTS, frag : fragment object }
                INIT_PTS_FOUND: "hlsInitPtsFound",
                // fired when a fragment loading starts - data: { frag : fragment object }
                FRAG_LOADING: "hlsFragLoading",
                // fired when a fragment loading is progressing - data: { frag : fragment object, { trequest, tfirst, loaded } }
                FRAG_LOAD_PROGRESS: "hlsFragLoadProgress",
                // Identifier for fragment load aborting for emergency switch down - data: { frag : fragment object }
                FRAG_LOAD_EMERGENCY_ABORTED: "hlsFragLoadEmergencyAborted",
                // fired when a fragment loading is completed - data: { frag : fragment object, payload : fragment payload, stats : { trequest, tfirst, tload, length } }
                FRAG_LOADED: "hlsFragLoaded",
                // fired when a fragment has finished decrypting - data: { id : demuxer id, frag: fragment object, payload : fragment payload, stats : { tstart, tdecrypt } }
                FRAG_DECRYPTED: "hlsFragDecrypted",
                // fired when Init Segment has been extracted from fragment - data: { id : demuxer id, frag: fragment object, moov : moov MP4 box, codecs : codecs found while parsing fragment }
                FRAG_PARSING_INIT_SEGMENT: "hlsFragParsingInitSegment",
                // fired when parsing sei text is completed - data: { id : demuxer id, frag: fragment object, samples : [ sei samples pes ] }
                FRAG_PARSING_USERDATA: "hlsFragParsingUserdata",
                // fired when parsing id3 is completed - data: { id : demuxer id, frag: fragment object, samples : [ id3 samples pes ] }
                FRAG_PARSING_METADATA: "hlsFragParsingMetadata",
                // fired when data have been extracted from fragment - data: { id : demuxer id, frag: fragment object, data1 : moof MP4 box or TS fragments, data2 : mdat MP4 box or null}
                FRAG_PARSING_DATA: "hlsFragParsingData",
                // fired when fragment parsing is completed - data: { id : demuxer id, frag: fragment object }
                FRAG_PARSED: "hlsFragParsed",
                // fired when fragment remuxed MP4 boxes have all been appended into SourceBuffer - data: { id : demuxer id, frag : fragment object, stats : { trequest, tfirst, tload, tparsed, tbuffered, length, bwEstimate } }
                FRAG_BUFFERED: "hlsFragBuffered",
                // fired when fragment matching with current media position is changing - data : { id : demuxer id, frag : fragment object }
                FRAG_CHANGED: "hlsFragChanged",
                // Identifier for a FPS drop event - data: { curentDropped, currentDecoded, totalDroppedFrames }
                FPS_DROP: "hlsFpsDrop",
                // triggered when FPS drop triggers auto level capping - data: { level, droppedlevel }
                FPS_DROP_LEVEL_CAPPING: "hlsFpsDropLevelCapping",
                // Identifier for an error event - data: { type : error type, details : error details, fatal : if true, hls.js cannot/will not try to recover, if false, hls.js will try to recover,other error specific data }
                ERROR: "hlsError",
                // fired when hls.js instance starts destroying. Different from MEDIA_DETACHED as one could want to detach and reattach a media to the instance of hls.js to handle mid-rolls for example - data: { }
                DESTROYING: "hlsDestroying",
                // fired when a decrypt key loading starts - data: { frag : fragment object }
                KEY_LOADING: "hlsKeyLoading",
                // fired when a decrypt key loading is completed - data: { frag : fragment object, payload : key payload, stats : { trequest, tfirst, tload, length } }
                KEY_LOADED: "hlsKeyLoaded",
                // fired upon stream controller state transitions - data: { previousState, nextState }
                STREAM_STATE_TRANSITION: "hlsStreamStateTransition",
                // fired when the live back buffer is reached defined by the liveBackBufferLength config option - data : { bufferEnd: number }
                LIVE_BACK_BUFFER_REACHED: "hlsLiveBackBufferReached"
              };
              __webpack_exports__["default"] = HlsEvents;
            }
          ),
          /***/
          "./src/hls.ts": (
            /*!*********************************!*\
              !*** ./src/hls.ts + 50 modules ***!
              \*********************************/
            /*! exports provided: default */
            /*! ModuleConcatenation bailout: Cannot concat with ./src/crypt/decrypter.js because of ./src/demux/demuxer-worker.js */
            /*! ModuleConcatenation bailout: Cannot concat with ./src/demux/demuxer-inline.js because of ./src/demux/demuxer-worker.js */
            /*! ModuleConcatenation bailout: Cannot concat with ./src/demux/id3.js because of ./src/demux/demuxer-worker.js */
            /*! ModuleConcatenation bailout: Cannot concat with ./src/demux/mp4demuxer.js because of ./src/demux/demuxer-worker.js */
            /*! ModuleConcatenation bailout: Cannot concat with ./src/errors.ts because of ./src/demux/demuxer-worker.js */
            /*! ModuleConcatenation bailout: Cannot concat with ./src/events.js because of ./src/demux/demuxer-worker.js */
            /*! ModuleConcatenation bailout: Cannot concat with ./src/polyfills/number.js because of ./src/demux/demuxer-worker.js */
            /*! ModuleConcatenation bailout: Cannot concat with ./src/utils/get-self-scope.js because of ./src/demux/demuxer-worker.js */
            /*! ModuleConcatenation bailout: Cannot concat with ./src/utils/logger.js because of ./src/demux/demuxer-worker.js */
            /*! ModuleConcatenation bailout: Cannot concat with ./node_modules/eventemitter3/index.js (<- Module is not an ECMAScript module) */
            /*! ModuleConcatenation bailout: Cannot concat with ./node_modules/url-toolkit/src/url-toolkit.js (<- Module is not an ECMAScript module) */
            /***/
            function(module2, __webpack_exports__, __webpack_require__) {
              "use strict";
              __webpack_require__.r(__webpack_exports__);
              __webpack_require__.d(__webpack_exports__, "default", function() {
                return (
                  /* binding */
                  hls_Hls
                );
              });
              var cues_namespaceObject = {};
              __webpack_require__.r(cues_namespaceObject);
              __webpack_require__.d(cues_namespaceObject, "newCue", function() {
                return newCue;
              });
              var url_toolkit = __webpack_require__("./node_modules/url-toolkit/src/url-toolkit.js");
              var errors = __webpack_require__("./src/errors.ts");
              var number = __webpack_require__("./src/polyfills/number.js");
              var events = __webpack_require__("./src/events.js");
              var logger = __webpack_require__("./src/utils/logger.js");
              var FORBIDDEN_EVENT_NAMES = {
                "hlsEventGeneric": true,
                "hlsHandlerDestroying": true,
                "hlsHandlerDestroyed": true
              };
              var event_handler_EventHandler = function() {
                function EventHandler(hls) {
                  this.hls = void 0;
                  this.handledEvents = void 0;
                  this.useGenericHandler = void 0;
                  this.hls = hls;
                  this.onEvent = this.onEvent.bind(this);
                  for (var _len = arguments.length, events2 = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
                    events2[_key - 1] = arguments[_key];
                  }
                  this.handledEvents = events2;
                  this.useGenericHandler = true;
                  this.registerListeners();
                }
                var _proto = EventHandler.prototype;
                _proto.destroy = function destroy() {
                  this.onHandlerDestroying();
                  this.unregisterListeners();
                  this.onHandlerDestroyed();
                };
                _proto.onHandlerDestroying = function onHandlerDestroying() {
                };
                _proto.onHandlerDestroyed = function onHandlerDestroyed() {
                };
                _proto.isEventHandler = function isEventHandler() {
                  return typeof this.handledEvents === "object" && this.handledEvents.length && typeof this.onEvent === "function";
                };
                _proto.registerListeners = function registerListeners() {
                  if (this.isEventHandler()) {
                    this.handledEvents.forEach(function(event) {
                      if (FORBIDDEN_EVENT_NAMES[event]) {
                        throw new Error("Forbidden event-name: " + event);
                      }
                      this.hls.on(event, this.onEvent);
                    }, this);
                  }
                };
                _proto.unregisterListeners = function unregisterListeners() {
                  if (this.isEventHandler()) {
                    this.handledEvents.forEach(function(event) {
                      this.hls.off(event, this.onEvent);
                    }, this);
                  }
                };
                _proto.onEvent = function onEvent(event, data) {
                  this.onEventGeneric(event, data);
                };
                _proto.onEventGeneric = function onEventGeneric(event, data) {
                  var eventToFunction = function eventToFunction2(event2, data2) {
                    var funcName = "on" + event2.replace("hls", "");
                    if (typeof this[funcName] !== "function") {
                      throw new Error("Event " + event2 + " has no generic handler in this " + this.constructor.name + " class (tried " + funcName + ")");
                    }
                    return this[funcName].bind(this, data2);
                  };
                  try {
                    eventToFunction.call(this, event, data).call();
                  } catch (err) {
                    logger["logger"].error("An internal error happened while handling event " + event + '. Error message: "' + err.message + '". Here is a stacktrace:', err);
                    this.hls.trigger(events["default"].ERROR, {
                      type: errors["ErrorTypes"].OTHER_ERROR,
                      details: errors["ErrorDetails"].INTERNAL_EXCEPTION,
                      fatal: false,
                      event,
                      err
                    });
                  }
                };
                return EventHandler;
              }();
              var event_handler = event_handler_EventHandler;
              var PlaylistContextType;
              (function(PlaylistContextType2) {
                PlaylistContextType2["MANIFEST"] = "manifest";
                PlaylistContextType2["LEVEL"] = "level";
                PlaylistContextType2["AUDIO_TRACK"] = "audioTrack";
                PlaylistContextType2["SUBTITLE_TRACK"] = "subtitleTrack";
              })(PlaylistContextType || (PlaylistContextType = {}));
              var PlaylistLevelType;
              (function(PlaylistLevelType2) {
                PlaylistLevelType2["MAIN"] = "main";
                PlaylistLevelType2["AUDIO"] = "audio";
                PlaylistLevelType2["SUBTITLE"] = "subtitle";
              })(PlaylistLevelType || (PlaylistLevelType = {}));
              var mp4demuxer = __webpack_require__("./src/demux/mp4demuxer.js");
              function _defineProperties(target, props) {
                for (var i = 0; i < props.length; i++) {
                  var descriptor = props[i];
                  descriptor.enumerable = descriptor.enumerable || false;
                  descriptor.configurable = true;
                  if ("value" in descriptor)
                    descriptor.writable = true;
                  Object.defineProperty(target, descriptor.key, descriptor);
                }
              }
              function _createClass(Constructor, protoProps, staticProps) {
                if (protoProps)
                  _defineProperties(Constructor.prototype, protoProps);
                if (staticProps)
                  _defineProperties(Constructor, staticProps);
                return Constructor;
              }
              var level_key_LevelKey = function() {
                function LevelKey(baseURI, relativeURI) {
                  this._uri = null;
                  this.baseuri = void 0;
                  this.reluri = void 0;
                  this.method = null;
                  this.key = null;
                  this.iv = null;
                  this.baseuri = baseURI;
                  this.reluri = relativeURI;
                }
                _createClass(LevelKey, [{
                  key: "uri",
                  get: function get() {
                    if (!this._uri && this.reluri) {
                      this._uri = Object(url_toolkit["buildAbsoluteURL"])(this.baseuri, this.reluri, {
                        alwaysNormalize: true
                      });
                    }
                    return this._uri;
                  }
                }]);
                return LevelKey;
              }();
              function fragment_defineProperties(target, props) {
                for (var i = 0; i < props.length; i++) {
                  var descriptor = props[i];
                  descriptor.enumerable = descriptor.enumerable || false;
                  descriptor.configurable = true;
                  if ("value" in descriptor)
                    descriptor.writable = true;
                  Object.defineProperty(target, descriptor.key, descriptor);
                }
              }
              function fragment_createClass(Constructor, protoProps, staticProps) {
                if (protoProps)
                  fragment_defineProperties(Constructor.prototype, protoProps);
                if (staticProps)
                  fragment_defineProperties(Constructor, staticProps);
                return Constructor;
              }
              var ElementaryStreamTypes;
              (function(ElementaryStreamTypes2) {
                ElementaryStreamTypes2["AUDIO"] = "audio";
                ElementaryStreamTypes2["VIDEO"] = "video";
              })(ElementaryStreamTypes || (ElementaryStreamTypes = {}));
              var fragment_Fragment = function() {
                function Fragment() {
                  var _this$_elementaryStre;
                  this._url = null;
                  this._byteRange = null;
                  this._decryptdata = null;
                  this._elementaryStreams = (_this$_elementaryStre = {}, _this$_elementaryStre[ElementaryStreamTypes.AUDIO] = false, _this$_elementaryStre[ElementaryStreamTypes.VIDEO] = false, _this$_elementaryStre);
                  this.deltaPTS = 0;
                  this.rawProgramDateTime = null;
                  this.programDateTime = null;
                  this.title = null;
                  this.tagList = [];
                  this.cc = void 0;
                  this.type = void 0;
                  this.relurl = void 0;
                  this.baseurl = void 0;
                  this.duration = void 0;
                  this.start = void 0;
                  this.sn = 0;
                  this.urlId = 0;
                  this.level = 0;
                  this.levelkey = void 0;
                  this.loader = void 0;
                }
                var _proto = Fragment.prototype;
                _proto.setByteRange = function setByteRange(value, previousFrag) {
                  var params = value.split("@", 2);
                  var byteRange = [];
                  if (params.length === 1) {
                    byteRange[0] = previousFrag ? previousFrag.byteRangeEndOffset : 0;
                  } else {
                    byteRange[0] = parseInt(params[1]);
                  }
                  byteRange[1] = parseInt(params[0]) + byteRange[0];
                  this._byteRange = byteRange;
                };
                _proto.addElementaryStream = function addElementaryStream(type) {
                  this._elementaryStreams[type] = true;
                };
                _proto.hasElementaryStream = function hasElementaryStream(type) {
                  return this._elementaryStreams[type] === true;
                };
                _proto.createInitializationVector = function createInitializationVector(segmentNumber) {
                  var uint8View = new Uint8Array(16);
                  for (var i = 12; i < 16; i++) {
                    uint8View[i] = segmentNumber >> 8 * (15 - i) & 255;
                  }
                  return uint8View;
                };
                _proto.setDecryptDataFromLevelKey = function setDecryptDataFromLevelKey(levelkey, segmentNumber) {
                  var decryptdata = levelkey;
                  if ((levelkey === null || levelkey === void 0 ? void 0 : levelkey.method) && levelkey.uri && !levelkey.iv) {
                    decryptdata = new level_key_LevelKey(levelkey.baseuri, levelkey.reluri);
                    decryptdata.method = levelkey.method;
                    decryptdata.iv = this.createInitializationVector(segmentNumber);
                  }
                  return decryptdata;
                };
                fragment_createClass(Fragment, [{
                  key: "url",
                  get: function get() {
                    if (!this._url && this.relurl) {
                      this._url = Object(url_toolkit["buildAbsoluteURL"])(this.baseurl, this.relurl, {
                        alwaysNormalize: true
                      });
                    }
                    return this._url;
                  },
                  set: function set(value) {
                    this._url = value;
                  }
                }, {
                  key: "byteRange",
                  get: function get() {
                    if (!this._byteRange) {
                      return [];
                    }
                    return this._byteRange;
                  }
                  /**
                   * @type {number}
                   */
                }, {
                  key: "byteRangeStartOffset",
                  get: function get() {
                    return this.byteRange[0];
                  }
                }, {
                  key: "byteRangeEndOffset",
                  get: function get() {
                    return this.byteRange[1];
                  }
                }, {
                  key: "decryptdata",
                  get: function get() {
                    if (!this.levelkey && !this._decryptdata) {
                      return null;
                    }
                    if (!this._decryptdata && this.levelkey) {
                      var sn = this.sn;
                      if (typeof sn !== "number") {
                        if (this.levelkey && this.levelkey.method === "AES-128" && !this.levelkey.iv) {
                          logger["logger"].warn('missing IV for initialization segment with method="' + this.levelkey.method + '" - compliance issue');
                        }
                        sn = 0;
                      }
                      this._decryptdata = this.setDecryptDataFromLevelKey(this.levelkey, sn);
                    }
                    return this._decryptdata;
                  }
                }, {
                  key: "endProgramDateTime",
                  get: function get() {
                    if (this.programDateTime === null) {
                      return null;
                    }
                    if (!Object(number["isFiniteNumber"])(this.programDateTime)) {
                      return null;
                    }
                    var duration = !Object(number["isFiniteNumber"])(this.duration) ? 0 : this.duration;
                    return this.programDateTime + duration * 1e3;
                  }
                }, {
                  key: "encrypted",
                  get: function get() {
                    return !!(this.decryptdata && this.decryptdata.uri !== null && this.decryptdata.key === null);
                  }
                }]);
                return Fragment;
              }();
              function level_defineProperties(target, props) {
                for (var i = 0; i < props.length; i++) {
                  var descriptor = props[i];
                  descriptor.enumerable = descriptor.enumerable || false;
                  descriptor.configurable = true;
                  if ("value" in descriptor)
                    descriptor.writable = true;
                  Object.defineProperty(target, descriptor.key, descriptor);
                }
              }
              function level_createClass(Constructor, protoProps, staticProps) {
                if (protoProps)
                  level_defineProperties(Constructor.prototype, protoProps);
                if (staticProps)
                  level_defineProperties(Constructor, staticProps);
                return Constructor;
              }
              var level_Level = function() {
                function Level(baseUrl) {
                  this.endCC = 0;
                  this.endSN = 0;
                  this.fragments = [];
                  this.initSegment = null;
                  this.live = true;
                  this.needSidxRanges = false;
                  this.startCC = 0;
                  this.startSN = 0;
                  this.startTimeOffset = null;
                  this.targetduration = 0;
                  this.totalduration = 0;
                  this.type = null;
                  this.url = baseUrl;
                  this.version = null;
                }
                level_createClass(Level, [{
                  key: "hasProgramDateTime",
                  get: function get() {
                    return !!(this.fragments[0] && Object(number["isFiniteNumber"])(this.fragments[0].programDateTime));
                  }
                }]);
                return Level;
              }();
              var DECIMAL_RESOLUTION_REGEX = /^(\d+)x(\d+)$/;
              var ATTR_LIST_REGEX = /\s*(.+?)\s*=((?:\".*?\")|.*?)(?:,|$)/g;
              var AttrList = function() {
                function AttrList2(attrs) {
                  if (typeof attrs === "string") {
                    attrs = AttrList2.parseAttrList(attrs);
                  }
                  for (var attr in attrs) {
                    if (attrs.hasOwnProperty(attr)) {
                      this[attr] = attrs[attr];
                    }
                  }
                }
                var _proto = AttrList2.prototype;
                _proto.decimalInteger = function decimalInteger(attrName) {
                  var intValue = parseInt(this[attrName], 10);
                  if (intValue > Number.MAX_SAFE_INTEGER) {
                    return Infinity;
                  }
                  return intValue;
                };
                _proto.hexadecimalInteger = function hexadecimalInteger(attrName) {
                  if (this[attrName]) {
                    var stringValue = (this[attrName] || "0x").slice(2);
                    stringValue = (stringValue.length & 1 ? "0" : "") + stringValue;
                    var value = new Uint8Array(stringValue.length / 2);
                    for (var i = 0; i < stringValue.length / 2; i++) {
                      value[i] = parseInt(stringValue.slice(i * 2, i * 2 + 2), 16);
                    }
                    return value;
                  } else {
                    return null;
                  }
                };
                _proto.hexadecimalIntegerAsNumber = function hexadecimalIntegerAsNumber(attrName) {
                  var intValue = parseInt(this[attrName], 16);
                  if (intValue > Number.MAX_SAFE_INTEGER) {
                    return Infinity;
                  }
                  return intValue;
                };
                _proto.decimalFloatingPoint = function decimalFloatingPoint(attrName) {
                  return parseFloat(this[attrName]);
                };
                _proto.enumeratedString = function enumeratedString(attrName) {
                  return this[attrName];
                };
                _proto.decimalResolution = function decimalResolution(attrName) {
                  var res = DECIMAL_RESOLUTION_REGEX.exec(this[attrName]);
                  if (res === null) {
                    return void 0;
                  }
                  return {
                    width: parseInt(res[1], 10),
                    height: parseInt(res[2], 10)
                  };
                };
                AttrList2.parseAttrList = function parseAttrList(input) {
                  var match, attrs = {};
                  ATTR_LIST_REGEX.lastIndex = 0;
                  while ((match = ATTR_LIST_REGEX.exec(input)) !== null) {
                    var value = match[2], quote = '"';
                    if (value.indexOf(quote) === 0 && value.lastIndexOf(quote) === value.length - 1) {
                      value = value.slice(1, -1);
                    }
                    attrs[match[1]] = value;
                  }
                  return attrs;
                };
                return AttrList2;
              }();
              var attr_list = AttrList;
              var sampleEntryCodesISO = {
                audio: {
                  "a3ds": true,
                  "ac-3": true,
                  "ac-4": true,
                  "alac": true,
                  "alaw": true,
                  "dra1": true,
                  "dts+": true,
                  "dts-": true,
                  "dtsc": true,
                  "dtse": true,
                  "dtsh": true,
                  "ec-3": true,
                  "enca": true,
                  "g719": true,
                  "g726": true,
                  "m4ae": true,
                  "mha1": true,
                  "mha2": true,
                  "mhm1": true,
                  "mhm2": true,
                  "mlpa": true,
                  "mp4a": true,
                  "raw ": true,
                  "Opus": true,
                  "samr": true,
                  "sawb": true,
                  "sawp": true,
                  "sevc": true,
                  "sqcp": true,
                  "ssmv": true,
                  "twos": true,
                  "ulaw": true
                },
                video: {
                  "avc1": true,
                  "avc2": true,
                  "avc3": true,
                  "avc4": true,
                  "avcp": true,
                  "drac": true,
                  "dvav": true,
                  "dvhe": true,
                  "encv": true,
                  "hev1": true,
                  "hvc1": true,
                  "mjp2": true,
                  "mp4v": true,
                  "mvc1": true,
                  "mvc2": true,
                  "mvc3": true,
                  "mvc4": true,
                  "resv": true,
                  "rv60": true,
                  "s263": true,
                  "svc1": true,
                  "svc2": true,
                  "vc-1": true,
                  "vp08": true,
                  "vp09": true
                }
              };
              function isCodecType(codec, type) {
                var typeCodes = sampleEntryCodesISO[type];
                return !!typeCodes && typeCodes[codec.slice(0, 4)] === true;
              }
              function isCodecSupportedInMp4(codec, type) {
                return MediaSource.isTypeSupported((type || "video") + '/mp4;codecs="' + codec + '"');
              }
              var MASTER_PLAYLIST_REGEX = /(?:#EXT-X-STREAM-INF:([^\n\r]*)[\r\n]+([^\r\n]+)|#EXT-X-SESSION-DATA:([^\n\r]*)[\r\n]+)/g;
              var MASTER_PLAYLIST_MEDIA_REGEX = /#EXT-X-MEDIA:(.*)/g;
              var LEVEL_PLAYLIST_REGEX_FAST = new RegExp([
                /#EXTINF:\s*(\d*(?:\.\d+)?)(?:,(.*)\s+)?/.source,
                // duration (#EXTINF:<duration>,<title>), group 1 => duration, group 2 => title
                /|(?!#)([\S+ ?]+)/.source,
                // segment URI, group 3 => the URI (note newline is not eaten)
                /|#EXT-X-BYTERANGE:*(.+)/.source,
                // next segment's byterange, group 4 => range spec (x@y)
                /|#EXT-X-PROGRAM-DATE-TIME:(.+)/.source,
                // next segment's program date/time group 5 => the datetime spec
                /|#.*/.source
                // All other non-segment oriented tags will match with all groups empty
              ].join(""), "g");
              var LEVEL_PLAYLIST_REGEX_SLOW = /(?:(?:#(EXTM3U))|(?:#EXT-X-(PLAYLIST-TYPE):(.+))|(?:#EXT-X-(MEDIA-SEQUENCE): *(\d+))|(?:#EXT-X-(TARGETDURATION): *(\d+))|(?:#EXT-X-(KEY):(.+))|(?:#EXT-X-(START):(.+))|(?:#EXT-X-(ENDLIST))|(?:#EXT-X-(DISCONTINUITY-SEQ)UENCE:(\d+))|(?:#EXT-X-(DIS)CONTINUITY))|(?:#EXT-X-(VERSION):(\d+))|(?:#EXT-X-(MAP):(.+))|(?:(#)([^:]*):(.*))|(?:(#)(.*))(?:.*)\r?\n?/;
              var MP4_REGEX_SUFFIX = /\.(mp4|m4s|m4v|m4a)$/i;
              var m3u8_parser_M3U8Parser = function() {
                function M3U8Parser() {
                }
                M3U8Parser.findGroup = function findGroup(groups, mediaGroupId) {
                  for (var i = 0; i < groups.length; i++) {
                    var group = groups[i];
                    if (group.id === mediaGroupId) {
                      return group;
                    }
                  }
                };
                M3U8Parser.convertAVC1ToAVCOTI = function convertAVC1ToAVCOTI(codec) {
                  var avcdata = codec.split(".");
                  var result;
                  if (avcdata.length > 2) {
                    result = avcdata.shift() + ".";
                    result += parseInt(avcdata.shift()).toString(16);
                    result += ("000" + parseInt(avcdata.shift()).toString(16)).substr(-4);
                  } else {
                    result = codec;
                  }
                  return result;
                };
                M3U8Parser.resolve = function resolve(url, baseUrl) {
                  return url_toolkit["buildAbsoluteURL"](baseUrl, url, {
                    alwaysNormalize: true
                  });
                };
                M3U8Parser.parseMasterPlaylist = function parseMasterPlaylist(string, baseurl) {
                  var levels = [];
                  var sessionData = {};
                  var hasSessionData = false;
                  MASTER_PLAYLIST_REGEX.lastIndex = 0;
                  function setCodecs(codecs, level2) {
                    ["video", "audio"].forEach(function(type) {
                      var filtered = codecs.filter(function(codec) {
                        return isCodecType(codec, type);
                      });
                      if (filtered.length) {
                        var preferred = filtered.filter(function(codec) {
                          return codec.lastIndexOf("avc1", 0) === 0 || codec.lastIndexOf("mp4a", 0) === 0;
                        });
                        level2[type + "Codec"] = preferred.length > 0 ? preferred[0] : filtered[0];
                        codecs = codecs.filter(function(codec) {
                          return filtered.indexOf(codec) === -1;
                        });
                      }
                    });
                    level2.unknownCodecs = codecs;
                  }
                  var result;
                  while ((result = MASTER_PLAYLIST_REGEX.exec(string)) != null) {
                    if (result[1]) {
                      var level = {};
                      var attrs = level.attrs = new attr_list(result[1]);
                      level.url = M3U8Parser.resolve(result[2], baseurl);
                      var resolution = attrs.decimalResolution("RESOLUTION");
                      if (resolution) {
                        level.width = resolution.width;
                        level.height = resolution.height;
                      }
                      level.bitrate = attrs.decimalInteger("AVERAGE-BANDWIDTH") || attrs.decimalInteger("BANDWIDTH");
                      level.name = attrs.NAME;
                      setCodecs([].concat((attrs.CODECS || "").split(/[ ,]+/)), level);
                      if (level.videoCodec && level.videoCodec.indexOf("avc1") !== -1) {
                        level.videoCodec = M3U8Parser.convertAVC1ToAVCOTI(level.videoCodec);
                      }
                      levels.push(level);
                    } else if (result[3]) {
                      var sessionAttrs = new attr_list(result[3]);
                      if (sessionAttrs["DATA-ID"]) {
                        hasSessionData = true;
                        sessionData[sessionAttrs["DATA-ID"]] = sessionAttrs;
                      }
                    }
                  }
                  return {
                    levels,
                    sessionData: hasSessionData ? sessionData : null
                  };
                };
                M3U8Parser.parseMasterPlaylistMedia = function parseMasterPlaylistMedia(string, baseurl, type, audioGroups) {
                  if (audioGroups === void 0) {
                    audioGroups = [];
                  }
                  var result;
                  var medias = [];
                  var id = 0;
                  MASTER_PLAYLIST_MEDIA_REGEX.lastIndex = 0;
                  while ((result = MASTER_PLAYLIST_MEDIA_REGEX.exec(string)) !== null) {
                    var attrs = new attr_list(result[1]);
                    if (attrs.TYPE === type) {
                      var media = {
                        attrs,
                        id: id++,
                        groupId: attrs["GROUP-ID"],
                        instreamId: attrs["INSTREAM-ID"],
                        name: attrs.NAME || attrs.LANGUAGE,
                        type,
                        default: attrs.DEFAULT === "YES",
                        autoselect: attrs.AUTOSELECT === "YES",
                        forced: attrs.FORCED === "YES",
                        lang: attrs.LANGUAGE
                      };
                      if (attrs.URI) {
                        media.url = M3U8Parser.resolve(attrs.URI, baseurl);
                      }
                      if (audioGroups.length) {
                        var groupCodec = M3U8Parser.findGroup(audioGroups, media.groupId);
                        media.audioCodec = groupCodec ? groupCodec.codec : audioGroups[0].codec;
                      }
                      medias.push(media);
                    }
                  }
                  return medias;
                };
                M3U8Parser.parseLevelPlaylist = function parseLevelPlaylist(string, baseurl, id, type, levelUrlId) {
                  var currentSN = 0;
                  var totalduration = 0;
                  var level = new level_Level(baseurl);
                  var discontinuityCounter = 0;
                  var prevFrag = null;
                  var frag = new fragment_Fragment();
                  var result;
                  var i;
                  var levelkey;
                  var firstPdtIndex = null;
                  LEVEL_PLAYLIST_REGEX_FAST.lastIndex = 0;
                  while ((result = LEVEL_PLAYLIST_REGEX_FAST.exec(string)) !== null) {
                    var duration = result[1];
                    if (duration) {
                      frag.duration = parseFloat(duration);
                      var title = (" " + result[2]).slice(1);
                      frag.title = title || null;
                      frag.tagList.push(title ? ["INF", duration, title] : ["INF", duration]);
                    } else if (result[3]) {
                      if (Object(number["isFiniteNumber"])(frag.duration)) {
                        var sn = currentSN++;
                        frag.type = type;
                        frag.start = totalduration;
                        if (levelkey) {
                          frag.levelkey = levelkey;
                        }
                        frag.sn = sn;
                        frag.level = id;
                        frag.cc = discontinuityCounter;
                        frag.urlId = levelUrlId;
                        frag.baseurl = baseurl;
                        frag.relurl = (" " + result[3]).slice(1);
                        assignProgramDateTime(frag, prevFrag);
                        level.fragments.push(frag);
                        prevFrag = frag;
                        totalduration += frag.duration;
                        frag = new fragment_Fragment();
                      }
                    } else if (result[4]) {
                      var data = (" " + result[4]).slice(1);
                      if (prevFrag) {
                        frag.setByteRange(data, prevFrag);
                      } else {
                        frag.setByteRange(data);
                      }
                    } else if (result[5]) {
                      frag.rawProgramDateTime = (" " + result[5]).slice(1);
                      frag.tagList.push(["PROGRAM-DATE-TIME", frag.rawProgramDateTime]);
                      if (firstPdtIndex === null) {
                        firstPdtIndex = level.fragments.length;
                      }
                    } else {
                      result = result[0].match(LEVEL_PLAYLIST_REGEX_SLOW);
                      if (!result) {
                        logger["logger"].warn("No matches on slow regex match for level playlist!");
                        continue;
                      }
                      for (i = 1; i < result.length; i++) {
                        if (typeof result[i] !== "undefined") {
                          break;
                        }
                      }
                      var value1 = (" " + result[i + 1]).slice(1);
                      var value2 = (" " + result[i + 2]).slice(1);
                      switch (result[i]) {
                        case "#":
                          frag.tagList.push(value2 ? [value1, value2] : [value1]);
                          break;
                        case "PLAYLIST-TYPE":
                          level.type = value1.toUpperCase();
                          break;
                        case "MEDIA-SEQUENCE":
                          currentSN = level.startSN = parseInt(value1);
                          break;
                        case "TARGETDURATION":
                          level.targetduration = parseFloat(value1);
                          break;
                        case "VERSION":
                          level.version = parseInt(value1);
                          break;
                        case "EXTM3U":
                          break;
                        case "ENDLIST":
                          level.live = false;
                          break;
                        case "DIS":
                          discontinuityCounter++;
                          frag.tagList.push(["DIS"]);
                          break;
                        case "DISCONTINUITY-SEQ":
                          discontinuityCounter = parseInt(value1);
                          break;
                        case "KEY": {
                          var decryptparams = value1;
                          var keyAttrs = new attr_list(decryptparams);
                          var decryptmethod = keyAttrs.enumeratedString("METHOD");
                          var decrypturi = keyAttrs.URI;
                          var decryptiv = keyAttrs.hexadecimalInteger("IV");
                          var decryptkeyformat = keyAttrs.KEYFORMAT || "identity";
                          if (decryptkeyformat === "com.apple.streamingkeydelivery") {
                            logger["logger"].warn("Keyformat com.apple.streamingkeydelivery is not supported");
                            continue;
                          }
                          if (decryptmethod) {
                            levelkey = new level_key_LevelKey(baseurl, decrypturi);
                            if (decrypturi && ["AES-128", "SAMPLE-AES", "SAMPLE-AES-CENC"].indexOf(decryptmethod) >= 0) {
                              levelkey.method = decryptmethod;
                              levelkey.key = null;
                              levelkey.iv = decryptiv;
                            }
                          }
                          break;
                        }
                        case "START": {
                          var startAttrs = new attr_list(value1);
                          var startTimeOffset = startAttrs.decimalFloatingPoint("TIME-OFFSET");
                          if (Object(number["isFiniteNumber"])(startTimeOffset)) {
                            level.startTimeOffset = startTimeOffset;
                          }
                          break;
                        }
                        case "MAP": {
                          var mapAttrs = new attr_list(value1);
                          frag.relurl = mapAttrs.URI;
                          if (mapAttrs.BYTERANGE) {
                            frag.setByteRange(mapAttrs.BYTERANGE);
                          }
                          frag.baseurl = baseurl;
                          frag.level = id;
                          frag.type = type;
                          frag.sn = "initSegment";
                          level.initSegment = frag;
                          frag = new fragment_Fragment();
                          frag.rawProgramDateTime = level.initSegment.rawProgramDateTime;
                          break;
                        }
                        default:
                          logger["logger"].warn("line parsed but not handled: " + result);
                          break;
                      }
                    }
                  }
                  frag = prevFrag;
                  if (frag && !frag.relurl) {
                    level.fragments.pop();
                    totalduration -= frag.duration;
                  }
                  level.totalduration = totalduration;
                  level.averagetargetduration = totalduration / level.fragments.length;
                  level.endSN = currentSN - 1;
                  level.startCC = level.fragments[0] ? level.fragments[0].cc : 0;
                  level.endCC = discontinuityCounter;
                  if (!level.initSegment && level.fragments.length) {
                    if (level.fragments.every(function(frag2) {
                      return MP4_REGEX_SUFFIX.test(frag2.relurl);
                    })) {
                      logger["logger"].warn("MP4 fragments found but no init segment (probably no MAP, incomplete M3U8), trying to fetch SIDX");
                      frag = new fragment_Fragment();
                      frag.relurl = level.fragments[0].relurl;
                      frag.baseurl = baseurl;
                      frag.level = id;
                      frag.type = type;
                      frag.sn = "initSegment";
                      level.initSegment = frag;
                      level.needSidxRanges = true;
                    }
                  }
                  if (firstPdtIndex) {
                    backfillProgramDateTimes(level.fragments, firstPdtIndex);
                  }
                  return level;
                };
                return M3U8Parser;
              }();
              function backfillProgramDateTimes(fragments, startIndex) {
                var fragPrev = fragments[startIndex];
                for (var i = startIndex - 1; i >= 0; i--) {
                  var frag = fragments[i];
                  frag.programDateTime = fragPrev.programDateTime - frag.duration * 1e3;
                  fragPrev = frag;
                }
              }
              function assignProgramDateTime(frag, prevFrag) {
                if (frag.rawProgramDateTime) {
                  frag.programDateTime = Date.parse(frag.rawProgramDateTime);
                } else if (prevFrag === null || prevFrag === void 0 ? void 0 : prevFrag.programDateTime) {
                  frag.programDateTime = prevFrag.endProgramDateTime;
                }
                if (!Object(number["isFiniteNumber"])(frag.programDateTime)) {
                  frag.programDateTime = null;
                  frag.rawProgramDateTime = null;
                }
              }
              function _inheritsLoose(subClass, superClass) {
                subClass.prototype = Object.create(superClass.prototype);
                subClass.prototype.constructor = subClass;
                subClass.__proto__ = superClass;
              }
              var _window = window, performance = _window.performance;
              var playlist_loader_PlaylistLoader = function(_EventHandler) {
                _inheritsLoose(PlaylistLoader, _EventHandler);
                function PlaylistLoader(hls) {
                  var _this;
                  _this = _EventHandler.call(this, hls, events["default"].MANIFEST_LOADING, events["default"].LEVEL_LOADING, events["default"].AUDIO_TRACK_LOADING, events["default"].SUBTITLE_TRACK_LOADING) || this;
                  _this.loaders = {};
                  return _this;
                }
                PlaylistLoader.canHaveQualityLevels = function canHaveQualityLevels(type) {
                  return type !== PlaylistContextType.AUDIO_TRACK && type !== PlaylistContextType.SUBTITLE_TRACK;
                };
                PlaylistLoader.mapContextToLevelType = function mapContextToLevelType(context) {
                  var type = context.type;
                  switch (type) {
                    case PlaylistContextType.AUDIO_TRACK:
                      return PlaylistLevelType.AUDIO;
                    case PlaylistContextType.SUBTITLE_TRACK:
                      return PlaylistLevelType.SUBTITLE;
                    default:
                      return PlaylistLevelType.MAIN;
                  }
                };
                PlaylistLoader.getResponseUrl = function getResponseUrl(response, context) {
                  var url = response.url;
                  if (url === void 0 || url.indexOf("data:") === 0) {
                    url = context.url;
                  }
                  return url;
                };
                var _proto = PlaylistLoader.prototype;
                _proto.createInternalLoader = function createInternalLoader(context) {
                  var config = this.hls.config;
                  var PLoader = config.pLoader;
                  var Loader = config.loader;
                  var InternalLoader = PLoader || Loader;
                  var loader = new InternalLoader(config);
                  context.loader = loader;
                  this.loaders[context.type] = loader;
                  return loader;
                };
                _proto.getInternalLoader = function getInternalLoader(context) {
                  return this.loaders[context.type];
                };
                _proto.resetInternalLoader = function resetInternalLoader(contextType) {
                  if (this.loaders[contextType]) {
                    delete this.loaders[contextType];
                  }
                };
                _proto.destroyInternalLoaders = function destroyInternalLoaders() {
                  for (var contextType in this.loaders) {
                    var loader = this.loaders[contextType];
                    if (loader) {
                      loader.destroy();
                    }
                    this.resetInternalLoader(contextType);
                  }
                };
                _proto.destroy = function destroy() {
                  this.destroyInternalLoaders();
                  _EventHandler.prototype.destroy.call(this);
                };
                _proto.onManifestLoading = function onManifestLoading(data) {
                  this.load({
                    url: data.url,
                    type: PlaylistContextType.MANIFEST,
                    level: 0,
                    id: null,
                    responseType: "text"
                  });
                };
                _proto.onLevelLoading = function onLevelLoading(data) {
                  this.load({
                    url: data.url,
                    type: PlaylistContextType.LEVEL,
                    level: data.level,
                    id: data.id,
                    responseType: "text"
                  });
                };
                _proto.onAudioTrackLoading = function onAudioTrackLoading(data) {
                  this.load({
                    url: data.url,
                    type: PlaylistContextType.AUDIO_TRACK,
                    level: null,
                    id: data.id,
                    responseType: "text"
                  });
                };
                _proto.onSubtitleTrackLoading = function onSubtitleTrackLoading(data) {
                  this.load({
                    url: data.url,
                    type: PlaylistContextType.SUBTITLE_TRACK,
                    level: null,
                    id: data.id,
                    responseType: "text"
                  });
                };
                _proto.load = function load(context) {
                  var config = this.hls.config;
                  logger["logger"].debug("Loading playlist of type " + context.type + ", level: " + context.level + ", id: " + context.id);
                  var loader = this.getInternalLoader(context);
                  if (loader) {
                    var loaderContext = loader.context;
                    if (loaderContext && loaderContext.url === context.url) {
                      logger["logger"].trace("playlist request ongoing");
                      return false;
                    } else {
                      logger["logger"].warn("aborting previous loader for type: " + context.type);
                      loader.abort();
                    }
                  }
                  var maxRetry;
                  var timeout;
                  var retryDelay;
                  var maxRetryDelay;
                  switch (context.type) {
                    case PlaylistContextType.MANIFEST:
                      maxRetry = config.manifestLoadingMaxRetry;
                      timeout = config.manifestLoadingTimeOut;
                      retryDelay = config.manifestLoadingRetryDelay;
                      maxRetryDelay = config.manifestLoadingMaxRetryTimeout;
                      break;
                    case PlaylistContextType.LEVEL:
                      maxRetry = 0;
                      maxRetryDelay = 0;
                      retryDelay = 0;
                      timeout = config.levelLoadingTimeOut;
                      break;
                    default:
                      maxRetry = config.levelLoadingMaxRetry;
                      timeout = config.levelLoadingTimeOut;
                      retryDelay = config.levelLoadingRetryDelay;
                      maxRetryDelay = config.levelLoadingMaxRetryTimeout;
                      break;
                  }
                  loader = this.createInternalLoader(context);
                  var loaderConfig = {
                    timeout,
                    maxRetry,
                    retryDelay,
                    maxRetryDelay
                  };
                  var loaderCallbacks = {
                    onSuccess: this.loadsuccess.bind(this),
                    onError: this.loaderror.bind(this),
                    onTimeout: this.loadtimeout.bind(this)
                  };
                  logger["logger"].debug("Calling internal loader delegate for URL: " + context.url);
                  loader.load(context, loaderConfig, loaderCallbacks);
                  return true;
                };
                _proto.loadsuccess = function loadsuccess(response, stats, context, networkDetails) {
                  if (networkDetails === void 0) {
                    networkDetails = null;
                  }
                  if (context.isSidxRequest) {
                    this._handleSidxRequest(response, context);
                    this._handlePlaylistLoaded(response, stats, context, networkDetails);
                    return;
                  }
                  this.resetInternalLoader(context.type);
                  if (typeof response.data !== "string") {
                    throw new Error('expected responseType of "text" for PlaylistLoader');
                  }
                  var string = response.data;
                  stats.tload = performance.now();
                  if (string.indexOf("#EXTM3U") !== 0) {
                    this._handleManifestParsingError(response, context, "no EXTM3U delimiter", networkDetails);
                    return;
                  }
                  if (string.indexOf("#EXTINF:") > 0 || string.indexOf("#EXT-X-TARGETDURATION:") > 0) {
                    this._handleTrackOrLevelPlaylist(response, stats, context, networkDetails);
                  } else {
                    this._handleMasterPlaylist(response, stats, context, networkDetails);
                  }
                };
                _proto.loaderror = function loaderror(response, context, networkDetails) {
                  if (networkDetails === void 0) {
                    networkDetails = null;
                  }
                  this._handleNetworkError(context, networkDetails, false, response);
                };
                _proto.loadtimeout = function loadtimeout(stats, context, networkDetails) {
                  if (networkDetails === void 0) {
                    networkDetails = null;
                  }
                  this._handleNetworkError(context, networkDetails, true);
                };
                _proto._handleMasterPlaylist = function _handleMasterPlaylist(response, stats, context, networkDetails) {
                  var hls = this.hls;
                  var string = response.data;
                  var url = PlaylistLoader.getResponseUrl(response, context);
                  var _M3U8Parser$parseMast = m3u8_parser_M3U8Parser.parseMasterPlaylist(string, url), levels = _M3U8Parser$parseMast.levels, sessionData = _M3U8Parser$parseMast.sessionData;
                  if (!levels.length) {
                    this._handleManifestParsingError(response, context, "no level found in manifest", networkDetails);
                    return;
                  }
                  var audioGroups = levels.map(function(level) {
                    return {
                      id: level.attrs.AUDIO,
                      codec: level.audioCodec
                    };
                  });
                  var audioTracks = m3u8_parser_M3U8Parser.parseMasterPlaylistMedia(string, url, "AUDIO", audioGroups);
                  var subtitles = m3u8_parser_M3U8Parser.parseMasterPlaylistMedia(string, url, "SUBTITLES");
                  var captions = m3u8_parser_M3U8Parser.parseMasterPlaylistMedia(string, url, "CLOSED-CAPTIONS");
                  if (audioTracks.length) {
                    var embeddedAudioFound = false;
                    audioTracks.forEach(function(audioTrack) {
                      if (!audioTrack.url) {
                        embeddedAudioFound = true;
                      }
                    });
                    if (embeddedAudioFound === false && levels[0].audioCodec && !levels[0].attrs.AUDIO) {
                      logger["logger"].log("audio codec signaled in quality level, but no embedded audio track signaled, create one");
                      audioTracks.unshift({
                        type: "main",
                        name: "main",
                        default: false,
                        autoselect: false,
                        forced: false,
                        id: -1,
                        attrs: {},
                        url: ""
                      });
                    }
                  }
                  hls.trigger(events["default"].MANIFEST_LOADED, {
                    levels,
                    audioTracks,
                    subtitles,
                    captions,
                    url,
                    stats,
                    networkDetails,
                    sessionData
                  });
                };
                _proto._handleTrackOrLevelPlaylist = function _handleTrackOrLevelPlaylist(response, stats, context, networkDetails) {
                  var hls = this.hls;
                  var id = context.id, level = context.level, type = context.type;
                  var url = PlaylistLoader.getResponseUrl(response, context);
                  var levelUrlId = Object(number["isFiniteNumber"])(id) ? id : 0;
                  var levelId = Object(number["isFiniteNumber"])(level) ? level : levelUrlId;
                  var levelType = PlaylistLoader.mapContextToLevelType(context);
                  var levelDetails = m3u8_parser_M3U8Parser.parseLevelPlaylist(response.data, url, levelId, levelType, levelUrlId);
                  levelDetails.tload = stats.tload;
                  if (!levelDetails.fragments.length) {
                    hls.trigger(events["default"].ERROR, {
                      type: errors["ErrorTypes"].NETWORK_ERROR,
                      details: errors["ErrorDetails"].LEVEL_EMPTY_ERROR,
                      fatal: false,
                      url,
                      reason: "no fragments found in level",
                      level: typeof context.level === "number" ? context.level : void 0
                    });
                    return;
                  }
                  if (type === PlaylistContextType.MANIFEST) {
                    var singleLevel = {
                      url,
                      details: levelDetails
                    };
                    hls.trigger(events["default"].MANIFEST_LOADED, {
                      levels: [singleLevel],
                      audioTracks: [],
                      url,
                      stats,
                      networkDetails,
                      sessionData: null
                    });
                  }
                  stats.tparsed = performance.now();
                  if (levelDetails.needSidxRanges) {
                    var sidxUrl = levelDetails.initSegment.url;
                    this.load({
                      url: sidxUrl,
                      isSidxRequest: true,
                      type,
                      level,
                      levelDetails,
                      id,
                      rangeStart: 0,
                      rangeEnd: 2048,
                      responseType: "arraybuffer"
                    });
                    return;
                  }
                  context.levelDetails = levelDetails;
                  this._handlePlaylistLoaded(response, stats, context, networkDetails);
                };
                _proto._handleSidxRequest = function _handleSidxRequest(response, context) {
                  if (typeof response.data === "string") {
                    throw new Error("sidx request must be made with responseType of array buffer");
                  }
                  var sidxInfo = mp4demuxer["default"].parseSegmentIndex(new Uint8Array(response.data));
                  if (!sidxInfo) {
                    return;
                  }
                  var sidxReferences = sidxInfo.references;
                  var levelDetails = context.levelDetails;
                  sidxReferences.forEach(function(segmentRef, index) {
                    var segRefInfo = segmentRef.info;
                    if (!levelDetails) {
                      return;
                    }
                    var frag = levelDetails.fragments[index];
                    if (frag.byteRange.length === 0) {
                      frag.setByteRange(String(1 + segRefInfo.end - segRefInfo.start) + "@" + String(segRefInfo.start));
                    }
                  });
                  if (levelDetails) {
                    levelDetails.initSegment.setByteRange(String(sidxInfo.moovEndOffset) + "@0");
                  }
                };
                _proto._handleManifestParsingError = function _handleManifestParsingError(response, context, reason, networkDetails) {
                  this.hls.trigger(events["default"].ERROR, {
                    type: errors["ErrorTypes"].NETWORK_ERROR,
                    details: errors["ErrorDetails"].MANIFEST_PARSING_ERROR,
                    fatal: true,
                    url: response.url,
                    reason,
                    networkDetails
                  });
                };
                _proto._handleNetworkError = function _handleNetworkError(context, networkDetails, timeout, response) {
                  if (timeout === void 0) {
                    timeout = false;
                  }
                  if (response === void 0) {
                    response = null;
                  }
                  logger["logger"].info("A network error occured while loading a " + context.type + "-type playlist");
                  var details;
                  var fatal;
                  var loader = this.getInternalLoader(context);
                  switch (context.type) {
                    case PlaylistContextType.MANIFEST:
                      details = timeout ? errors["ErrorDetails"].MANIFEST_LOAD_TIMEOUT : errors["ErrorDetails"].MANIFEST_LOAD_ERROR;
                      fatal = true;
                      break;
                    case PlaylistContextType.LEVEL:
                      details = timeout ? errors["ErrorDetails"].LEVEL_LOAD_TIMEOUT : errors["ErrorDetails"].LEVEL_LOAD_ERROR;
                      fatal = false;
                      break;
                    case PlaylistContextType.AUDIO_TRACK:
                      details = timeout ? errors["ErrorDetails"].AUDIO_TRACK_LOAD_TIMEOUT : errors["ErrorDetails"].AUDIO_TRACK_LOAD_ERROR;
                      fatal = false;
                      break;
                    default:
                      fatal = false;
                  }
                  if (loader) {
                    loader.abort();
                    this.resetInternalLoader(context.type);
                  }
                  var errorData = {
                    type: errors["ErrorTypes"].NETWORK_ERROR,
                    details,
                    fatal,
                    url: context.url,
                    loader,
                    context,
                    networkDetails
                  };
                  if (response) {
                    errorData.response = response;
                  }
                  this.hls.trigger(events["default"].ERROR, errorData);
                };
                _proto._handlePlaylistLoaded = function _handlePlaylistLoaded(response, stats, context, networkDetails) {
                  var type = context.type, level = context.level, id = context.id, levelDetails = context.levelDetails;
                  if (!levelDetails || !levelDetails.targetduration) {
                    this._handleManifestParsingError(response, context, "invalid target duration", networkDetails);
                    return;
                  }
                  var canHaveLevels = PlaylistLoader.canHaveQualityLevels(context.type);
                  if (canHaveLevels) {
                    this.hls.trigger(events["default"].LEVEL_LOADED, {
                      details: levelDetails,
                      level: level || 0,
                      id: id || 0,
                      stats,
                      networkDetails
                    });
                  } else {
                    switch (type) {
                      case PlaylistContextType.AUDIO_TRACK:
                        this.hls.trigger(events["default"].AUDIO_TRACK_LOADED, {
                          details: levelDetails,
                          id,
                          stats,
                          networkDetails
                        });
                        break;
                      case PlaylistContextType.SUBTITLE_TRACK:
                        this.hls.trigger(events["default"].SUBTITLE_TRACK_LOADED, {
                          details: levelDetails,
                          id,
                          stats,
                          networkDetails
                        });
                        break;
                    }
                  }
                };
                return PlaylistLoader;
              }(event_handler);
              var playlist_loader = playlist_loader_PlaylistLoader;
              function fragment_loader_inheritsLoose(subClass, superClass) {
                subClass.prototype = Object.create(superClass.prototype);
                subClass.prototype.constructor = subClass;
                subClass.__proto__ = superClass;
              }
              var fragment_loader_FragmentLoader = function(_EventHandler) {
                fragment_loader_inheritsLoose(FragmentLoader, _EventHandler);
                function FragmentLoader(hls) {
                  var _this;
                  _this = _EventHandler.call(this, hls, events["default"].FRAG_LOADING) || this;
                  _this.loaders = {};
                  return _this;
                }
                var _proto = FragmentLoader.prototype;
                _proto.destroy = function destroy() {
                  var loaders = this.loaders;
                  for (var loaderName in loaders) {
                    var loader = loaders[loaderName];
                    if (loader) {
                      loader.destroy();
                    }
                  }
                  this.loaders = {};
                  _EventHandler.prototype.destroy.call(this);
                };
                _proto.onFragLoading = function onFragLoading(data) {
                  var frag = data.frag, type = frag.type, loaders = this.loaders, config = this.hls.config, FragmentILoader = config.fLoader, DefaultILoader = config.loader;
                  frag.loaded = 0;
                  var loader = loaders[type];
                  if (loader) {
                    logger["logger"].warn("abort previous fragment loader for type: " + type);
                    loader.abort();
                  }
                  loader = loaders[type] = frag.loader = config.fLoader ? new FragmentILoader(config) : new DefaultILoader(config);
                  var loaderContext, loaderConfig, loaderCallbacks;
                  loaderContext = {
                    url: frag.url,
                    frag,
                    responseType: "arraybuffer",
                    progressData: false
                  };
                  var start = frag.byteRangeStartOffset, end = frag.byteRangeEndOffset;
                  if (Object(number["isFiniteNumber"])(start) && Object(number["isFiniteNumber"])(end)) {
                    loaderContext.rangeStart = start;
                    loaderContext.rangeEnd = end;
                  }
                  loaderConfig = {
                    timeout: config.fragLoadingTimeOut,
                    maxRetry: 0,
                    retryDelay: 0,
                    maxRetryDelay: config.fragLoadingMaxRetryTimeout
                  };
                  loaderCallbacks = {
                    onSuccess: this.loadsuccess.bind(this),
                    onError: this.loaderror.bind(this),
                    onTimeout: this.loadtimeout.bind(this),
                    onProgress: this.loadprogress.bind(this)
                  };
                  loader.load(loaderContext, loaderConfig, loaderCallbacks);
                };
                _proto.loadsuccess = function loadsuccess(response, stats, context, networkDetails) {
                  if (networkDetails === void 0) {
                    networkDetails = null;
                  }
                  var payload = response.data, frag = context.frag;
                  frag.loader = void 0;
                  this.loaders[frag.type] = void 0;
                  this.hls.trigger(events["default"].FRAG_LOADED, {
                    payload,
                    frag,
                    stats,
                    networkDetails
                  });
                };
                _proto.loaderror = function loaderror(response, context, networkDetails) {
                  if (networkDetails === void 0) {
                    networkDetails = null;
                  }
                  var frag = context.frag;
                  var loader = frag.loader;
                  if (loader) {
                    loader.abort();
                  }
                  this.loaders[frag.type] = void 0;
                  this.hls.trigger(events["default"].ERROR, {
                    type: errors["ErrorTypes"].NETWORK_ERROR,
                    details: errors["ErrorDetails"].FRAG_LOAD_ERROR,
                    fatal: false,
                    frag: context.frag,
                    response,
                    networkDetails
                  });
                };
                _proto.loadtimeout = function loadtimeout(stats, context, networkDetails) {
                  if (networkDetails === void 0) {
                    networkDetails = null;
                  }
                  var frag = context.frag;
                  var loader = frag.loader;
                  if (loader) {
                    loader.abort();
                  }
                  this.loaders[frag.type] = void 0;
                  this.hls.trigger(events["default"].ERROR, {
                    type: errors["ErrorTypes"].NETWORK_ERROR,
                    details: errors["ErrorDetails"].FRAG_LOAD_TIMEOUT,
                    fatal: false,
                    frag: context.frag,
                    networkDetails
                  });
                };
                _proto.loadprogress = function loadprogress(stats, context, data, networkDetails) {
                  if (networkDetails === void 0) {
                    networkDetails = null;
                  }
                  var frag = context.frag;
                  frag.loaded = stats.loaded;
                  this.hls.trigger(events["default"].FRAG_LOAD_PROGRESS, {
                    frag,
                    stats,
                    networkDetails
                  });
                };
                return FragmentLoader;
              }(event_handler);
              var fragment_loader = fragment_loader_FragmentLoader;
              function key_loader_inheritsLoose(subClass, superClass) {
                subClass.prototype = Object.create(superClass.prototype);
                subClass.prototype.constructor = subClass;
                subClass.__proto__ = superClass;
              }
              var key_loader_KeyLoader = function(_EventHandler) {
                key_loader_inheritsLoose(KeyLoader, _EventHandler);
                function KeyLoader(hls) {
                  var _this;
                  _this = _EventHandler.call(this, hls, events["default"].KEY_LOADING) || this;
                  _this.loaders = {};
                  _this.decryptkey = null;
                  _this.decrypturl = null;
                  return _this;
                }
                var _proto = KeyLoader.prototype;
                _proto.destroy = function destroy() {
                  for (var loaderName in this.loaders) {
                    var loader = this.loaders[loaderName];
                    if (loader) {
                      loader.destroy();
                    }
                  }
                  this.loaders = {};
                  _EventHandler.prototype.destroy.call(this);
                };
                _proto.onKeyLoading = function onKeyLoading(data) {
                  var frag = data.frag;
                  var type = frag.type;
                  var loader = this.loaders[type];
                  if (!frag.decryptdata) {
                    logger["logger"].warn("Missing decryption data on fragment in onKeyLoading");
                    return;
                  }
                  var uri = frag.decryptdata.uri;
                  if (uri !== this.decrypturl || this.decryptkey === null) {
                    var config = this.hls.config;
                    if (loader) {
                      logger["logger"].warn("abort previous key loader for type:" + type);
                      loader.abort();
                    }
                    if (!uri) {
                      logger["logger"].warn("key uri is falsy");
                      return;
                    }
                    frag.loader = this.loaders[type] = new config.loader(config);
                    this.decrypturl = uri;
                    this.decryptkey = null;
                    var loaderContext = {
                      url: uri,
                      frag,
                      responseType: "arraybuffer"
                    };
                    var loaderConfig = {
                      timeout: config.fragLoadingTimeOut,
                      maxRetry: 0,
                      retryDelay: config.fragLoadingRetryDelay,
                      maxRetryDelay: config.fragLoadingMaxRetryTimeout
                    };
                    var loaderCallbacks = {
                      onSuccess: this.loadsuccess.bind(this),
                      onError: this.loaderror.bind(this),
                      onTimeout: this.loadtimeout.bind(this)
                    };
                    frag.loader.load(loaderContext, loaderConfig, loaderCallbacks);
                  } else if (this.decryptkey) {
                    frag.decryptdata.key = this.decryptkey;
                    this.hls.trigger(events["default"].KEY_LOADED, {
                      frag
                    });
                  }
                };
                _proto.loadsuccess = function loadsuccess(response, stats, context) {
                  var frag = context.frag;
                  if (!frag.decryptdata) {
                    logger["logger"].error("after key load, decryptdata unset");
                    return;
                  }
                  this.decryptkey = frag.decryptdata.key = new Uint8Array(response.data);
                  frag.loader = void 0;
                  delete this.loaders[frag.type];
                  this.hls.trigger(events["default"].KEY_LOADED, {
                    frag
                  });
                };
                _proto.loaderror = function loaderror(response, context) {
                  var frag = context.frag;
                  var loader = frag.loader;
                  if (loader) {
                    loader.abort();
                  }
                  delete this.loaders[frag.type];
                  this.hls.trigger(events["default"].ERROR, {
                    type: errors["ErrorTypes"].NETWORK_ERROR,
                    details: errors["ErrorDetails"].KEY_LOAD_ERROR,
                    fatal: false,
                    frag,
                    response
                  });
                };
                _proto.loadtimeout = function loadtimeout(stats, context) {
                  var frag = context.frag;
                  var loader = frag.loader;
                  if (loader) {
                    loader.abort();
                  }
                  delete this.loaders[frag.type];
                  this.hls.trigger(events["default"].ERROR, {
                    type: errors["ErrorTypes"].NETWORK_ERROR,
                    details: errors["ErrorDetails"].KEY_LOAD_TIMEOUT,
                    fatal: false,
                    frag
                  });
                };
                return KeyLoader;
              }(event_handler);
              var key_loader = key_loader_KeyLoader;
              function fragment_tracker_inheritsLoose(subClass, superClass) {
                subClass.prototype = Object.create(superClass.prototype);
                subClass.prototype.constructor = subClass;
                subClass.__proto__ = superClass;
              }
              var FragmentState = {
                NOT_LOADED: "NOT_LOADED",
                APPENDING: "APPENDING",
                PARTIAL: "PARTIAL",
                OK: "OK"
              };
              var fragment_tracker_FragmentTracker = function(_EventHandler) {
                fragment_tracker_inheritsLoose(FragmentTracker, _EventHandler);
                function FragmentTracker(hls) {
                  var _this;
                  _this = _EventHandler.call(this, hls, events["default"].BUFFER_APPENDED, events["default"].FRAG_BUFFERED, events["default"].FRAG_LOADED) || this;
                  _this.bufferPadding = 0.2;
                  _this.fragments = /* @__PURE__ */ Object.create(null);
                  _this.timeRanges = /* @__PURE__ */ Object.create(null);
                  _this.config = hls.config;
                  return _this;
                }
                var _proto = FragmentTracker.prototype;
                _proto.destroy = function destroy() {
                  this.fragments = /* @__PURE__ */ Object.create(null);
                  this.timeRanges = /* @__PURE__ */ Object.create(null);
                  this.config = null;
                  event_handler.prototype.destroy.call(this);
                  _EventHandler.prototype.destroy.call(this);
                };
                _proto.getBufferedFrag = function getBufferedFrag(position, levelType) {
                  var fragments = this.fragments;
                  var bufferedFrags = Object.keys(fragments).filter(function(key) {
                    var fragmentEntity = fragments[key];
                    if (fragmentEntity.body.type !== levelType) {
                      return false;
                    }
                    if (!fragmentEntity.buffered) {
                      return false;
                    }
                    var frag = fragmentEntity.body;
                    return frag.startPTS <= position && position <= frag.endPTS;
                  });
                  if (bufferedFrags.length === 0) {
                    return null;
                  } else {
                    var bufferedFragKey = bufferedFrags.pop();
                    return fragments[bufferedFragKey].body;
                  }
                };
                _proto.detectEvictedFragments = function detectEvictedFragments(elementaryStream, timeRange) {
                  var _this2 = this;
                  Object.keys(this.fragments).forEach(function(key) {
                    var fragmentEntity = _this2.fragments[key];
                    if (!fragmentEntity || !fragmentEntity.buffered) {
                      return;
                    }
                    var esData = fragmentEntity.range[elementaryStream];
                    if (!esData) {
                      return;
                    }
                    var fragmentTimes = esData.time;
                    for (var i = 0; i < fragmentTimes.length; i++) {
                      var time = fragmentTimes[i];
                      if (!_this2.isTimeBuffered(time.startPTS, time.endPTS, timeRange)) {
                        _this2.removeFragment(fragmentEntity.body);
                        break;
                      }
                    }
                  });
                };
                _proto.detectPartialFragments = function detectPartialFragments(fragment) {
                  var _this3 = this;
                  var fragKey = this.getFragmentKey(fragment);
                  var fragmentEntity = this.fragments[fragKey];
                  if (fragmentEntity) {
                    fragmentEntity.buffered = true;
                    Object.keys(this.timeRanges).forEach(function(elementaryStream) {
                      if (fragment.hasElementaryStream(elementaryStream)) {
                        var timeRange = _this3.timeRanges[elementaryStream];
                        fragmentEntity.range[elementaryStream] = _this3.getBufferedTimes(fragment.startPTS, fragment.endPTS, timeRange);
                      }
                    });
                  }
                };
                _proto.getBufferedTimes = function getBufferedTimes(startPTS, endPTS, timeRange) {
                  var fragmentTimes = [];
                  var startTime, endTime;
                  var fragmentPartial = false;
                  for (var i = 0; i < timeRange.length; i++) {
                    startTime = timeRange.start(i) - this.bufferPadding;
                    endTime = timeRange.end(i) + this.bufferPadding;
                    if (startPTS >= startTime && endPTS <= endTime) {
                      fragmentTimes.push({
                        startPTS: Math.max(startPTS, timeRange.start(i)),
                        endPTS: Math.min(endPTS, timeRange.end(i))
                      });
                      break;
                    } else if (startPTS < endTime && endPTS > startTime) {
                      fragmentTimes.push({
                        startPTS: Math.max(startPTS, timeRange.start(i)),
                        endPTS: Math.min(endPTS, timeRange.end(i))
                      });
                      fragmentPartial = true;
                    } else if (endPTS <= startTime) {
                      break;
                    }
                  }
                  return {
                    time: fragmentTimes,
                    partial: fragmentPartial
                  };
                };
                _proto.getFragmentKey = function getFragmentKey(fragment) {
                  return fragment.type + "_" + fragment.level + "_" + fragment.urlId + "_" + fragment.sn;
                };
                _proto.getPartialFragment = function getPartialFragment(time) {
                  var _this4 = this;
                  var timePadding, startTime, endTime;
                  var bestFragment = null;
                  var bestOverlap = 0;
                  Object.keys(this.fragments).forEach(function(key) {
                    var fragmentEntity = _this4.fragments[key];
                    if (_this4.isPartial(fragmentEntity)) {
                      startTime = fragmentEntity.body.startPTS - _this4.bufferPadding;
                      endTime = fragmentEntity.body.endPTS + _this4.bufferPadding;
                      if (time >= startTime && time <= endTime) {
                        timePadding = Math.min(time - startTime, endTime - time);
                        if (bestOverlap <= timePadding) {
                          bestFragment = fragmentEntity.body;
                          bestOverlap = timePadding;
                        }
                      }
                    }
                  });
                  return bestFragment;
                };
                _proto.getState = function getState(fragment) {
                  var fragKey = this.getFragmentKey(fragment);
                  var fragmentEntity = this.fragments[fragKey];
                  var state = FragmentState.NOT_LOADED;
                  if (fragmentEntity !== void 0) {
                    if (!fragmentEntity.buffered) {
                      state = FragmentState.APPENDING;
                    } else if (this.isPartial(fragmentEntity) === true) {
                      state = FragmentState.PARTIAL;
                    } else {
                      state = FragmentState.OK;
                    }
                  }
                  return state;
                };
                _proto.isPartial = function isPartial(fragmentEntity) {
                  return fragmentEntity.buffered === true && (fragmentEntity.range.video !== void 0 && fragmentEntity.range.video.partial === true || fragmentEntity.range.audio !== void 0 && fragmentEntity.range.audio.partial === true);
                };
                _proto.isTimeBuffered = function isTimeBuffered(startPTS, endPTS, timeRange) {
                  var startTime, endTime;
                  for (var i = 0; i < timeRange.length; i++) {
                    startTime = timeRange.start(i) - this.bufferPadding;
                    endTime = timeRange.end(i) + this.bufferPadding;
                    if (startPTS >= startTime && endPTS <= endTime) {
                      return true;
                    }
                    if (endPTS <= startTime) {
                      return false;
                    }
                  }
                  return false;
                };
                _proto.onFragLoaded = function onFragLoaded(e) {
                  var fragment = e.frag;
                  if (!Object(number["isFiniteNumber"])(fragment.sn) || fragment.bitrateTest) {
                    return;
                  }
                  this.fragments[this.getFragmentKey(fragment)] = {
                    body: fragment,
                    range: /* @__PURE__ */ Object.create(null),
                    buffered: false
                  };
                };
                _proto.onBufferAppended = function onBufferAppended(e) {
                  var _this5 = this;
                  this.timeRanges = e.timeRanges;
                  Object.keys(this.timeRanges).forEach(function(elementaryStream) {
                    var timeRange = _this5.timeRanges[elementaryStream];
                    _this5.detectEvictedFragments(elementaryStream, timeRange);
                  });
                };
                _proto.onFragBuffered = function onFragBuffered(e) {
                  this.detectPartialFragments(e.frag);
                };
                _proto.hasFragment = function hasFragment(fragment) {
                  var fragKey = this.getFragmentKey(fragment);
                  return this.fragments[fragKey] !== void 0;
                };
                _proto.removeFragment = function removeFragment(fragment) {
                  var fragKey = this.getFragmentKey(fragment);
                  delete this.fragments[fragKey];
                };
                _proto.removeAllFragments = function removeAllFragments() {
                  this.fragments = /* @__PURE__ */ Object.create(null);
                };
                return FragmentTracker;
              }(event_handler);
              var BinarySearch = {
                /**
                 * Searches for an item in an array which matches a certain condition.
                 * This requires the condition to only match one item in the array,
                 * and for the array to be ordered.
                 *
                 * @param {Array<T>} list The array to search.
                 * @param {BinarySearchComparison<T>} comparisonFn
                 *      Called and provided a candidate item as the first argument.
                 *      Should return:
                 *          > -1 if the item should be located at a lower index than the provided item.
                 *          > 1 if the item should be located at a higher index than the provided item.
                 *          > 0 if the item is the item you're looking for.
                 *
                 * @return {T | null} The object if it is found or null otherwise.
                 */
                search: function search(list, comparisonFn) {
                  var minIndex = 0;
                  var maxIndex = list.length - 1;
                  var currentIndex = null;
                  var currentElement = null;
                  while (minIndex <= maxIndex) {
                    currentIndex = (minIndex + maxIndex) / 2 | 0;
                    currentElement = list[currentIndex];
                    var comparisonResult = comparisonFn(currentElement);
                    if (comparisonResult > 0) {
                      minIndex = currentIndex + 1;
                    } else if (comparisonResult < 0) {
                      maxIndex = currentIndex - 1;
                    } else {
                      return currentElement;
                    }
                  }
                  return null;
                }
              };
              var binary_search = BinarySearch;
              var BufferHelper = function() {
                function BufferHelper2() {
                }
                BufferHelper2.isBuffered = function isBuffered(media, position) {
                  try {
                    if (media) {
                      var buffered = media.buffered;
                      for (var i = 0; i < buffered.length; i++) {
                        if (position >= buffered.start(i) && position <= buffered.end(i)) {
                          return true;
                        }
                      }
                    }
                  } catch (error) {
                  }
                  return false;
                };
                BufferHelper2.bufferInfo = function bufferInfo(media, pos, maxHoleDuration) {
                  try {
                    if (media) {
                      var vbuffered = media.buffered;
                      var buffered = [];
                      var i;
                      for (i = 0; i < vbuffered.length; i++) {
                        buffered.push({
                          start: vbuffered.start(i),
                          end: vbuffered.end(i)
                        });
                      }
                      return this.bufferedInfo(buffered, pos, maxHoleDuration);
                    }
                  } catch (error) {
                  }
                  return {
                    len: 0,
                    start: pos,
                    end: pos,
                    nextStart: void 0
                  };
                };
                BufferHelper2.bufferedInfo = function bufferedInfo(buffered, pos, maxHoleDuration) {
                  buffered.sort(function(a, b) {
                    var diff = a.start - b.start;
                    if (diff) {
                      return diff;
                    } else {
                      return b.end - a.end;
                    }
                  });
                  var buffered2 = [];
                  if (maxHoleDuration) {
                    for (var i = 0; i < buffered.length; i++) {
                      var buf2len = buffered2.length;
                      if (buf2len) {
                        var buf2end = buffered2[buf2len - 1].end;
                        if (buffered[i].start - buf2end < maxHoleDuration) {
                          if (buffered[i].end > buf2end) {
                            buffered2[buf2len - 1].end = buffered[i].end;
                          }
                        } else {
                          buffered2.push(buffered[i]);
                        }
                      } else {
                        buffered2.push(buffered[i]);
                      }
                    }
                  } else {
                    buffered2 = buffered;
                  }
                  var bufferLen = 0;
                  var bufferStartNext;
                  var bufferStart = pos;
                  var bufferEnd = pos;
                  for (var _i = 0; _i < buffered2.length; _i++) {
                    var start = buffered2[_i].start, end = buffered2[_i].end;
                    if (pos + maxHoleDuration >= start && pos < end) {
                      bufferStart = start;
                      bufferEnd = end;
                      bufferLen = bufferEnd - pos;
                    } else if (pos + maxHoleDuration < start) {
                      bufferStartNext = start;
                      break;
                    }
                  }
                  return {
                    len: bufferLen,
                    start: bufferStart,
                    end: bufferEnd,
                    nextStart: bufferStartNext
                  };
                };
                return BufferHelper2;
              }();
              var eventemitter3 = __webpack_require__("./node_modules/eventemitter3/index.js");
              var webworkify_webpack = __webpack_require__("./node_modules/webworkify-webpack/index.js");
              var demuxer_inline = __webpack_require__("./src/demux/demuxer-inline.js");
              function getMediaSource() {
                return window.MediaSource || window.WebKitMediaSource;
              }
              var get_self_scope = __webpack_require__("./src/utils/get-self-scope.js");
              function observer_inheritsLoose(subClass, superClass) {
                subClass.prototype = Object.create(superClass.prototype);
                subClass.prototype.constructor = subClass;
                subClass.__proto__ = superClass;
              }
              var Observer = function(_EventEmitter) {
                observer_inheritsLoose(Observer2, _EventEmitter);
                function Observer2() {
                  return _EventEmitter.apply(this, arguments) || this;
                }
                var _proto = Observer2.prototype;
                _proto.trigger = function trigger(event) {
                  for (var _len = arguments.length, data = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
                    data[_key - 1] = arguments[_key];
                  }
                  this.emit.apply(this, [event, event].concat(data));
                };
                return Observer2;
              }(eventemitter3["EventEmitter"]);
              var global = Object(get_self_scope["getSelfScope"])();
              var demuxer_MediaSource = getMediaSource() || {
                isTypeSupported: function isTypeSupported() {
                  return false;
                }
              };
              var demuxer_Demuxer = function() {
                function Demuxer(hls, id) {
                  var _this = this;
                  this.hls = hls;
                  this.id = id;
                  var observer = this.observer = new Observer();
                  var config = hls.config;
                  var forwardMessage = function forwardMessage2(ev, data) {
                    data = data || {};
                    data.frag = _this.frag;
                    data.id = _this.id;
                    hls.trigger(ev, data);
                  };
                  observer.on(events["default"].FRAG_DECRYPTED, forwardMessage);
                  observer.on(events["default"].FRAG_PARSING_INIT_SEGMENT, forwardMessage);
                  observer.on(events["default"].FRAG_PARSING_DATA, forwardMessage);
                  observer.on(events["default"].FRAG_PARSED, forwardMessage);
                  observer.on(events["default"].ERROR, forwardMessage);
                  observer.on(events["default"].FRAG_PARSING_METADATA, forwardMessage);
                  observer.on(events["default"].FRAG_PARSING_USERDATA, forwardMessage);
                  observer.on(events["default"].INIT_PTS_FOUND, forwardMessage);
                  var typeSupported = {
                    mp4: demuxer_MediaSource.isTypeSupported("video/mp4"),
                    mpeg: demuxer_MediaSource.isTypeSupported("audio/mpeg"),
                    mp3: demuxer_MediaSource.isTypeSupported('audio/mp4; codecs="mp3"')
                  };
                  var vendor = navigator.vendor;
                  if (config.enableWorker && typeof Worker !== "undefined") {
                    logger["logger"].log("demuxing in webworker");
                    var w;
                    try {
                      w = this.w = webworkify_webpack(
                        /*require.resolve*/
                        /*! ../demux/demuxer-worker.js */
                        "./src/demux/demuxer-worker.js"
                      );
                      this.onwmsg = this.onWorkerMessage.bind(this);
                      w.addEventListener("message", this.onwmsg);
                      w.onerror = function(event) {
                        hls.trigger(events["default"].ERROR, {
                          type: errors["ErrorTypes"].OTHER_ERROR,
                          details: errors["ErrorDetails"].INTERNAL_EXCEPTION,
                          fatal: true,
                          event: "demuxerWorker",
                          err: {
                            message: event.message + " (" + event.filename + ":" + event.lineno + ")"
                          }
                        });
                      };
                      w.postMessage({
                        cmd: "init",
                        typeSupported,
                        vendor,
                        id,
                        config: JSON.stringify(config)
                      });
                    } catch (err) {
                      logger["logger"].warn("Error in worker:", err);
                      logger["logger"].error("Error while initializing DemuxerWorker, fallback on DemuxerInline");
                      if (w) {
                        global.URL.revokeObjectURL(w.objectURL);
                      }
                      this.demuxer = new demuxer_inline["default"](observer, typeSupported, config, vendor);
                      this.w = void 0;
                    }
                  } else {
                    this.demuxer = new demuxer_inline["default"](observer, typeSupported, config, vendor);
                  }
                }
                var _proto = Demuxer.prototype;
                _proto.destroy = function destroy() {
                  var w = this.w;
                  if (w) {
                    w.removeEventListener("message", this.onwmsg);
                    w.terminate();
                    this.w = null;
                  } else {
                    var demuxer = this.demuxer;
                    if (demuxer) {
                      demuxer.destroy();
                      this.demuxer = null;
                    }
                  }
                  var observer = this.observer;
                  if (observer) {
                    observer.removeAllListeners();
                    this.observer = null;
                  }
                };
                _proto.push = function push(data, initSegment, audioCodec, videoCodec, frag, duration, accurateTimeOffset, defaultInitPTS) {
                  var w = this.w;
                  var timeOffset = Object(number["isFiniteNumber"])(frag.startPTS) ? frag.startPTS : frag.start;
                  var decryptdata = frag.decryptdata;
                  var lastFrag = this.frag;
                  var discontinuity = !(lastFrag && frag.cc === lastFrag.cc);
                  var trackSwitch = !(lastFrag && frag.level === lastFrag.level);
                  var nextSN = lastFrag && frag.sn === lastFrag.sn + 1;
                  var contiguous = !trackSwitch && nextSN;
                  if (discontinuity) {
                    logger["logger"].log(this.id + ":discontinuity detected");
                  }
                  if (trackSwitch) {
                    logger["logger"].log(this.id + ":switch detected");
                  }
                  this.frag = frag;
                  if (w) {
                    w.postMessage({
                      cmd: "demux",
                      data,
                      decryptdata,
                      initSegment,
                      audioCodec,
                      videoCodec,
                      timeOffset,
                      discontinuity,
                      trackSwitch,
                      contiguous,
                      duration,
                      accurateTimeOffset,
                      defaultInitPTS
                    }, data instanceof ArrayBuffer ? [data] : []);
                  } else {
                    var demuxer = this.demuxer;
                    if (demuxer) {
                      demuxer.push(data, decryptdata, initSegment, audioCodec, videoCodec, timeOffset, discontinuity, trackSwitch, contiguous, duration, accurateTimeOffset, defaultInitPTS);
                    }
                  }
                };
                _proto.onWorkerMessage = function onWorkerMessage(ev) {
                  var data = ev.data, hls = this.hls;
                  switch (data.event) {
                    case "init":
                      global.URL.revokeObjectURL(this.w.objectURL);
                      break;
                    case events["default"].FRAG_PARSING_DATA:
                      data.data.data1 = new Uint8Array(data.data1);
                      if (data.data2) {
                        data.data.data2 = new Uint8Array(data.data2);
                      }
                    default:
                      data.data = data.data || {};
                      data.data.frag = this.frag;
                      data.data.id = this.id;
                      hls.trigger(data.event, data.data);
                      break;
                  }
                };
                return Demuxer;
              }();
              var demux_demuxer = demuxer_Demuxer;
              function addGroupId(level, type, id) {
                switch (type) {
                  case "audio":
                    if (!level.audioGroupIds) {
                      level.audioGroupIds = [];
                    }
                    level.audioGroupIds.push(id);
                    break;
                  case "text":
                    if (!level.textGroupIds) {
                      level.textGroupIds = [];
                    }
                    level.textGroupIds.push(id);
                    break;
                }
              }
              function updatePTS(fragments, fromIdx, toIdx) {
                var fragFrom = fragments[fromIdx], fragTo = fragments[toIdx], fragToPTS = fragTo.startPTS;
                if (Object(number["isFiniteNumber"])(fragToPTS)) {
                  if (toIdx > fromIdx) {
                    fragFrom.duration = fragToPTS - fragFrom.start;
                    if (fragFrom.duration < 0) {
                      logger["logger"].warn("negative duration computed for frag " + fragFrom.sn + ",level " + fragFrom.level + ", there should be some duration drift between playlist and fragment!");
                    }
                  } else {
                    fragTo.duration = fragFrom.start - fragToPTS;
                    if (fragTo.duration < 0) {
                      logger["logger"].warn("negative duration computed for frag " + fragTo.sn + ",level " + fragTo.level + ", there should be some duration drift between playlist and fragment!");
                    }
                  }
                } else {
                  if (toIdx > fromIdx) {
                    var contiguous = fragFrom.cc === fragTo.cc;
                    fragTo.start = fragFrom.start + (contiguous && fragFrom.minEndPTS ? fragFrom.minEndPTS - fragFrom.start : fragFrom.duration);
                  } else {
                    fragTo.start = Math.max(fragFrom.start - fragTo.duration, 0);
                  }
                }
              }
              function updateFragPTSDTS(details, frag, startPTS, endPTS, startDTS, endDTS) {
                var maxStartPTS = startPTS;
                var minEndPTS = endPTS;
                if (Object(number["isFiniteNumber"])(frag.startPTS)) {
                  var deltaPTS = Math.abs(frag.startPTS - startPTS);
                  if (!Object(number["isFiniteNumber"])(frag.deltaPTS)) {
                    frag.deltaPTS = deltaPTS;
                  } else {
                    frag.deltaPTS = Math.max(deltaPTS, frag.deltaPTS);
                  }
                  maxStartPTS = Math.max(startPTS, frag.startPTS);
                  startPTS = Math.min(startPTS, frag.startPTS);
                  minEndPTS = Math.min(endPTS, frag.endPTS);
                  endPTS = Math.max(endPTS, frag.endPTS);
                  startDTS = Math.min(startDTS, frag.startDTS);
                  endDTS = Math.max(endDTS, frag.endDTS);
                }
                var drift = startPTS - frag.start;
                frag.start = frag.startPTS = startPTS;
                frag.maxStartPTS = maxStartPTS;
                frag.endPTS = endPTS;
                frag.minEndPTS = minEndPTS;
                frag.startDTS = startDTS;
                frag.endDTS = endDTS;
                frag.duration = endPTS - startPTS;
                var sn = frag.sn;
                if (!details || sn < details.startSN || sn > details.endSN) {
                  return 0;
                }
                var fragIdx, fragments, i;
                fragIdx = sn - details.startSN;
                fragments = details.fragments;
                fragments[fragIdx] = frag;
                for (i = fragIdx; i > 0; i--) {
                  updatePTS(fragments, i, i - 1);
                }
                for (i = fragIdx; i < fragments.length - 1; i++) {
                  updatePTS(fragments, i, i + 1);
                }
                details.PTSKnown = true;
                return drift;
              }
              function mergeDetails(oldDetails, newDetails) {
                if (newDetails.initSegment && oldDetails.initSegment) {
                  newDetails.initSegment = oldDetails.initSegment;
                }
                var ccOffset = 0;
                var PTSFrag;
                mapFragmentIntersection(oldDetails, newDetails, function(oldFrag, newFrag) {
                  ccOffset = oldFrag.cc - newFrag.cc;
                  if (Object(number["isFiniteNumber"])(oldFrag.startPTS)) {
                    newFrag.start = newFrag.startPTS = oldFrag.startPTS;
                    newFrag.endPTS = oldFrag.endPTS;
                    newFrag.duration = oldFrag.duration;
                    newFrag.backtracked = oldFrag.backtracked;
                    newFrag.dropped = oldFrag.dropped;
                    PTSFrag = newFrag;
                  }
                  newDetails.PTSKnown = true;
                });
                if (!newDetails.PTSKnown) {
                  return;
                }
                if (ccOffset) {
                  logger["logger"].log("discontinuity sliding from playlist, take drift into account");
                  var newFragments = newDetails.fragments;
                  for (var i = 0; i < newFragments.length; i++) {
                    newFragments[i].cc += ccOffset;
                  }
                }
                if (PTSFrag) {
                  updateFragPTSDTS(newDetails, PTSFrag, PTSFrag.startPTS, PTSFrag.endPTS, PTSFrag.startDTS, PTSFrag.endDTS);
                } else {
                  adjustSliding(oldDetails, newDetails);
                }
                newDetails.PTSKnown = oldDetails.PTSKnown;
              }
              function mergeSubtitlePlaylists(oldPlaylist, newPlaylist, referenceStart) {
                if (referenceStart === void 0) {
                  referenceStart = 0;
                }
                var lastIndex = -1;
                mapFragmentIntersection(oldPlaylist, newPlaylist, function(oldFrag, newFrag, index) {
                  newFrag.start = oldFrag.start;
                  lastIndex = index;
                });
                var frags = newPlaylist.fragments;
                if (lastIndex < 0) {
                  frags.forEach(function(frag) {
                    frag.start += referenceStart;
                  });
                  return;
                }
                for (var i = lastIndex + 1; i < frags.length; i++) {
                  frags[i].start = frags[i - 1].start + frags[i - 1].duration;
                }
              }
              function mapFragmentIntersection(oldPlaylist, newPlaylist, intersectionFn) {
                if (!oldPlaylist || !newPlaylist) {
                  return;
                }
                var start = Math.max(oldPlaylist.startSN, newPlaylist.startSN) - newPlaylist.startSN;
                var end = Math.min(oldPlaylist.endSN, newPlaylist.endSN) - newPlaylist.startSN;
                var delta = newPlaylist.startSN - oldPlaylist.startSN;
                for (var i = start; i <= end; i++) {
                  var oldFrag = oldPlaylist.fragments[delta + i];
                  var newFrag = newPlaylist.fragments[i];
                  if (!oldFrag || !newFrag) {
                    break;
                  }
                  intersectionFn(oldFrag, newFrag, i);
                }
              }
              function adjustSliding(oldPlaylist, newPlaylist) {
                var delta = newPlaylist.startSN - oldPlaylist.startSN;
                var oldFragments = oldPlaylist.fragments;
                var newFragments = newPlaylist.fragments;
                if (delta < 0 || delta > oldFragments.length) {
                  return;
                }
                for (var i = 0; i < newFragments.length; i++) {
                  newFragments[i].start += oldFragments[delta].start;
                }
              }
              function computeReloadInterval(currentPlaylist, newPlaylist, lastRequestTime) {
                var reloadInterval = 1e3 * (newPlaylist.averagetargetduration ? newPlaylist.averagetargetduration : newPlaylist.targetduration);
                var minReloadInterval = reloadInterval / 2;
                if (currentPlaylist && newPlaylist.endSN === currentPlaylist.endSN) {
                  reloadInterval = minReloadInterval;
                }
                if (lastRequestTime) {
                  reloadInterval = Math.max(minReloadInterval, reloadInterval - (window.performance.now() - lastRequestTime));
                }
                return Math.round(reloadInterval);
              }
              var TimeRanges = {
                toString: function toString(r) {
                  var log = "";
                  var len = r.length;
                  for (var i = 0; i < len; i++) {
                    log += "[" + r.start(i).toFixed(3) + "," + r.end(i).toFixed(3) + "]";
                  }
                  return log;
                }
              };
              var time_ranges = TimeRanges;
              function findFirstFragWithCC(fragments, cc) {
                var firstFrag = null;
                for (var i = 0; i < fragments.length; i += 1) {
                  var currentFrag = fragments[i];
                  if (currentFrag && currentFrag.cc === cc) {
                    firstFrag = currentFrag;
                    break;
                  }
                }
                return firstFrag;
              }
              function findFragWithCC(fragments, CC) {
                return binary_search.search(fragments, function(candidate) {
                  if (candidate.cc < CC) {
                    return 1;
                  } else if (candidate.cc > CC) {
                    return -1;
                  } else {
                    return 0;
                  }
                });
              }
              function shouldAlignOnDiscontinuities(lastFrag, lastLevel, details) {
                var shouldAlign = false;
                if (lastLevel && lastLevel.details && details) {
                  if (details.endCC > details.startCC || lastFrag && lastFrag.cc < details.startCC) {
                    shouldAlign = true;
                  }
                }
                return shouldAlign;
              }
              function findDiscontinuousReferenceFrag(prevDetails, curDetails) {
                var prevFrags = prevDetails.fragments;
                var curFrags = curDetails.fragments;
                if (!curFrags.length || !prevFrags.length) {
                  logger["logger"].log("No fragments to align");
                  return;
                }
                var prevStartFrag = findFirstFragWithCC(prevFrags, curFrags[0].cc);
                if (!prevStartFrag || prevStartFrag && !prevStartFrag.startPTS) {
                  logger["logger"].log("No frag in previous level to align on");
                  return;
                }
                return prevStartFrag;
              }
              function adjustPts(sliding, details) {
                details.fragments.forEach(function(frag) {
                  if (frag) {
                    var start = frag.start + sliding;
                    frag.start = frag.startPTS = start;
                    frag.endPTS = start + frag.duration;
                  }
                });
                details.PTSKnown = true;
              }
              function alignStream(lastFrag, lastLevel, details) {
                alignDiscontinuities(lastFrag, details, lastLevel);
                if (!details.PTSKnown && lastLevel) {
                  alignPDT(details, lastLevel.details);
                }
              }
              function alignDiscontinuities(lastFrag, details, lastLevel) {
                if (shouldAlignOnDiscontinuities(lastFrag, lastLevel, details)) {
                  var referenceFrag = findDiscontinuousReferenceFrag(lastLevel.details, details);
                  if (referenceFrag) {
                    logger["logger"].log("Adjusting PTS using last level due to CC increase within current level");
                    adjustPts(referenceFrag.start, details);
                  }
                }
              }
              function alignPDT(details, lastDetails) {
                if (lastDetails && lastDetails.fragments.length) {
                  if (!details.hasProgramDateTime || !lastDetails.hasProgramDateTime) {
                    return;
                  }
                  var lastPDT = lastDetails.fragments[0].programDateTime;
                  var newPDT = details.fragments[0].programDateTime;
                  var sliding = (newPDT - lastPDT) / 1e3 + lastDetails.fragments[0].start;
                  if (Object(number["isFiniteNumber"])(sliding)) {
                    logger["logger"].log("adjusting PTS using programDateTime delta, sliding:" + sliding.toFixed(3));
                    adjustPts(sliding, details);
                  }
                }
              }
              function findFragmentByPDT(fragments, PDTValue, maxFragLookUpTolerance) {
                if (PDTValue === null || !Array.isArray(fragments) || !fragments.length || !Object(number["isFiniteNumber"])(PDTValue)) {
                  return null;
                }
                var startPDT = fragments[0].programDateTime;
                if (PDTValue < (startPDT || 0)) {
                  return null;
                }
                var endPDT = fragments[fragments.length - 1].endProgramDateTime;
                if (PDTValue >= (endPDT || 0)) {
                  return null;
                }
                maxFragLookUpTolerance = maxFragLookUpTolerance || 0;
                for (var seg = 0; seg < fragments.length; ++seg) {
                  var frag = fragments[seg];
                  if (pdtWithinToleranceTest(PDTValue, maxFragLookUpTolerance, frag)) {
                    return frag;
                  }
                }
                return null;
              }
              function findFragmentByPTS(fragPrevious, fragments, bufferEnd, maxFragLookUpTolerance) {
                if (bufferEnd === void 0) {
                  bufferEnd = 0;
                }
                if (maxFragLookUpTolerance === void 0) {
                  maxFragLookUpTolerance = 0;
                }
                var fragNext = null;
                if (fragPrevious) {
                  fragNext = fragments[fragPrevious.sn - fragments[0].sn + 1];
                } else if (bufferEnd === 0 && fragments[0].start === 0) {
                  fragNext = fragments[0];
                }
                if (fragNext && fragmentWithinToleranceTest(bufferEnd, maxFragLookUpTolerance, fragNext) === 0) {
                  return fragNext;
                }
                var foundFragment = binary_search.search(fragments, fragmentWithinToleranceTest.bind(null, bufferEnd, maxFragLookUpTolerance));
                if (foundFragment) {
                  return foundFragment;
                }
                return fragNext;
              }
              function fragmentWithinToleranceTest(bufferEnd, maxFragLookUpTolerance, candidate) {
                if (bufferEnd === void 0) {
                  bufferEnd = 0;
                }
                if (maxFragLookUpTolerance === void 0) {
                  maxFragLookUpTolerance = 0;
                }
                var candidateLookupTolerance = Math.min(maxFragLookUpTolerance, candidate.duration + (candidate.deltaPTS ? candidate.deltaPTS : 0));
                if (candidate.start + candidate.duration - candidateLookupTolerance <= bufferEnd) {
                  return 1;
                } else if (candidate.start - candidateLookupTolerance > bufferEnd && candidate.start) {
                  return -1;
                }
                return 0;
              }
              function pdtWithinToleranceTest(pdtBufferEnd, maxFragLookUpTolerance, candidate) {
                var candidateLookupTolerance = Math.min(maxFragLookUpTolerance, candidate.duration + (candidate.deltaPTS ? candidate.deltaPTS : 0)) * 1e3;
                var endProgramDateTime = candidate.endProgramDateTime || 0;
                return endProgramDateTime - candidateLookupTolerance > pdtBufferEnd;
              }
              var STALL_MINIMUM_DURATION_MS = 250;
              var MAX_START_GAP_JUMP = 2;
              var SKIP_BUFFER_HOLE_STEP_SECONDS = 0.1;
              var SKIP_BUFFER_RANGE_START = 0.05;
              var gap_controller_GapController = function() {
                function GapController(config, media, fragmentTracker, hls) {
                  this.config = config;
                  this.media = media;
                  this.fragmentTracker = fragmentTracker;
                  this.hls = hls;
                  this.nudgeRetry = 0;
                  this.stallReported = false;
                  this.stalled = null;
                  this.moved = false;
                  this.seeking = false;
                }
                var _proto = GapController.prototype;
                _proto.poll = function poll(lastCurrentTime) {
                  var config = this.config, media = this.media, stalled = this.stalled;
                  var currentTime = media.currentTime, seeking = media.seeking;
                  var seeked = this.seeking && !seeking;
                  var beginSeek = !this.seeking && seeking;
                  this.seeking = seeking;
                  if (currentTime !== lastCurrentTime) {
                    this.moved = true;
                    if (stalled !== null) {
                      if (this.stallReported) {
                        var _stalledDuration = self.performance.now() - stalled;
                        logger["logger"].warn("playback not stuck anymore @" + currentTime + ", after " + Math.round(_stalledDuration) + "ms");
                        this.stallReported = false;
                      }
                      this.stalled = null;
                      this.nudgeRetry = 0;
                    }
                    return;
                  }
                  if (beginSeek || seeked) {
                    this.stalled = null;
                  }
                  if (media.paused || media.ended || media.playbackRate === 0 || !media.buffered.length) {
                    return;
                  }
                  var bufferInfo = BufferHelper.bufferInfo(media, currentTime, 0);
                  var isBuffered = bufferInfo.len > 0;
                  var nextStart = bufferInfo.nextStart || 0;
                  if (!isBuffered && !nextStart) {
                    return;
                  }
                  if (seeking) {
                    var hasEnoughBuffer = bufferInfo.len > MAX_START_GAP_JUMP;
                    var noBufferGap = !nextStart || nextStart - currentTime > MAX_START_GAP_JUMP && !this.fragmentTracker.getPartialFragment(currentTime);
                    if (hasEnoughBuffer || noBufferGap) {
                      return;
                    }
                    this.moved = false;
                  }
                  if (!this.moved && this.stalled) {
                    var startJump = Math.max(nextStart, bufferInfo.start || 0) - currentTime;
                    if (startJump > 0 && startJump <= MAX_START_GAP_JUMP) {
                      this._trySkipBufferHole(null);
                      return;
                    }
                  }
                  var tnow = self.performance.now();
                  if (stalled === null) {
                    this.stalled = tnow;
                    return;
                  }
                  var stalledDuration = tnow - stalled;
                  if (!seeking && stalledDuration >= STALL_MINIMUM_DURATION_MS) {
                    this._reportStall(bufferInfo.len);
                  }
                  var bufferedWithHoles = BufferHelper.bufferInfo(media, currentTime, config.maxBufferHole);
                  this._tryFixBufferStall(bufferedWithHoles, stalledDuration);
                };
                _proto._tryFixBufferStall = function _tryFixBufferStall(bufferInfo, stalledDurationMs) {
                  var config = this.config, fragmentTracker = this.fragmentTracker, media = this.media;
                  var currentTime = media.currentTime;
                  var partial = fragmentTracker.getPartialFragment(currentTime);
                  if (partial) {
                    var targetTime = this._trySkipBufferHole(partial);
                    if (targetTime) {
                      return;
                    }
                  }
                  if (bufferInfo.len > config.maxBufferHole && stalledDurationMs > config.highBufferWatchdogPeriod * 1e3) {
                    logger["logger"].warn("Trying to nudge playhead over buffer-hole");
                    this.stalled = null;
                    this._tryNudgeBuffer();
                  }
                };
                _proto._reportStall = function _reportStall(bufferLen) {
                  var hls = this.hls, media = this.media, stallReported = this.stallReported;
                  if (!stallReported) {
                    this.stallReported = true;
                    logger["logger"].warn("Playback stalling at @" + media.currentTime + " due to low buffer (buffer=" + bufferLen + ")");
                    hls.trigger(events["default"].ERROR, {
                      type: errors["ErrorTypes"].MEDIA_ERROR,
                      details: errors["ErrorDetails"].BUFFER_STALLED_ERROR,
                      fatal: false,
                      buffer: bufferLen
                    });
                  }
                };
                _proto._trySkipBufferHole = function _trySkipBufferHole(partial) {
                  var config = this.config, hls = this.hls, media = this.media;
                  var currentTime = media.currentTime;
                  var lastEndTime = 0;
                  for (var i = 0; i < media.buffered.length; i++) {
                    var startTime = media.buffered.start(i);
                    if (currentTime + config.maxBufferHole >= lastEndTime && currentTime < startTime) {
                      var targetTime = Math.max(startTime + SKIP_BUFFER_RANGE_START, media.currentTime + SKIP_BUFFER_HOLE_STEP_SECONDS);
                      logger["logger"].warn("skipping hole, adjusting currentTime from " + currentTime + " to " + targetTime);
                      this.moved = true;
                      this.stalled = null;
                      media.currentTime = targetTime;
                      if (partial) {
                        hls.trigger(events["default"].ERROR, {
                          type: errors["ErrorTypes"].MEDIA_ERROR,
                          details: errors["ErrorDetails"].BUFFER_SEEK_OVER_HOLE,
                          fatal: false,
                          reason: "fragment loaded with buffer holes, seeking from " + currentTime + " to " + targetTime,
                          frag: partial
                        });
                      }
                      return targetTime;
                    }
                    lastEndTime = media.buffered.end(i);
                  }
                  return 0;
                };
                _proto._tryNudgeBuffer = function _tryNudgeBuffer() {
                  var config = this.config, hls = this.hls, media = this.media;
                  var currentTime = media.currentTime;
                  var nudgeRetry = (this.nudgeRetry || 0) + 1;
                  this.nudgeRetry = nudgeRetry;
                  if (nudgeRetry < config.nudgeMaxRetry) {
                    var targetTime = currentTime + nudgeRetry * config.nudgeOffset;
                    logger["logger"].warn("Nudging 'currentTime' from " + currentTime + " to " + targetTime);
                    media.currentTime = targetTime;
                    hls.trigger(events["default"].ERROR, {
                      type: errors["ErrorTypes"].MEDIA_ERROR,
                      details: errors["ErrorDetails"].BUFFER_NUDGE_ON_STALL,
                      fatal: false
                    });
                  } else {
                    logger["logger"].error("Playhead still not moving while enough data buffered @" + currentTime + " after " + config.nudgeMaxRetry + " nudges");
                    hls.trigger(events["default"].ERROR, {
                      type: errors["ErrorTypes"].MEDIA_ERROR,
                      details: errors["ErrorDetails"].BUFFER_STALLED_ERROR,
                      fatal: true
                    });
                  }
                };
                return GapController;
              }();
              function _assertThisInitialized(self2) {
                if (self2 === void 0) {
                  throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                }
                return self2;
              }
              function task_loop_inheritsLoose(subClass, superClass) {
                subClass.prototype = Object.create(superClass.prototype);
                subClass.prototype.constructor = subClass;
                subClass.__proto__ = superClass;
              }
              var TaskLoop = function(_EventHandler) {
                task_loop_inheritsLoose(TaskLoop2, _EventHandler);
                function TaskLoop2(hls) {
                  var _this;
                  for (var _len = arguments.length, events2 = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
                    events2[_key - 1] = arguments[_key];
                  }
                  _this = _EventHandler.call.apply(_EventHandler, [this, hls].concat(events2)) || this;
                  _this._boundTick = void 0;
                  _this._tickTimer = null;
                  _this._tickInterval = null;
                  _this._tickCallCount = 0;
                  _this._boundTick = _this.tick.bind(_assertThisInitialized(_this));
                  return _this;
                }
                var _proto = TaskLoop2.prototype;
                _proto.onHandlerDestroying = function onHandlerDestroying() {
                  this.clearNextTick();
                  this.clearInterval();
                };
                _proto.hasInterval = function hasInterval() {
                  return !!this._tickInterval;
                };
                _proto.hasNextTick = function hasNextTick() {
                  return !!this._tickTimer;
                };
                _proto.setInterval = function setInterval2(millis) {
                  if (!this._tickInterval) {
                    this._tickInterval = self.setInterval(this._boundTick, millis);
                    return true;
                  }
                  return false;
                };
                _proto.clearInterval = function clearInterval2() {
                  if (this._tickInterval) {
                    self.clearInterval(this._tickInterval);
                    this._tickInterval = null;
                    return true;
                  }
                  return false;
                };
                _proto.clearNextTick = function clearNextTick() {
                  if (this._tickTimer) {
                    self.clearTimeout(this._tickTimer);
                    this._tickTimer = null;
                    return true;
                  }
                  return false;
                };
                _proto.tick = function tick() {
                  this._tickCallCount++;
                  if (this._tickCallCount === 1) {
                    this.doTick();
                    if (this._tickCallCount > 1) {
                      this.clearNextTick();
                      this._tickTimer = self.setTimeout(this._boundTick, 0);
                    }
                    this._tickCallCount = 0;
                  }
                };
                _proto.doTick = function doTick() {
                };
                return TaskLoop2;
              }(event_handler);
              function base_stream_controller_inheritsLoose(subClass, superClass) {
                subClass.prototype = Object.create(superClass.prototype);
                subClass.prototype.constructor = subClass;
                subClass.__proto__ = superClass;
              }
              var State = {
                STOPPED: "STOPPED",
                STARTING: "STARTING",
                IDLE: "IDLE",
                PAUSED: "PAUSED",
                KEY_LOADING: "KEY_LOADING",
                FRAG_LOADING: "FRAG_LOADING",
                FRAG_LOADING_WAITING_RETRY: "FRAG_LOADING_WAITING_RETRY",
                WAITING_TRACK: "WAITING_TRACK",
                PARSING: "PARSING",
                PARSED: "PARSED",
                BUFFER_FLUSHING: "BUFFER_FLUSHING",
                ENDED: "ENDED",
                ERROR: "ERROR",
                WAITING_INIT_PTS: "WAITING_INIT_PTS",
                WAITING_LEVEL: "WAITING_LEVEL"
              };
              var base_stream_controller_BaseStreamController = function(_TaskLoop) {
                base_stream_controller_inheritsLoose(BaseStreamController, _TaskLoop);
                function BaseStreamController() {
                  return _TaskLoop.apply(this, arguments) || this;
                }
                var _proto = BaseStreamController.prototype;
                _proto.doTick = function doTick() {
                };
                _proto.startLoad = function startLoad() {
                };
                _proto.stopLoad = function stopLoad() {
                  var frag = this.fragCurrent;
                  if (frag) {
                    if (frag.loader) {
                      frag.loader.abort();
                    }
                    this.fragmentTracker.removeFragment(frag);
                  }
                  if (this.demuxer) {
                    this.demuxer.destroy();
                    this.demuxer = null;
                  }
                  this.fragCurrent = null;
                  this.fragPrevious = null;
                  this.clearInterval();
                  this.clearNextTick();
                  this.state = State.STOPPED;
                };
                _proto._streamEnded = function _streamEnded(bufferInfo, levelDetails) {
                  var fragCurrent = this.fragCurrent, fragmentTracker = this.fragmentTracker;
                  if (!levelDetails.live && fragCurrent && !fragCurrent.backtracked && fragCurrent.sn === levelDetails.endSN && !bufferInfo.nextStart) {
                    var fragState = fragmentTracker.getState(fragCurrent);
                    return fragState === FragmentState.PARTIAL || fragState === FragmentState.OK;
                  }
                  return false;
                };
                _proto.onMediaSeeking = function onMediaSeeking() {
                  var config = this.config, media = this.media, mediaBuffer = this.mediaBuffer, state = this.state;
                  var currentTime = media ? media.currentTime : null;
                  var bufferInfo = BufferHelper.bufferInfo(mediaBuffer || media, currentTime, this.config.maxBufferHole);
                  logger["logger"].log("media seeking to " + (Object(number["isFiniteNumber"])(currentTime) ? currentTime.toFixed(3) : currentTime));
                  if (state === State.FRAG_LOADING) {
                    var fragCurrent = this.fragCurrent;
                    if (bufferInfo.len === 0 && fragCurrent) {
                      var tolerance = config.maxFragLookUpTolerance;
                      var fragStartOffset = fragCurrent.start - tolerance;
                      var fragEndOffset = fragCurrent.start + fragCurrent.duration + tolerance;
                      if (currentTime < fragStartOffset || currentTime > fragEndOffset) {
                        if (fragCurrent.loader) {
                          logger["logger"].log("seeking outside of buffer while fragment load in progress, cancel fragment load");
                          fragCurrent.loader.abort();
                        }
                        this.fragCurrent = null;
                        this.fragPrevious = null;
                        this.state = State.IDLE;
                      } else {
                        logger["logger"].log("seeking outside of buffer but within currently loaded fragment range");
                      }
                    }
                  } else if (state === State.ENDED) {
                    if (bufferInfo.len === 0) {
                      this.fragPrevious = null;
                      this.fragCurrent = null;
                    }
                    this.state = State.IDLE;
                  }
                  if (media) {
                    this.lastCurrentTime = currentTime;
                  }
                  if (!this.loadedmetadata) {
                    this.nextLoadPosition = this.startPosition = currentTime;
                  }
                  this.tick();
                };
                _proto.onMediaEnded = function onMediaEnded() {
                  this.startPosition = this.lastCurrentTime = 0;
                };
                _proto.onHandlerDestroying = function onHandlerDestroying() {
                  this.stopLoad();
                  _TaskLoop.prototype.onHandlerDestroying.call(this);
                };
                _proto.onHandlerDestroyed = function onHandlerDestroyed() {
                  this.state = State.STOPPED;
                  this.fragmentTracker = null;
                };
                _proto.computeLivePosition = function computeLivePosition(sliding, levelDetails) {
                  var targetLatency = this.config.liveSyncDuration !== void 0 ? this.config.liveSyncDuration : this.config.liveSyncDurationCount * levelDetails.targetduration;
                  return sliding + Math.max(0, levelDetails.totalduration - targetLatency);
                };
                return BaseStreamController;
              }(TaskLoop);
              function stream_controller_defineProperties(target, props) {
                for (var i = 0; i < props.length; i++) {
                  var descriptor = props[i];
                  descriptor.enumerable = descriptor.enumerable || false;
                  descriptor.configurable = true;
                  if ("value" in descriptor)
                    descriptor.writable = true;
                  Object.defineProperty(target, descriptor.key, descriptor);
                }
              }
              function stream_controller_createClass(Constructor, protoProps, staticProps) {
                if (protoProps)
                  stream_controller_defineProperties(Constructor.prototype, protoProps);
                if (staticProps)
                  stream_controller_defineProperties(Constructor, staticProps);
                return Constructor;
              }
              function stream_controller_inheritsLoose(subClass, superClass) {
                subClass.prototype = Object.create(superClass.prototype);
                subClass.prototype.constructor = subClass;
                subClass.__proto__ = superClass;
              }
              var TICK_INTERVAL = 100;
              var stream_controller_StreamController = function(_BaseStreamController) {
                stream_controller_inheritsLoose(StreamController, _BaseStreamController);
                function StreamController(hls, fragmentTracker) {
                  var _this;
                  _this = _BaseStreamController.call(this, hls, events["default"].MEDIA_ATTACHED, events["default"].MEDIA_DETACHING, events["default"].MANIFEST_LOADING, events["default"].MANIFEST_PARSED, events["default"].LEVEL_LOADED, events["default"].LEVELS_UPDATED, events["default"].KEY_LOADED, events["default"].FRAG_LOADED, events["default"].FRAG_LOAD_EMERGENCY_ABORTED, events["default"].FRAG_PARSING_INIT_SEGMENT, events["default"].FRAG_PARSING_DATA, events["default"].FRAG_PARSED, events["default"].ERROR, events["default"].AUDIO_TRACK_SWITCHING, events["default"].AUDIO_TRACK_SWITCHED, events["default"].BUFFER_CREATED, events["default"].BUFFER_APPENDED, events["default"].BUFFER_FLUSHED) || this;
                  _this.fragmentTracker = fragmentTracker;
                  _this.config = hls.config;
                  _this.audioCodecSwap = false;
                  _this._state = State.STOPPED;
                  _this.stallReported = false;
                  _this.gapController = null;
                  _this.altAudio = false;
                  _this.audioOnly = false;
                  _this.bitrateTest = false;
                  return _this;
                }
                var _proto = StreamController.prototype;
                _proto.startLoad = function startLoad(startPosition) {
                  if (this.levels) {
                    var lastCurrentTime = this.lastCurrentTime, hls = this.hls;
                    this.stopLoad();
                    this.setInterval(TICK_INTERVAL);
                    this.level = -1;
                    this.fragLoadError = 0;
                    if (!this.startFragRequested) {
                      var startLevel = hls.startLevel;
                      if (startLevel === -1) {
                        if (hls.config.testBandwidth) {
                          startLevel = 0;
                          this.bitrateTest = true;
                        } else {
                          startLevel = hls.nextAutoLevel;
                        }
                      }
                      this.level = hls.nextLoadLevel = startLevel;
                      this.loadedmetadata = false;
                    }
                    if (lastCurrentTime > 0 && startPosition === -1) {
                      logger["logger"].log("override startPosition with lastCurrentTime @" + lastCurrentTime.toFixed(3));
                      startPosition = lastCurrentTime;
                    }
                    this.state = State.IDLE;
                    this.nextLoadPosition = this.startPosition = this.lastCurrentTime = startPosition;
                    this.tick();
                  } else {
                    this.forceStartLoad = true;
                    this.state = State.STOPPED;
                  }
                };
                _proto.stopLoad = function stopLoad() {
                  this.forceStartLoad = false;
                  _BaseStreamController.prototype.stopLoad.call(this);
                };
                _proto.doTick = function doTick() {
                  switch (this.state) {
                    case State.BUFFER_FLUSHING:
                      this.fragLoadError = 0;
                      break;
                    case State.IDLE:
                      this._doTickIdle();
                      break;
                    case State.WAITING_LEVEL:
                      var level = this.levels[this.level];
                      if (level && level.details) {
                        this.state = State.IDLE;
                      }
                      break;
                    case State.FRAG_LOADING_WAITING_RETRY:
                      var now = window.performance.now();
                      var retryDate = this.retryDate;
                      if (!retryDate || now >= retryDate || this.media && this.media.seeking) {
                        logger["logger"].log("mediaController: retryDate reached, switch back to IDLE state");
                        this.state = State.IDLE;
                      }
                      break;
                    case State.ERROR:
                    case State.STOPPED:
                    case State.FRAG_LOADING:
                    case State.PARSING:
                    case State.PARSED:
                    case State.ENDED:
                      break;
                    default:
                      break;
                  }
                  this._checkBuffer();
                  this._checkFragmentChanged();
                };
                _proto._doTickIdle = function _doTickIdle() {
                  var hls = this.hls, config = hls.config, media = this.media;
                  if (this.levelLastLoaded === void 0 || !media && (this.startFragRequested || !config.startFragPrefetch)) {
                    return;
                  }
                  if (this.altAudio && this.audioOnly) {
                    this.demuxer.frag = null;
                    return;
                  }
                  var pos;
                  if (this.loadedmetadata) {
                    pos = media.currentTime;
                  } else {
                    pos = this.nextLoadPosition;
                  }
                  var level = hls.nextLoadLevel, levelInfo = this.levels[level];
                  if (!levelInfo) {
                    return;
                  }
                  var levelBitrate = levelInfo.bitrate, maxBufLen;
                  if (levelBitrate) {
                    maxBufLen = Math.max(8 * config.maxBufferSize / levelBitrate, config.maxBufferLength);
                  } else {
                    maxBufLen = config.maxBufferLength;
                  }
                  maxBufLen = Math.min(maxBufLen, config.maxMaxBufferLength);
                  var maxBufferHole = pos < config.maxBufferHole ? Math.max(MAX_START_GAP_JUMP, config.maxBufferHole) : config.maxBufferHole;
                  var bufferInfo = BufferHelper.bufferInfo(this.mediaBuffer ? this.mediaBuffer : media, pos, maxBufferHole);
                  var bufferLen = bufferInfo.len;
                  if (bufferLen >= maxBufLen) {
                    return;
                  }
                  logger["logger"].trace("buffer length of " + bufferLen.toFixed(3) + " is below max of " + maxBufLen.toFixed(3) + ". checking for more payload ...");
                  this.level = hls.nextLoadLevel = level;
                  var levelDetails = levelInfo.details;
                  if (!levelDetails || levelDetails.live && this.levelLastLoaded !== level) {
                    this.state = State.WAITING_LEVEL;
                    return;
                  }
                  if (this._streamEnded(bufferInfo, levelDetails)) {
                    var data = {};
                    if (this.altAudio) {
                      data.type = "video";
                    }
                    this.hls.trigger(events["default"].BUFFER_EOS, data);
                    this.state = State.ENDED;
                    return;
                  }
                  this._fetchPayloadOrEos(pos, bufferInfo, levelDetails);
                };
                _proto._fetchPayloadOrEos = function _fetchPayloadOrEos(pos, bufferInfo, levelDetails) {
                  var fragPrevious = this.fragPrevious, level = this.level, fragments = levelDetails.fragments, fragLen = fragments.length;
                  if (fragLen === 0) {
                    return;
                  }
                  var start = fragments[0].start, end = fragments[fragLen - 1].start + fragments[fragLen - 1].duration, bufferEnd = bufferInfo.end, frag;
                  if (levelDetails.initSegment && !levelDetails.initSegment.data) {
                    frag = levelDetails.initSegment;
                  } else {
                    if (levelDetails.live) {
                      var initialLiveManifestSize = this.config.initialLiveManifestSize;
                      if (fragLen < initialLiveManifestSize) {
                        logger["logger"].warn("Can not start playback of a level, reason: not enough fragments " + fragLen + " < " + initialLiveManifestSize);
                        return;
                      }
                      frag = this._ensureFragmentAtLivePoint(levelDetails, bufferEnd, start, end, fragPrevious, fragments);
                      if (frag === null) {
                        return;
                      }
                    } else {
                      if (bufferEnd < start) {
                        frag = fragments[0];
                      }
                    }
                  }
                  if (!frag) {
                    frag = this._findFragment(start, fragPrevious, fragLen, fragments, bufferEnd, end, levelDetails);
                  }
                  if (frag) {
                    if (frag.encrypted) {
                      this._loadKey(frag, levelDetails);
                    } else {
                      this._loadFragment(frag, levelDetails, pos, bufferEnd);
                    }
                  }
                };
                _proto._ensureFragmentAtLivePoint = function _ensureFragmentAtLivePoint(levelDetails, bufferEnd, start, end, fragPrevious, fragments) {
                  var config = this.hls.config, media = this.media;
                  var frag;
                  var maxLatency = Infinity;
                  if (config.liveMaxLatencyDuration !== void 0) {
                    maxLatency = config.liveMaxLatencyDuration;
                  } else if (Object(number["isFiniteNumber"])(config.liveMaxLatencyDurationCount)) {
                    maxLatency = config.liveMaxLatencyDurationCount * levelDetails.targetduration;
                  }
                  if (bufferEnd < Math.max(start - config.maxFragLookUpTolerance, end - maxLatency)) {
                    var liveSyncPosition = this.liveSyncPosition = this.computeLivePosition(start, levelDetails);
                    bufferEnd = liveSyncPosition;
                    if (media && !media.paused && media.readyState && media.duration > liveSyncPosition && liveSyncPosition > media.currentTime) {
                      logger["logger"].log("buffer end: " + bufferEnd.toFixed(3) + " is located too far from the end of live sliding playlist, reset currentTime to : " + liveSyncPosition.toFixed(3));
                      media.currentTime = liveSyncPosition;
                    }
                    this.nextLoadPosition = liveSyncPosition;
                  }
                  if (levelDetails.PTSKnown && bufferEnd > end && media && media.readyState) {
                    return null;
                  }
                  if (this.startFragRequested && !levelDetails.PTSKnown) {
                    if (fragPrevious) {
                      if (levelDetails.hasProgramDateTime) {
                        logger["logger"].log("live playlist, switching playlist, load frag with same PDT: " + fragPrevious.programDateTime);
                        frag = findFragmentByPDT(fragments, fragPrevious.endProgramDateTime, config.maxFragLookUpTolerance);
                      } else {
                        var targetSN = fragPrevious.sn + 1;
                        if (targetSN >= levelDetails.startSN && targetSN <= levelDetails.endSN) {
                          var fragNext = fragments[targetSN - levelDetails.startSN];
                          if (fragPrevious.cc === fragNext.cc) {
                            frag = fragNext;
                            logger["logger"].log("live playlist, switching playlist, load frag with next SN: " + frag.sn);
                          }
                        }
                        if (!frag) {
                          frag = binary_search.search(fragments, function(frag2) {
                            return fragPrevious.cc - frag2.cc;
                          });
                          if (frag) {
                            logger["logger"].log("live playlist, switching playlist, load frag with same CC: " + frag.sn);
                          }
                        }
                      }
                    }
                  }
                  return frag;
                };
                _proto._findFragment = function _findFragment(start, fragPreviousLoad, fragmentIndexRange, fragments, bufferEnd, end, levelDetails) {
                  var config = this.hls.config;
                  var fragNextLoad;
                  if (bufferEnd < end) {
                    var lookupTolerance = bufferEnd > end - config.maxFragLookUpTolerance ? 0 : config.maxFragLookUpTolerance;
                    fragNextLoad = findFragmentByPTS(fragPreviousLoad, fragments, bufferEnd, lookupTolerance);
                  } else {
                    fragNextLoad = fragments[fragmentIndexRange - 1];
                  }
                  if (fragNextLoad) {
                    var curSNIdx = fragNextLoad.sn - levelDetails.startSN;
                    var sameLevel = fragPreviousLoad && fragNextLoad.level === fragPreviousLoad.level;
                    var prevSnFrag = fragments[curSNIdx - 1];
                    var nextSnFrag = fragments[curSNIdx + 1];
                    if (fragPreviousLoad && fragNextLoad.sn === fragPreviousLoad.sn) {
                      if (sameLevel && !fragNextLoad.backtracked) {
                        if (fragNextLoad.sn < levelDetails.endSN) {
                          var deltaPTS = fragPreviousLoad.deltaPTS;
                          if (deltaPTS && deltaPTS > config.maxBufferHole && fragPreviousLoad.dropped && curSNIdx) {
                            fragNextLoad = prevSnFrag;
                            logger["logger"].warn("Previous fragment was dropped with large PTS gap between audio and video. Maybe fragment is not starting with a keyframe? Loading previous one to try to overcome this");
                          } else {
                            fragNextLoad = nextSnFrag;
                            if (this.fragmentTracker.getState(fragNextLoad) !== FragmentState.OK) {
                              logger["logger"].log("Re-loading fragment with SN: " + fragNextLoad.sn);
                            }
                          }
                        } else {
                          fragNextLoad = null;
                        }
                      } else if (fragNextLoad.backtracked) {
                        if (nextSnFrag && nextSnFrag.backtracked) {
                          logger["logger"].warn("Already backtracked from fragment " + nextSnFrag.sn + ", will not backtrack to fragment " + fragNextLoad.sn + ". Loading fragment " + nextSnFrag.sn);
                          fragNextLoad = nextSnFrag;
                        } else {
                          logger["logger"].warn("Loaded fragment with dropped frames, backtracking 1 segment to find a keyframe");
                          fragNextLoad.dropped = 0;
                          if (prevSnFrag) {
                            fragNextLoad = prevSnFrag;
                            fragNextLoad.backtracked = true;
                          } else if (curSNIdx) {
                            fragNextLoad = null;
                          }
                        }
                      }
                    }
                  }
                  return fragNextLoad;
                };
                _proto._loadKey = function _loadKey(frag, levelDetails) {
                  logger["logger"].log("Loading key for " + frag.sn + " of [" + levelDetails.startSN + "-" + levelDetails.endSN + "], level " + this.level);
                  this.state = State.KEY_LOADING;
                  this.hls.trigger(events["default"].KEY_LOADING, {
                    frag
                  });
                };
                _proto._loadFragment = function _loadFragment(frag, levelDetails, pos, bufferEnd) {
                  var fragState = this.fragmentTracker.getState(frag);
                  this.fragCurrent = frag;
                  if (frag.sn !== "initSegment") {
                    this.startFragRequested = true;
                  }
                  if (Object(number["isFiniteNumber"])(frag.sn) && !frag.bitrateTest) {
                    this.nextLoadPosition = frag.start + frag.duration;
                  }
                  if (frag.backtracked || fragState === FragmentState.NOT_LOADED || fragState === FragmentState.PARTIAL) {
                    frag.autoLevel = this.hls.autoLevelEnabled;
                    frag.bitrateTest = this.bitrateTest;
                    logger["logger"].log("Loading " + frag.sn + " of [" + levelDetails.startSN + "-" + levelDetails.endSN + "], level " + this.level + ", " + (this.loadedmetadata ? "currentTime" : "nextLoadPosition") + ": " + parseFloat(pos.toFixed(3)) + ", bufferEnd: " + parseFloat(bufferEnd.toFixed(3)));
                    this.hls.trigger(events["default"].FRAG_LOADING, {
                      frag
                    });
                    if (!this.demuxer) {
                      this.demuxer = new demux_demuxer(this.hls, "main");
                    }
                    this.state = State.FRAG_LOADING;
                  } else if (fragState === FragmentState.APPENDING) {
                    if (this._reduceMaxBufferLength(frag.duration)) {
                      this.fragmentTracker.removeFragment(frag);
                    }
                  }
                };
                _proto.getBufferedFrag = function getBufferedFrag(position) {
                  return this.fragmentTracker.getBufferedFrag(position, PlaylistLevelType.MAIN);
                };
                _proto.followingBufferedFrag = function followingBufferedFrag(frag) {
                  if (frag) {
                    return this.getBufferedFrag(frag.endPTS + 0.5);
                  }
                  return null;
                };
                _proto._checkFragmentChanged = function _checkFragmentChanged() {
                  var fragPlayingCurrent, currentTime, video = this.media;
                  if (video && video.readyState && video.seeking === false) {
                    currentTime = video.currentTime;
                    if (currentTime > this.lastCurrentTime) {
                      this.lastCurrentTime = currentTime;
                    }
                    if (BufferHelper.isBuffered(video, currentTime)) {
                      fragPlayingCurrent = this.getBufferedFrag(currentTime);
                    } else if (BufferHelper.isBuffered(video, currentTime + 0.1)) {
                      fragPlayingCurrent = this.getBufferedFrag(currentTime + 0.1);
                    }
                    if (fragPlayingCurrent) {
                      var fragPlaying = fragPlayingCurrent;
                      if (fragPlaying !== this.fragPlaying) {
                        this.hls.trigger(events["default"].FRAG_CHANGED, {
                          frag: fragPlaying
                        });
                        var fragPlayingLevel = fragPlaying.level;
                        if (!this.fragPlaying || this.fragPlaying.level !== fragPlayingLevel) {
                          this.hls.trigger(events["default"].LEVEL_SWITCHED, {
                            level: fragPlayingLevel
                          });
                        }
                        this.fragPlaying = fragPlaying;
                      }
                    }
                  }
                };
                _proto.immediateLevelSwitch = function immediateLevelSwitch() {
                  logger["logger"].log("immediateLevelSwitch");
                  if (!this.immediateSwitch) {
                    this.immediateSwitch = true;
                    var media = this.media, previouslyPaused;
                    if (media) {
                      previouslyPaused = media.paused;
                      if (!previouslyPaused) {
                        media.pause();
                      }
                    } else {
                      previouslyPaused = true;
                    }
                    this.previouslyPaused = previouslyPaused;
                  }
                  var fragCurrent = this.fragCurrent;
                  if (fragCurrent && fragCurrent.loader) {
                    fragCurrent.loader.abort();
                  }
                  this.fragCurrent = null;
                  this.flushMainBuffer(0, Number.POSITIVE_INFINITY);
                };
                _proto.immediateLevelSwitchEnd = function immediateLevelSwitchEnd() {
                  var media = this.media;
                  if (media && media.buffered.length) {
                    this.immediateSwitch = false;
                    if (media.currentTime > 0 && BufferHelper.isBuffered(media, media.currentTime)) {
                      media.currentTime -= 1e-4;
                    }
                    if (!this.previouslyPaused) {
                      media.play();
                    }
                  }
                };
                _proto.nextLevelSwitch = function nextLevelSwitch() {
                  var media = this.media;
                  if (media && media.readyState) {
                    var fetchdelay;
                    var fragPlayingCurrent = this.getBufferedFrag(media.currentTime);
                    if (fragPlayingCurrent && fragPlayingCurrent.startPTS > 1) {
                      this.flushMainBuffer(0, fragPlayingCurrent.startPTS - 1);
                    }
                    if (!media.paused) {
                      var nextLevelId = this.hls.nextLoadLevel, nextLevel = this.levels[nextLevelId], fragLastKbps = this.fragLastKbps;
                      if (fragLastKbps && this.fragCurrent) {
                        fetchdelay = this.fragCurrent.duration * nextLevel.bitrate / (1e3 * fragLastKbps) + 1;
                      } else {
                        fetchdelay = 0;
                      }
                    } else {
                      fetchdelay = 0;
                    }
                    var bufferedFrag = this.getBufferedFrag(media.currentTime + fetchdelay);
                    if (bufferedFrag) {
                      var nextBufferedFrag = this.followingBufferedFrag(bufferedFrag);
                      if (nextBufferedFrag) {
                        var fragCurrent = this.fragCurrent;
                        if (fragCurrent && fragCurrent.loader) {
                          fragCurrent.loader.abort();
                        }
                        this.fragCurrent = null;
                        var startPts = Math.max(bufferedFrag.endPTS, nextBufferedFrag.maxStartPTS + Math.min(this.config.maxFragLookUpTolerance, nextBufferedFrag.duration));
                        this.flushMainBuffer(startPts, Number.POSITIVE_INFINITY);
                      }
                    }
                  }
                };
                _proto.flushMainBuffer = function flushMainBuffer(startOffset, endOffset) {
                  this.state = State.BUFFER_FLUSHING;
                  var flushScope = {
                    startOffset,
                    endOffset
                  };
                  if (this.altAudio) {
                    flushScope.type = "video";
                  }
                  this.hls.trigger(events["default"].BUFFER_FLUSHING, flushScope);
                };
                _proto.onMediaAttached = function onMediaAttached(data) {
                  var media = this.media = this.mediaBuffer = data.media;
                  this.onvseeking = this.onMediaSeeking.bind(this);
                  this.onvseeked = this.onMediaSeeked.bind(this);
                  this.onvended = this.onMediaEnded.bind(this);
                  media.addEventListener("seeking", this.onvseeking);
                  media.addEventListener("seeked", this.onvseeked);
                  media.addEventListener("ended", this.onvended);
                  var config = this.config;
                  if (this.levels && config.autoStartLoad) {
                    this.hls.startLoad(config.startPosition);
                  }
                  this.gapController = new gap_controller_GapController(config, media, this.fragmentTracker, this.hls);
                };
                _proto.onMediaDetaching = function onMediaDetaching() {
                  var media = this.media;
                  if (media && media.ended) {
                    logger["logger"].log("MSE detaching and video ended, reset startPosition");
                    this.startPosition = this.lastCurrentTime = 0;
                  }
                  var levels = this.levels;
                  if (levels) {
                    levels.forEach(function(level) {
                      if (level.details) {
                        level.details.fragments.forEach(function(fragment) {
                          fragment.backtracked = void 0;
                        });
                      }
                    });
                  }
                  if (media) {
                    media.removeEventListener("seeking", this.onvseeking);
                    media.removeEventListener("seeked", this.onvseeked);
                    media.removeEventListener("ended", this.onvended);
                    this.onvseeking = this.onvseeked = this.onvended = null;
                  }
                  this.fragmentTracker.removeAllFragments();
                  this.media = this.mediaBuffer = null;
                  this.loadedmetadata = false;
                  this.stopLoad();
                };
                _proto.onMediaSeeked = function onMediaSeeked() {
                  var media = this.media;
                  var currentTime = media ? media.currentTime : void 0;
                  if (Object(number["isFiniteNumber"])(currentTime)) {
                    logger["logger"].log("media seeked to " + currentTime.toFixed(3));
                  }
                  this.tick();
                };
                _proto.onManifestLoading = function onManifestLoading() {
                  logger["logger"].log("trigger BUFFER_RESET");
                  this.hls.trigger(events["default"].BUFFER_RESET);
                  this.fragmentTracker.removeAllFragments();
                  this.stalled = false;
                  this.startPosition = this.lastCurrentTime = 0;
                };
                _proto.onManifestParsed = function onManifestParsed(data) {
                  var aac = false, heaac = false, codec;
                  data.levels.forEach(function(level) {
                    codec = level.audioCodec;
                    if (codec) {
                      if (codec.indexOf("mp4a.40.2") !== -1) {
                        aac = true;
                      }
                      if (codec.indexOf("mp4a.40.5") !== -1) {
                        heaac = true;
                      }
                    }
                  });
                  this.audioCodecSwitch = aac && heaac;
                  if (this.audioCodecSwitch) {
                    logger["logger"].log("both AAC/HE-AAC audio found in levels; declaring level codec as HE-AAC");
                  }
                  this.altAudio = data.altAudio;
                  this.levels = data.levels;
                  this.startFragRequested = false;
                  var config = this.config;
                  if (config.autoStartLoad || this.forceStartLoad) {
                    this.hls.startLoad(config.startPosition);
                  }
                };
                _proto.onLevelLoaded = function onLevelLoaded(data) {
                  var newDetails = data.details;
                  var newLevelId = data.level;
                  var lastLevel = this.levels[this.levelLastLoaded];
                  var curLevel = this.levels[newLevelId];
                  var duration = newDetails.totalduration;
                  var sliding = 0;
                  logger["logger"].log("level " + newLevelId + " loaded [" + newDetails.startSN + "," + newDetails.endSN + "],duration:" + duration);
                  if (newDetails.live || curLevel.details && curLevel.details.live) {
                    var curDetails = curLevel.details;
                    if (curDetails && newDetails.fragments.length > 0) {
                      mergeDetails(curDetails, newDetails);
                      sliding = newDetails.fragments[0].start;
                      this.liveSyncPosition = this.computeLivePosition(sliding, curDetails);
                      if (newDetails.PTSKnown && Object(number["isFiniteNumber"])(sliding)) {
                        logger["logger"].log("live playlist sliding:" + sliding.toFixed(3));
                      } else {
                        logger["logger"].log("live playlist - outdated PTS, unknown sliding");
                        alignStream(this.fragPrevious, lastLevel, newDetails);
                      }
                    } else {
                      logger["logger"].log("live playlist - first load, unknown sliding");
                      newDetails.PTSKnown = false;
                      alignStream(this.fragPrevious, lastLevel, newDetails);
                    }
                  } else {
                    newDetails.PTSKnown = false;
                  }
                  curLevel.details = newDetails;
                  this.levelLastLoaded = newLevelId;
                  this.hls.trigger(events["default"].LEVEL_UPDATED, {
                    details: newDetails,
                    level: newLevelId
                  });
                  if (this.startFragRequested === false) {
                    if (this.startPosition === -1 || this.lastCurrentTime === -1) {
                      var startTimeOffset = newDetails.startTimeOffset;
                      if (Object(number["isFiniteNumber"])(startTimeOffset)) {
                        if (startTimeOffset < 0) {
                          logger["logger"].log("negative start time offset " + startTimeOffset + ", count from end of last fragment");
                          startTimeOffset = sliding + duration + startTimeOffset;
                        }
                        logger["logger"].log("start time offset found in playlist, adjust startPosition to " + startTimeOffset);
                        this.startPosition = startTimeOffset;
                      } else {
                        if (newDetails.live) {
                          this.startPosition = this.computeLivePosition(sliding, newDetails);
                          logger["logger"].log("configure startPosition to " + this.startPosition);
                        } else {
                          this.startPosition = 0;
                        }
                      }
                      this.lastCurrentTime = this.startPosition;
                    }
                    this.nextLoadPosition = this.startPosition;
                  }
                  if (this.state === State.WAITING_LEVEL) {
                    this.state = State.IDLE;
                  }
                  this.tick();
                };
                _proto.onKeyLoaded = function onKeyLoaded() {
                  if (this.state === State.KEY_LOADING) {
                    this.state = State.IDLE;
                    this.tick();
                  }
                };
                _proto.onFragLoaded = function onFragLoaded(data) {
                  var fragCurrent = this.fragCurrent, hls = this.hls, levels = this.levels, media = this.media;
                  var fragLoaded = data.frag;
                  if (this.state === State.FRAG_LOADING && fragCurrent && fragLoaded.type === "main" && fragLoaded.level === fragCurrent.level && fragLoaded.sn === fragCurrent.sn) {
                    var stats = data.stats;
                    var currentLevel = levels[fragCurrent.level];
                    var details = currentLevel.details;
                    this.bitrateTest = false;
                    this.stats = stats;
                    logger["logger"].log("Loaded " + fragCurrent.sn + " of [" + details.startSN + " ," + details.endSN + "],level " + fragCurrent.level);
                    if (fragLoaded.bitrateTest && hls.nextLoadLevel) {
                      this.state = State.IDLE;
                      this.startFragRequested = false;
                      stats.tparsed = stats.tbuffered = window.performance.now();
                      hls.trigger(events["default"].FRAG_BUFFERED, {
                        stats,
                        frag: fragCurrent,
                        id: "main"
                      });
                      this.tick();
                    } else if (fragLoaded.sn === "initSegment") {
                      this.state = State.IDLE;
                      stats.tparsed = stats.tbuffered = window.performance.now();
                      details.initSegment.data = data.payload;
                      hls.trigger(events["default"].FRAG_BUFFERED, {
                        stats,
                        frag: fragCurrent,
                        id: "main"
                      });
                      this.tick();
                    } else {
                      logger["logger"].log("Parsing " + fragCurrent.sn + " of [" + details.startSN + " ," + details.endSN + "],level " + fragCurrent.level + ", cc " + fragCurrent.cc);
                      this.state = State.PARSING;
                      this.pendingBuffering = true;
                      this.appended = false;
                      if (fragLoaded.bitrateTest) {
                        fragLoaded.bitrateTest = false;
                        this.fragmentTracker.onFragLoaded({
                          frag: fragLoaded
                        });
                      }
                      var accurateTimeOffset = !(media && media.seeking) && (details.PTSKnown || !details.live);
                      var initSegmentData = details.initSegment ? details.initSegment.data : [];
                      var audioCodec = this._getAudioCodec(currentLevel);
                      var demuxer = this.demuxer = this.demuxer || new demux_demuxer(this.hls, "main");
                      demuxer.push(data.payload, initSegmentData, audioCodec, currentLevel.videoCodec, fragCurrent, details.totalduration, accurateTimeOffset);
                    }
                  }
                  this.fragLoadError = 0;
                };
                _proto.onFragParsingInitSegment = function onFragParsingInitSegment(data) {
                  var fragCurrent = this.fragCurrent;
                  var fragNew = data.frag;
                  if (fragCurrent && data.id === "main" && fragNew.sn === fragCurrent.sn && fragNew.level === fragCurrent.level && this.state === State.PARSING) {
                    var tracks = data.tracks, trackName, track;
                    this.audioOnly = tracks.audio && !tracks.video;
                    if (this.altAudio && !this.audioOnly) {
                      delete tracks.audio;
                    }
                    track = tracks.audio;
                    if (track) {
                      var audioCodec = this.levels[this.level].audioCodec, ua = navigator.userAgent.toLowerCase();
                      if (audioCodec && this.audioCodecSwap) {
                        logger["logger"].log("swapping playlist audio codec");
                        if (audioCodec.indexOf("mp4a.40.5") !== -1) {
                          audioCodec = "mp4a.40.2";
                        } else {
                          audioCodec = "mp4a.40.5";
                        }
                      }
                      if (this.audioCodecSwitch) {
                        if (track.metadata.channelCount !== 1 && // don't force HE-AAC if firefox
                        ua.indexOf("firefox") === -1) {
                          audioCodec = "mp4a.40.5";
                        }
                      }
                      if (ua.indexOf("android") !== -1 && track.container !== "audio/mpeg") {
                        audioCodec = "mp4a.40.2";
                        logger["logger"].log("Android: force audio codec to " + audioCodec);
                      }
                      track.levelCodec = audioCodec;
                      track.id = data.id;
                    }
                    track = tracks.video;
                    if (track) {
                      track.levelCodec = this.levels[this.level].videoCodec;
                      track.id = data.id;
                    }
                    this.hls.trigger(events["default"].BUFFER_CODECS, tracks);
                    for (trackName in tracks) {
                      track = tracks[trackName];
                      logger["logger"].log("main track:" + trackName + ",container:" + track.container + ",codecs[level/parsed]=[" + track.levelCodec + "/" + track.codec + "]");
                      var initSegment = track.initSegment;
                      if (initSegment) {
                        this.appended = true;
                        this.pendingBuffering = true;
                        this.hls.trigger(events["default"].BUFFER_APPENDING, {
                          type: trackName,
                          data: initSegment,
                          parent: "main",
                          content: "initSegment"
                        });
                      }
                    }
                    this.tick();
                  }
                };
                _proto.onFragParsingData = function onFragParsingData(data) {
                  var _this2 = this;
                  var fragCurrent = this.fragCurrent;
                  var fragNew = data.frag;
                  if (fragCurrent && data.id === "main" && fragNew.sn === fragCurrent.sn && fragNew.level === fragCurrent.level && !(data.type === "audio" && this.altAudio) && // filter out main audio if audio track is loaded through audio stream controller
                  this.state === State.PARSING) {
                    var level = this.levels[this.level], frag = fragCurrent;
                    if (!Object(number["isFiniteNumber"])(data.endPTS)) {
                      data.endPTS = data.startPTS + fragCurrent.duration;
                      data.endDTS = data.startDTS + fragCurrent.duration;
                    }
                    if (data.hasAudio === true) {
                      frag.addElementaryStream(ElementaryStreamTypes.AUDIO);
                    }
                    if (data.hasVideo === true) {
                      frag.addElementaryStream(ElementaryStreamTypes.VIDEO);
                    }
                    logger["logger"].log("Parsed " + data.type + ",PTS:[" + data.startPTS.toFixed(3) + "," + data.endPTS.toFixed(3) + "],DTS:[" + data.startDTS.toFixed(3) + "/" + data.endDTS.toFixed(3) + "],nb:" + data.nb + ",dropped:" + (data.dropped || 0));
                    if (data.type === "video") {
                      frag.dropped = data.dropped;
                      if (frag.dropped) {
                        if (!frag.backtracked) {
                          var levelDetails = level.details;
                          if (levelDetails && frag.sn === levelDetails.startSN) {
                            logger["logger"].warn("missing video frame(s) on first frag, appending with gap", frag.sn);
                          } else {
                            logger["logger"].warn("missing video frame(s), backtracking fragment", frag.sn);
                            this.fragmentTracker.removeFragment(frag);
                            frag.backtracked = true;
                            this.nextLoadPosition = data.startPTS;
                            this.state = State.IDLE;
                            this.fragPrevious = frag;
                            if (this.demuxer) {
                              this.demuxer.destroy();
                              this.demuxer = null;
                            }
                            this.tick();
                            return;
                          }
                        } else {
                          logger["logger"].warn("Already backtracked on this fragment, appending with the gap", frag.sn);
                        }
                      } else {
                        frag.backtracked = false;
                      }
                    }
                    var drift = updateFragPTSDTS(level.details, frag, data.startPTS, data.endPTS, data.startDTS, data.endDTS), hls = this.hls;
                    hls.trigger(events["default"].LEVEL_PTS_UPDATED, {
                      details: level.details,
                      level: this.level,
                      drift,
                      type: data.type,
                      start: data.startPTS,
                      end: data.endPTS
                    });
                    [data.data1, data.data2].forEach(function(buffer) {
                      if (buffer && buffer.length && _this2.state === State.PARSING) {
                        _this2.appended = true;
                        _this2.pendingBuffering = true;
                        hls.trigger(events["default"].BUFFER_APPENDING, {
                          type: data.type,
                          data: buffer,
                          parent: "main",
                          content: "data"
                        });
                      }
                    });
                    this.tick();
                  }
                };
                _proto.onFragParsed = function onFragParsed(data) {
                  var fragCurrent = this.fragCurrent;
                  var fragNew = data.frag;
                  if (fragCurrent && data.id === "main" && fragNew.sn === fragCurrent.sn && fragNew.level === fragCurrent.level && this.state === State.PARSING) {
                    this.stats.tparsed = window.performance.now();
                    this.state = State.PARSED;
                    this._checkAppendedParsed();
                  }
                };
                _proto.onAudioTrackSwitching = function onAudioTrackSwitching(data) {
                  var fromAltAudio = this.altAudio;
                  var altAudio = !!data.url;
                  var trackId = data.id;
                  if (!altAudio) {
                    if (this.mediaBuffer !== this.media) {
                      logger["logger"].log("switching on main audio, use media.buffered to schedule main fragment loading");
                      this.mediaBuffer = this.media;
                      var fragCurrent = this.fragCurrent;
                      if (fragCurrent.loader) {
                        logger["logger"].log("switching to main audio track, cancel main fragment load");
                        fragCurrent.loader.abort();
                      }
                      this.fragCurrent = null;
                      this.fragPrevious = null;
                      if (this.demuxer) {
                        this.demuxer.destroy();
                        this.demuxer = null;
                      }
                      this.state = State.IDLE;
                    }
                    var hls = this.hls;
                    if (fromAltAudio) {
                      hls.trigger(events["default"].BUFFER_FLUSHING, {
                        startOffset: 0,
                        endOffset: Number.POSITIVE_INFINITY,
                        type: "audio"
                      });
                    }
                    hls.trigger(events["default"].AUDIO_TRACK_SWITCHED, {
                      id: trackId
                    });
                  }
                };
                _proto.onAudioTrackSwitched = function onAudioTrackSwitched(data) {
                  var trackId = data.id, altAudio = !!this.hls.audioTracks[trackId].url;
                  if (altAudio) {
                    var videoBuffer = this.videoBuffer;
                    if (videoBuffer && this.mediaBuffer !== videoBuffer) {
                      logger["logger"].log("switching on alternate audio, use video.buffered to schedule main fragment loading");
                      this.mediaBuffer = videoBuffer;
                    }
                  }
                  this.altAudio = altAudio;
                  this.tick();
                };
                _proto.onBufferCreated = function onBufferCreated(data) {
                  var tracks = data.tracks, mediaTrack, name, alternate = false;
                  for (var type in tracks) {
                    var track = tracks[type];
                    if (track.id === "main") {
                      name = type;
                      mediaTrack = track;
                      if (type === "video") {
                        this.videoBuffer = tracks[type].buffer;
                      }
                    } else {
                      alternate = true;
                    }
                  }
                  if (alternate && mediaTrack) {
                    logger["logger"].log("alternate track found, use " + name + ".buffered to schedule main fragment loading");
                    this.mediaBuffer = mediaTrack.buffer;
                  } else {
                    this.mediaBuffer = this.media;
                  }
                };
                _proto.onBufferAppended = function onBufferAppended(data) {
                  if (data.parent === "main") {
                    var state = this.state;
                    if (state === State.PARSING || state === State.PARSED) {
                      this.pendingBuffering = data.pending > 0;
                      this._checkAppendedParsed();
                    }
                  }
                };
                _proto._checkAppendedParsed = function _checkAppendedParsed() {
                  if (this.state === State.PARSED && (!this.appended || !this.pendingBuffering)) {
                    var frag = this.fragCurrent;
                    if (frag) {
                      var media = this.mediaBuffer ? this.mediaBuffer : this.media;
                      logger["logger"].log("main buffered : " + time_ranges.toString(media.buffered));
                      this.fragPrevious = frag;
                      var stats = this.stats;
                      stats.tbuffered = window.performance.now();
                      this.fragLastKbps = Math.round(8 * stats.total / (stats.tbuffered - stats.tfirst));
                      this.hls.trigger(events["default"].FRAG_BUFFERED, {
                        stats,
                        frag,
                        id: "main"
                      });
                      this.state = State.IDLE;
                    }
                    if (this.loadedmetadata || this.startPosition <= 0) {
                      this.tick();
                    }
                  }
                };
                _proto.onError = function onError(data) {
                  var frag = data.frag || this.fragCurrent;
                  if (frag && frag.type !== "main") {
                    return;
                  }
                  var mediaBuffered = !!this.media && BufferHelper.isBuffered(this.media, this.media.currentTime) && BufferHelper.isBuffered(this.media, this.media.currentTime + 0.5);
                  switch (data.details) {
                    case errors["ErrorDetails"].FRAG_LOAD_ERROR:
                    case errors["ErrorDetails"].FRAG_LOAD_TIMEOUT:
                    case errors["ErrorDetails"].KEY_LOAD_ERROR:
                    case errors["ErrorDetails"].KEY_LOAD_TIMEOUT:
                      if (!data.fatal) {
                        if (this.fragLoadError + 1 <= this.config.fragLoadingMaxRetry) {
                          var delay = Math.min(Math.pow(2, this.fragLoadError) * this.config.fragLoadingRetryDelay, this.config.fragLoadingMaxRetryTimeout);
                          logger["logger"].warn("mediaController: frag loading failed, retry in " + delay + " ms");
                          this.retryDate = window.performance.now() + delay;
                          if (!this.loadedmetadata) {
                            this.startFragRequested = false;
                            this.nextLoadPosition = this.startPosition;
                          }
                          this.fragLoadError++;
                          this.state = State.FRAG_LOADING_WAITING_RETRY;
                        } else {
                          logger["logger"].error("mediaController: " + data.details + " reaches max retry, redispatch as fatal ...");
                          data.fatal = true;
                          this.state = State.ERROR;
                        }
                      }
                      break;
                    case errors["ErrorDetails"].LEVEL_LOAD_ERROR:
                    case errors["ErrorDetails"].LEVEL_LOAD_TIMEOUT:
                      if (this.state !== State.ERROR) {
                        if (data.fatal) {
                          this.state = State.ERROR;
                          logger["logger"].warn("streamController: " + data.details + ",switch to " + this.state + " state ...");
                        } else {
                          if (!data.levelRetry && this.state === State.WAITING_LEVEL) {
                            this.state = State.IDLE;
                          }
                        }
                      }
                      break;
                    case errors["ErrorDetails"].BUFFER_FULL_ERROR:
                      if (data.parent === "main" && (this.state === State.PARSING || this.state === State.PARSED)) {
                        if (mediaBuffered) {
                          this._reduceMaxBufferLength(this.config.maxBufferLength);
                          this.state = State.IDLE;
                        } else {
                          logger["logger"].warn("buffer full error also media.currentTime is not buffered, flush everything");
                          this.fragCurrent = null;
                          this.flushMainBuffer(0, Number.POSITIVE_INFINITY);
                        }
                      }
                      break;
                    default:
                      break;
                  }
                };
                _proto._reduceMaxBufferLength = function _reduceMaxBufferLength(minLength) {
                  var config = this.config;
                  if (config.maxMaxBufferLength >= minLength) {
                    config.maxMaxBufferLength /= 2;
                    logger["logger"].warn("main:reduce max buffer length to " + config.maxMaxBufferLength + "s");
                    return true;
                  }
                  return false;
                };
                _proto._checkBuffer = function _checkBuffer() {
                  var media = this.media;
                  if (!media || media.readyState === 0) {
                    return;
                  }
                  var mediaBuffer = this.mediaBuffer ? this.mediaBuffer : media;
                  var buffered = mediaBuffer.buffered;
                  if (!this.loadedmetadata && buffered.length) {
                    this.loadedmetadata = true;
                    this._seekToStartPos();
                  } else if (this.immediateSwitch) {
                    this.immediateLevelSwitchEnd();
                  } else {
                    this.gapController.poll(this.lastCurrentTime, buffered);
                  }
                };
                _proto.onFragLoadEmergencyAborted = function onFragLoadEmergencyAborted() {
                  this.state = State.IDLE;
                  if (!this.loadedmetadata) {
                    this.startFragRequested = false;
                    this.nextLoadPosition = this.startPosition;
                  }
                  this.tick();
                };
                _proto.onBufferFlushed = function onBufferFlushed() {
                  var media = this.mediaBuffer ? this.mediaBuffer : this.media;
                  if (media) {
                    var elementaryStreamType = this.audioOnly ? ElementaryStreamTypes.AUDIO : ElementaryStreamTypes.VIDEO;
                    this.fragmentTracker.detectEvictedFragments(elementaryStreamType, media.buffered);
                  }
                  this.state = State.IDLE;
                  this.fragPrevious = null;
                };
                _proto.onLevelsUpdated = function onLevelsUpdated(data) {
                  this.levels = data.levels;
                };
                _proto.swapAudioCodec = function swapAudioCodec() {
                  this.audioCodecSwap = !this.audioCodecSwap;
                };
                _proto._seekToStartPos = function _seekToStartPos() {
                  var media = this.media;
                  var currentTime = media.currentTime;
                  var startPosition = this.startPosition;
                  if (currentTime !== startPosition && startPosition >= 0) {
                    if (media.seeking) {
                      logger["logger"].log("could not seek to " + startPosition + ", already seeking at " + currentTime);
                      return;
                    }
                    var bufferStart = media.buffered.length ? media.buffered.start(0) : 0;
                    var delta = bufferStart - startPosition;
                    if (delta > 0 && delta < this.config.maxBufferHole) {
                      logger["logger"].log("adjusting start position by " + delta + " to match buffer start");
                      startPosition += delta;
                      this.startPosition = startPosition;
                    }
                    logger["logger"].log("seek to target start position " + startPosition + " from current time " + currentTime + ". ready state " + media.readyState);
                    media.currentTime = startPosition;
                  }
                };
                _proto._getAudioCodec = function _getAudioCodec(currentLevel) {
                  var audioCodec = this.config.defaultAudioCodec || currentLevel.audioCodec;
                  if (this.audioCodecSwap) {
                    logger["logger"].log("swapping playlist audio codec");
                    if (audioCodec) {
                      if (audioCodec.indexOf("mp4a.40.5") !== -1) {
                        audioCodec = "mp4a.40.2";
                      } else {
                        audioCodec = "mp4a.40.5";
                      }
                    }
                  }
                  return audioCodec;
                };
                stream_controller_createClass(StreamController, [{
                  key: "state",
                  set: function set(nextState) {
                    if (this.state !== nextState) {
                      var previousState = this.state;
                      this._state = nextState;
                      logger["logger"].log("main stream-controller: " + previousState + "->" + nextState);
                      this.hls.trigger(events["default"].STREAM_STATE_TRANSITION, {
                        previousState,
                        nextState
                      });
                    }
                  },
                  get: function get() {
                    return this._state;
                  }
                }, {
                  key: "currentLevel",
                  get: function get() {
                    var media = this.media;
                    if (media) {
                      var frag = this.getBufferedFrag(media.currentTime);
                      if (frag) {
                        return frag.level;
                      }
                    }
                    return -1;
                  }
                }, {
                  key: "nextBufferedFrag",
                  get: function get() {
                    var media = this.media;
                    if (media) {
                      return this.followingBufferedFrag(this.getBufferedFrag(media.currentTime));
                    } else {
                      return null;
                    }
                  }
                }, {
                  key: "nextLevel",
                  get: function get() {
                    var frag = this.nextBufferedFrag;
                    if (frag) {
                      return frag.level;
                    } else {
                      return -1;
                    }
                  }
                }, {
                  key: "liveSyncPosition",
                  get: function get() {
                    return this._liveSyncPosition;
                  },
                  set: function set(value) {
                    this._liveSyncPosition = value;
                  }
                }]);
                return StreamController;
              }(base_stream_controller_BaseStreamController);
              var stream_controller = stream_controller_StreamController;
              function level_controller_defineProperties(target, props) {
                for (var i = 0; i < props.length; i++) {
                  var descriptor = props[i];
                  descriptor.enumerable = descriptor.enumerable || false;
                  descriptor.configurable = true;
                  if ("value" in descriptor)
                    descriptor.writable = true;
                  Object.defineProperty(target, descriptor.key, descriptor);
                }
              }
              function level_controller_createClass(Constructor, protoProps, staticProps) {
                if (protoProps)
                  level_controller_defineProperties(Constructor.prototype, protoProps);
                if (staticProps)
                  level_controller_defineProperties(Constructor, staticProps);
                return Constructor;
              }
              function level_controller_inheritsLoose(subClass, superClass) {
                subClass.prototype = Object.create(superClass.prototype);
                subClass.prototype.constructor = subClass;
                subClass.__proto__ = superClass;
              }
              var chromeOrFirefox;
              var level_controller_LevelController = function(_EventHandler) {
                level_controller_inheritsLoose(LevelController, _EventHandler);
                function LevelController(hls) {
                  var _this;
                  _this = _EventHandler.call(this, hls, events["default"].MANIFEST_LOADED, events["default"].LEVEL_LOADED, events["default"].AUDIO_TRACK_SWITCHED, events["default"].FRAG_LOADED, events["default"].ERROR) || this;
                  _this.canload = false;
                  _this.currentLevelIndex = null;
                  _this.manualLevelIndex = -1;
                  _this.timer = null;
                  chromeOrFirefox = /chrome|firefox/.test(navigator.userAgent.toLowerCase());
                  return _this;
                }
                var _proto = LevelController.prototype;
                _proto.onHandlerDestroying = function onHandlerDestroying() {
                  this.clearTimer();
                  this.manualLevelIndex = -1;
                };
                _proto.clearTimer = function clearTimer() {
                  if (this.timer !== null) {
                    clearTimeout(this.timer);
                    this.timer = null;
                  }
                };
                _proto.startLoad = function startLoad() {
                  var levels = this._levels;
                  this.canload = true;
                  this.levelRetryCount = 0;
                  if (levels) {
                    levels.forEach(function(level) {
                      level.loadError = 0;
                      var levelDetails = level.details;
                      if (levelDetails && levelDetails.live) {
                        level.details = void 0;
                      }
                    });
                  }
                  if (this.timer !== null) {
                    this.loadLevel();
                  }
                };
                _proto.stopLoad = function stopLoad() {
                  this.canload = false;
                };
                _proto.onManifestLoaded = function onManifestLoaded(data) {
                  var levels = [];
                  var audioTracks = [];
                  var bitrateStart;
                  var levelSet = {};
                  var levelFromSet = null;
                  var videoCodecFound = false;
                  var audioCodecFound = false;
                  data.levels.forEach(function(level) {
                    var attributes = level.attrs;
                    level.loadError = 0;
                    level.fragmentError = false;
                    videoCodecFound = videoCodecFound || !!level.videoCodec;
                    audioCodecFound = audioCodecFound || !!level.audioCodec;
                    if (chromeOrFirefox && level.audioCodec && level.audioCodec.indexOf("mp4a.40.34") !== -1) {
                      level.audioCodec = void 0;
                    }
                    levelFromSet = levelSet[level.bitrate];
                    if (!levelFromSet) {
                      level.url = [level.url];
                      level.urlId = 0;
                      levelSet[level.bitrate] = level;
                      levels.push(level);
                    } else {
                      levelFromSet.url.push(level.url);
                    }
                    if (attributes) {
                      if (attributes.AUDIO) {
                        addGroupId(levelFromSet || level, "audio", attributes.AUDIO);
                      }
                      if (attributes.SUBTITLES) {
                        addGroupId(levelFromSet || level, "text", attributes.SUBTITLES);
                      }
                    }
                  });
                  if (videoCodecFound && audioCodecFound) {
                    levels = levels.filter(function(_ref) {
                      var videoCodec = _ref.videoCodec;
                      return !!videoCodec;
                    });
                  }
                  levels = levels.filter(function(_ref2) {
                    var audioCodec = _ref2.audioCodec, videoCodec = _ref2.videoCodec;
                    return (!audioCodec || isCodecSupportedInMp4(audioCodec, "audio")) && (!videoCodec || isCodecSupportedInMp4(videoCodec, "video"));
                  });
                  if (data.audioTracks) {
                    audioTracks = data.audioTracks.filter(function(track) {
                      return !track.audioCodec || isCodecSupportedInMp4(track.audioCodec, "audio");
                    });
                    audioTracks.forEach(function(track, index) {
                      track.id = index;
                    });
                  }
                  if (levels.length > 0) {
                    bitrateStart = levels[0].bitrate;
                    levels.sort(function(a, b) {
                      return a.bitrate - b.bitrate;
                    });
                    this._levels = levels;
                    for (var i = 0; i < levels.length; i++) {
                      if (levels[i].bitrate === bitrateStart) {
                        this._firstLevel = i;
                        logger["logger"].log("manifest loaded," + levels.length + " level(s) found, first bitrate:" + bitrateStart);
                        break;
                      }
                    }
                    var audioOnly = audioCodecFound && !videoCodecFound;
                    this.hls.trigger(events["default"].MANIFEST_PARSED, {
                      levels,
                      audioTracks,
                      firstLevel: this._firstLevel,
                      stats: data.stats,
                      audio: audioCodecFound,
                      video: videoCodecFound,
                      altAudio: !audioOnly && audioTracks.some(function(t) {
                        return !!t.url;
                      })
                    });
                  } else {
                    this.hls.trigger(events["default"].ERROR, {
                      type: errors["ErrorTypes"].MEDIA_ERROR,
                      details: errors["ErrorDetails"].MANIFEST_INCOMPATIBLE_CODECS_ERROR,
                      fatal: true,
                      url: this.hls.url,
                      reason: "no level with compatible codecs found in manifest"
                    });
                  }
                };
                _proto.setLevelInternal = function setLevelInternal(newLevel) {
                  var levels = this._levels;
                  var hls = this.hls;
                  if (newLevel >= 0 && newLevel < levels.length) {
                    this.clearTimer();
                    if (this.currentLevelIndex !== newLevel) {
                      logger["logger"].log("switching to level " + newLevel);
                      this.currentLevelIndex = newLevel;
                      var levelProperties = levels[newLevel];
                      levelProperties.level = newLevel;
                      hls.trigger(events["default"].LEVEL_SWITCHING, levelProperties);
                    }
                    var level = levels[newLevel];
                    var levelDetails = level.details;
                    if (!levelDetails || levelDetails.live) {
                      var urlId = level.urlId;
                      hls.trigger(events["default"].LEVEL_LOADING, {
                        url: level.url[urlId],
                        level: newLevel,
                        id: urlId
                      });
                    }
                  } else {
                    hls.trigger(events["default"].ERROR, {
                      type: errors["ErrorTypes"].OTHER_ERROR,
                      details: errors["ErrorDetails"].LEVEL_SWITCH_ERROR,
                      level: newLevel,
                      fatal: false,
                      reason: "invalid level idx"
                    });
                  }
                };
                _proto.onError = function onError(data) {
                  if (data.fatal) {
                    if (data.type === errors["ErrorTypes"].NETWORK_ERROR) {
                      this.clearTimer();
                    }
                    return;
                  }
                  var levelError = false, fragmentError = false;
                  var levelIndex;
                  switch (data.details) {
                    case errors["ErrorDetails"].FRAG_LOAD_ERROR:
                    case errors["ErrorDetails"].FRAG_LOAD_TIMEOUT:
                    case errors["ErrorDetails"].KEY_LOAD_ERROR:
                    case errors["ErrorDetails"].KEY_LOAD_TIMEOUT:
                      levelIndex = data.frag.level;
                      fragmentError = true;
                      break;
                    case errors["ErrorDetails"].LEVEL_LOAD_ERROR:
                    case errors["ErrorDetails"].LEVEL_LOAD_TIMEOUT:
                      levelIndex = data.context.level;
                      levelError = true;
                      break;
                    case errors["ErrorDetails"].REMUX_ALLOC_ERROR:
                      levelIndex = data.level;
                      levelError = true;
                      break;
                  }
                  if (levelIndex !== void 0) {
                    this.recoverLevel(data, levelIndex, levelError, fragmentError);
                  }
                };
                _proto.recoverLevel = function recoverLevel(errorEvent, levelIndex, levelError, fragmentError) {
                  var _this2 = this;
                  var config = this.hls.config;
                  var errorDetails = errorEvent.details;
                  var level = this._levels[levelIndex];
                  var redundantLevels, delay, nextLevel;
                  level.loadError++;
                  level.fragmentError = fragmentError;
                  if (levelError) {
                    if (this.levelRetryCount + 1 <= config.levelLoadingMaxRetry) {
                      delay = Math.min(Math.pow(2, this.levelRetryCount) * config.levelLoadingRetryDelay, config.levelLoadingMaxRetryTimeout);
                      this.timer = setTimeout(function() {
                        return _this2.loadLevel();
                      }, delay);
                      errorEvent.levelRetry = true;
                      this.levelRetryCount++;
                      logger["logger"].warn("level controller, " + errorDetails + ", retry in " + delay + " ms, current retry count is " + this.levelRetryCount);
                    } else {
                      logger["logger"].error("level controller, cannot recover from " + errorDetails + " error");
                      this.currentLevelIndex = null;
                      this.clearTimer();
                      errorEvent.fatal = true;
                      return;
                    }
                  }
                  if (levelError || fragmentError) {
                    redundantLevels = level.url.length;
                    if (redundantLevels > 1 && level.loadError < redundantLevels) {
                      level.urlId = (level.urlId + 1) % redundantLevels;
                      level.details = void 0;
                      logger["logger"].warn("level controller, " + errorDetails + " for level " + levelIndex + ": switching to redundant URL-id " + level.urlId);
                    } else {
                      if (this.manualLevelIndex === -1) {
                        nextLevel = levelIndex === 0 ? this._levels.length - 1 : levelIndex - 1;
                        logger["logger"].warn("level controller, " + errorDetails + ": switch to " + nextLevel);
                        this.hls.nextAutoLevel = this.currentLevelIndex = nextLevel;
                      } else if (fragmentError) {
                        logger["logger"].warn("level controller, " + errorDetails + ": reload a fragment");
                        this.currentLevelIndex = null;
                      }
                    }
                  }
                };
                _proto.onFragLoaded = function onFragLoaded(_ref3) {
                  var frag = _ref3.frag;
                  if (frag !== void 0 && frag.type === "main") {
                    var level = this._levels[frag.level];
                    if (level !== void 0) {
                      level.fragmentError = false;
                      level.loadError = 0;
                      this.levelRetryCount = 0;
                    }
                  }
                };
                _proto.onLevelLoaded = function onLevelLoaded(data) {
                  var _this3 = this;
                  var level = data.level, details = data.details;
                  if (level !== this.currentLevelIndex) {
                    return;
                  }
                  var curLevel = this._levels[level];
                  if (!curLevel.fragmentError) {
                    curLevel.loadError = 0;
                    this.levelRetryCount = 0;
                  }
                  if (details.live) {
                    var reloadInterval = computeReloadInterval(curLevel.details, details, data.stats.trequest);
                    logger["logger"].log("live playlist, reload in " + Math.round(reloadInterval) + " ms");
                    this.timer = setTimeout(function() {
                      return _this3.loadLevel();
                    }, reloadInterval);
                  } else {
                    this.clearTimer();
                  }
                };
                _proto.onAudioTrackSwitched = function onAudioTrackSwitched(data) {
                  var audioGroupId = this.hls.audioTracks[data.id].groupId;
                  var currentLevel = this.hls.levels[this.currentLevelIndex];
                  if (!currentLevel) {
                    return;
                  }
                  if (currentLevel.audioGroupIds) {
                    var urlId = -1;
                    for (var i = 0; i < currentLevel.audioGroupIds.length; i++) {
                      if (currentLevel.audioGroupIds[i] === audioGroupId) {
                        urlId = i;
                        break;
                      }
                    }
                    if (urlId !== currentLevel.urlId) {
                      currentLevel.urlId = urlId;
                      this.startLoad();
                    }
                  }
                };
                _proto.loadLevel = function loadLevel() {
                  logger["logger"].debug("call to loadLevel");
                  if (this.currentLevelIndex !== null && this.canload) {
                    var levelObject = this._levels[this.currentLevelIndex];
                    if (typeof levelObject === "object" && levelObject.url.length > 0) {
                      var level = this.currentLevelIndex;
                      var id = levelObject.urlId;
                      var url = levelObject.url[id];
                      logger["logger"].log("Attempt loading level index " + level + " with URL-id " + id);
                      this.hls.trigger(events["default"].LEVEL_LOADING, {
                        url,
                        level,
                        id
                      });
                    }
                  }
                };
                _proto.removeLevel = function removeLevel(levelIndex, urlId) {
                  var levels = this.levels.filter(function(level, index) {
                    if (index !== levelIndex) {
                      return true;
                    }
                    if (level.url.length > 1 && urlId !== void 0) {
                      level.url = level.url.filter(function(url, id) {
                        return id !== urlId;
                      });
                      level.urlId = 0;
                      return true;
                    }
                    return false;
                  }).map(function(level, index) {
                    var details = level.details;
                    if (details && details.fragments) {
                      details.fragments.forEach(function(fragment) {
                        fragment.level = index;
                      });
                    }
                    return level;
                  });
                  this._levels = levels;
                  this.hls.trigger(events["default"].LEVELS_UPDATED, {
                    levels
                  });
                };
                level_controller_createClass(LevelController, [{
                  key: "levels",
                  get: function get() {
                    return this._levels;
                  }
                }, {
                  key: "level",
                  get: function get() {
                    return this.currentLevelIndex;
                  },
                  set: function set(newLevel) {
                    var levels = this._levels;
                    if (levels) {
                      newLevel = Math.min(newLevel, levels.length - 1);
                      if (this.currentLevelIndex !== newLevel || !levels[newLevel].details) {
                        this.setLevelInternal(newLevel);
                      }
                    }
                  }
                }, {
                  key: "manualLevel",
                  get: function get() {
                    return this.manualLevelIndex;
                  },
                  set: function set(newLevel) {
                    this.manualLevelIndex = newLevel;
                    if (this._startLevel === void 0) {
                      this._startLevel = newLevel;
                    }
                    if (newLevel !== -1) {
                      this.level = newLevel;
                    }
                  }
                }, {
                  key: "firstLevel",
                  get: function get() {
                    return this._firstLevel;
                  },
                  set: function set(newLevel) {
                    this._firstLevel = newLevel;
                  }
                }, {
                  key: "startLevel",
                  get: function get() {
                    if (this._startLevel === void 0) {
                      var configStartLevel = this.hls.config.startLevel;
                      if (configStartLevel !== void 0) {
                        return configStartLevel;
                      } else {
                        return this._firstLevel;
                      }
                    } else {
                      return this._startLevel;
                    }
                  },
                  set: function set(newLevel) {
                    this._startLevel = newLevel;
                  }
                }, {
                  key: "nextLoadLevel",
                  get: function get() {
                    if (this.manualLevelIndex !== -1) {
                      return this.manualLevelIndex;
                    } else {
                      return this.hls.nextAutoLevel;
                    }
                  },
                  set: function set(nextLevel) {
                    this.level = nextLevel;
                    if (this.manualLevelIndex === -1) {
                      this.hls.nextAutoLevel = nextLevel;
                    }
                  }
                }]);
                return LevelController;
              }(event_handler);
              var id3 = __webpack_require__("./src/demux/id3.js");
              function sendAddTrackEvent(track, videoEl) {
                var event;
                try {
                  event = new Event("addtrack");
                } catch (err) {
                  event = document.createEvent("Event");
                  event.initEvent("addtrack", false, false);
                }
                event.track = track;
                videoEl.dispatchEvent(event);
              }
              function clearCurrentCues(track) {
                if (track === null || track === void 0 ? void 0 : track.cues) {
                  while (track.cues.length > 0) {
                    track.removeCue(track.cues[0]);
                  }
                }
              }
              function getClosestCue(cues, time) {
                if (time < cues[0].endTime) {
                  return cues[0];
                }
                if (time > cues[cues.length - 1].endTime) {
                  return cues[cues.length - 1];
                }
                var left = 0;
                var right = cues.length - 1;
                while (left <= right) {
                  var mid = Math.floor((right + left) / 2);
                  if (time < cues[mid].endTime) {
                    right = mid - 1;
                  } else if (time > cues[mid].endTime) {
                    left = mid + 1;
                  } else {
                    return cues[mid];
                  }
                }
                return cues[left].endTime - time < time - cues[right].endTime ? cues[left] : cues[right];
              }
              function id3_track_controller_inheritsLoose(subClass, superClass) {
                subClass.prototype = Object.create(superClass.prototype);
                subClass.prototype.constructor = subClass;
                subClass.__proto__ = superClass;
              }
              var MIN_CUE_DURATION = 0.25;
              var id3_track_controller_ID3TrackController = function(_EventHandler) {
                id3_track_controller_inheritsLoose(ID3TrackController, _EventHandler);
                function ID3TrackController(hls) {
                  var _this;
                  _this = _EventHandler.call(this, hls, events["default"].MEDIA_ATTACHED, events["default"].MEDIA_DETACHING, events["default"].FRAG_PARSING_METADATA, events["default"].LIVE_BACK_BUFFER_REACHED) || this;
                  _this.id3Track = void 0;
                  _this.media = void 0;
                  return _this;
                }
                var _proto = ID3TrackController.prototype;
                _proto.destroy = function destroy() {
                  event_handler.prototype.destroy.call(this);
                };
                _proto.onMediaAttached = function onMediaAttached(data) {
                  this.media = data.media;
                  if (!this.media) {
                  }
                };
                _proto.onMediaDetaching = function onMediaDetaching() {
                  clearCurrentCues(this.id3Track);
                  this.id3Track = void 0;
                  this.media = void 0;
                };
                _proto.getID3Track = function getID3Track(textTracks) {
                  for (var i = 0; i < textTracks.length; i++) {
                    var textTrack = textTracks[i];
                    if (textTrack.kind === "metadata" && textTrack.label === "id3") {
                      sendAddTrackEvent(textTrack, this.media);
                      return textTrack;
                    }
                  }
                  return this.media.addTextTrack("metadata", "id3");
                };
                _proto.onFragParsingMetadata = function onFragParsingMetadata(data) {
                  var fragment = data.frag;
                  var samples = data.samples;
                  if (!this.id3Track) {
                    this.id3Track = this.getID3Track(this.media.textTracks);
                    this.id3Track.mode = "hidden";
                  }
                  var Cue = window.WebKitDataCue || window.VTTCue || window.TextTrackCue;
                  for (var i = 0; i < samples.length; i++) {
                    var frames = id3["default"].getID3Frames(samples[i].data);
                    if (frames) {
                      var startTime = Math.max(samples[i].pts, 0);
                      var endTime = i < samples.length - 1 ? samples[i + 1].pts : fragment.endPTS;
                      if (!endTime) {
                        endTime = fragment.start + fragment.duration;
                      }
                      var timeDiff = endTime - startTime;
                      if (timeDiff <= 0) {
                        endTime = startTime + MIN_CUE_DURATION;
                      }
                      for (var j = 0; j < frames.length; j++) {
                        var frame = frames[j];
                        if (!id3["default"].isTimeStampFrame(frame)) {
                          var cue = new Cue(startTime, endTime, "");
                          cue.value = frame;
                          this.id3Track.addCue(cue);
                        }
                      }
                    }
                  }
                };
                _proto.onLiveBackBufferReached = function onLiveBackBufferReached(_ref) {
                  var bufferEnd = _ref.bufferEnd;
                  var id3Track = this.id3Track;
                  if (!id3Track || !id3Track.cues || !id3Track.cues.length) {
                    return;
                  }
                  var foundCue = getClosestCue(id3Track.cues, bufferEnd);
                  if (!foundCue) {
                    return;
                  }
                  while (id3Track.cues[0] !== foundCue) {
                    id3Track.removeCue(id3Track.cues[0]);
                  }
                };
                return ID3TrackController;
              }(event_handler);
              var id3_track_controller = id3_track_controller_ID3TrackController;
              function is_supported_isSupported() {
                var mediaSource = getMediaSource();
                if (!mediaSource) {
                  return false;
                }
                var sourceBuffer = self.SourceBuffer || self.WebKitSourceBuffer;
                var isTypeSupported = mediaSource && typeof mediaSource.isTypeSupported === "function" && mediaSource.isTypeSupported('video/mp4; codecs="avc1.42E01E,mp4a.40.2"');
                var sourceBufferValidAPI = !sourceBuffer || sourceBuffer.prototype && typeof sourceBuffer.prototype.appendBuffer === "function" && typeof sourceBuffer.prototype.remove === "function";
                return !!isTypeSupported && !!sourceBufferValidAPI;
              }
              var EWMA = function() {
                function EWMA2(halfLife) {
                  this.alpha_ = void 0;
                  this.estimate_ = void 0;
                  this.totalWeight_ = void 0;
                  this.alpha_ = halfLife ? Math.exp(Math.log(0.5) / halfLife) : 0;
                  this.estimate_ = 0;
                  this.totalWeight_ = 0;
                }
                var _proto = EWMA2.prototype;
                _proto.sample = function sample(weight, value) {
                  var adjAlpha = Math.pow(this.alpha_, weight);
                  this.estimate_ = value * (1 - adjAlpha) + adjAlpha * this.estimate_;
                  this.totalWeight_ += weight;
                };
                _proto.getTotalWeight = function getTotalWeight() {
                  return this.totalWeight_;
                };
                _proto.getEstimate = function getEstimate() {
                  if (this.alpha_) {
                    var zeroFactor = 1 - Math.pow(this.alpha_, this.totalWeight_);
                    return this.estimate_ / zeroFactor;
                  } else {
                    return this.estimate_;
                  }
                };
                return EWMA2;
              }();
              var ewma = EWMA;
              var ewma_bandwidth_estimator_EwmaBandWidthEstimator = function() {
                function EwmaBandWidthEstimator(hls, slow, fast, defaultEstimate) {
                  this.hls = void 0;
                  this.defaultEstimate_ = void 0;
                  this.minWeight_ = void 0;
                  this.minDelayMs_ = void 0;
                  this.slow_ = void 0;
                  this.fast_ = void 0;
                  this.hls = hls;
                  this.defaultEstimate_ = defaultEstimate;
                  this.minWeight_ = 1e-3;
                  this.minDelayMs_ = 50;
                  this.slow_ = new ewma(slow);
                  this.fast_ = new ewma(fast);
                }
                var _proto = EwmaBandWidthEstimator.prototype;
                _proto.sample = function sample(durationMs, numBytes) {
                  durationMs = Math.max(durationMs, this.minDelayMs_);
                  var numBits = 8 * numBytes, durationS = durationMs / 1e3, bandwidthInBps = numBits / durationS;
                  this.fast_.sample(durationS, bandwidthInBps);
                  this.slow_.sample(durationS, bandwidthInBps);
                };
                _proto.canEstimate = function canEstimate() {
                  var fast = this.fast_;
                  return fast && fast.getTotalWeight() >= this.minWeight_;
                };
                _proto.getEstimate = function getEstimate() {
                  if (this.canEstimate()) {
                    return Math.min(this.fast_.getEstimate(), this.slow_.getEstimate());
                  } else {
                    return this.defaultEstimate_;
                  }
                };
                _proto.destroy = function destroy() {
                };
                return EwmaBandWidthEstimator;
              }();
              var ewma_bandwidth_estimator = ewma_bandwidth_estimator_EwmaBandWidthEstimator;
              function abr_controller_defineProperties(target, props) {
                for (var i = 0; i < props.length; i++) {
                  var descriptor = props[i];
                  descriptor.enumerable = descriptor.enumerable || false;
                  descriptor.configurable = true;
                  if ("value" in descriptor)
                    descriptor.writable = true;
                  Object.defineProperty(target, descriptor.key, descriptor);
                }
              }
              function abr_controller_createClass(Constructor, protoProps, staticProps) {
                if (protoProps)
                  abr_controller_defineProperties(Constructor.prototype, protoProps);
                if (staticProps)
                  abr_controller_defineProperties(Constructor, staticProps);
                return Constructor;
              }
              function abr_controller_assertThisInitialized(self2) {
                if (self2 === void 0) {
                  throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                }
                return self2;
              }
              function abr_controller_inheritsLoose(subClass, superClass) {
                subClass.prototype = Object.create(superClass.prototype);
                subClass.prototype.constructor = subClass;
                subClass.__proto__ = superClass;
              }
              var abr_controller_window = window, abr_controller_performance = abr_controller_window.performance;
              var abr_controller_AbrController = function(_EventHandler) {
                abr_controller_inheritsLoose(AbrController, _EventHandler);
                function AbrController(hls) {
                  var _this;
                  _this = _EventHandler.call(this, hls, events["default"].FRAG_LOADING, events["default"].FRAG_LOADED, events["default"].FRAG_BUFFERED, events["default"].ERROR) || this;
                  _this.lastLoadedFragLevel = 0;
                  _this._nextAutoLevel = -1;
                  _this.hls = hls;
                  _this.timer = null;
                  _this._bwEstimator = null;
                  _this.onCheck = _this._abandonRulesCheck.bind(abr_controller_assertThisInitialized(_this));
                  return _this;
                }
                var _proto = AbrController.prototype;
                _proto.destroy = function destroy() {
                  this.clearTimer();
                  event_handler.prototype.destroy.call(this);
                };
                _proto.onFragLoading = function onFragLoading(data) {
                  var frag = data.frag;
                  if (frag.type === "main") {
                    if (!this.timer) {
                      this.fragCurrent = frag;
                      this.timer = setInterval(this.onCheck, 100);
                    }
                    if (!this._bwEstimator) {
                      var hls = this.hls;
                      var config = hls.config;
                      var level = frag.level;
                      var isLive = hls.levels[level].details.live;
                      var ewmaFast;
                      var ewmaSlow;
                      if (isLive) {
                        ewmaFast = config.abrEwmaFastLive;
                        ewmaSlow = config.abrEwmaSlowLive;
                      } else {
                        ewmaFast = config.abrEwmaFastVoD;
                        ewmaSlow = config.abrEwmaSlowVoD;
                      }
                      this._bwEstimator = new ewma_bandwidth_estimator(hls, ewmaSlow, ewmaFast, config.abrEwmaDefaultEstimate);
                    }
                  }
                };
                _proto._abandonRulesCheck = function _abandonRulesCheck() {
                  var hls = this.hls;
                  var video = hls.media;
                  var frag = this.fragCurrent;
                  if (!frag) {
                    return;
                  }
                  var loader = frag.loader;
                  if (!loader || loader.stats && loader.stats.aborted) {
                    logger["logger"].warn("frag loader destroy or aborted, disarm abandonRules");
                    this.clearTimer();
                    this._nextAutoLevel = -1;
                    return;
                  }
                  var stats = loader.stats;
                  if (video && stats && (!video.paused && video.playbackRate !== 0 || !video.readyState) && frag.autoLevel && frag.level) {
                    var requestDelay = abr_controller_performance.now() - stats.trequest;
                    var playbackRate = Math.abs(video.playbackRate);
                    if (requestDelay > 500 * frag.duration / playbackRate) {
                      var levels = hls.levels;
                      var loadRate = Math.max(1, stats.bw ? stats.bw / 8 : stats.loaded * 1e3 / requestDelay);
                      var level = levels[frag.level];
                      if (!level) {
                        return;
                      }
                      var levelBitrate = level.realBitrate ? Math.max(level.realBitrate, level.bitrate) : level.bitrate;
                      var expectedLen = stats.total ? stats.total : Math.max(stats.loaded, Math.round(frag.duration * levelBitrate / 8));
                      var pos = video.currentTime;
                      var fragLoadedDelay = (expectedLen - stats.loaded) / loadRate;
                      var bufferStarvationDelay = (BufferHelper.bufferInfo(video, pos, hls.config.maxBufferHole).end - pos) / playbackRate;
                      if (bufferStarvationDelay < 2 * frag.duration / playbackRate && fragLoadedDelay > bufferStarvationDelay) {
                        var minAutoLevel = hls.minAutoLevel;
                        var fragLevelNextLoadedDelay;
                        var nextLoadLevel;
                        for (nextLoadLevel = frag.level - 1; nextLoadLevel > minAutoLevel; nextLoadLevel--) {
                          var levelNextBitrate = levels[nextLoadLevel].realBitrate ? Math.max(levels[nextLoadLevel].realBitrate, levels[nextLoadLevel].bitrate) : levels[nextLoadLevel].bitrate;
                          var _fragLevelNextLoadedDelay = frag.duration * levelNextBitrate / (8 * 0.8 * loadRate);
                          if (_fragLevelNextLoadedDelay < bufferStarvationDelay) {
                            break;
                          }
                        }
                        if (fragLevelNextLoadedDelay < fragLoadedDelay) {
                          logger["logger"].warn("loading too slow, abort fragment loading and switch to level " + nextLoadLevel + ":fragLoadedDelay[" + nextLoadLevel + "]<fragLoadedDelay[" + (frag.level - 1) + "];bufferStarvationDelay:" + fragLevelNextLoadedDelay.toFixed(1) + "<" + fragLoadedDelay.toFixed(1) + ":" + bufferStarvationDelay.toFixed(1));
                          hls.nextLoadLevel = nextLoadLevel;
                          this._bwEstimator.sample(requestDelay, stats.loaded);
                          loader.abort();
                          this.clearTimer();
                          hls.trigger(events["default"].FRAG_LOAD_EMERGENCY_ABORTED, {
                            frag,
                            stats
                          });
                        }
                      }
                    }
                  }
                };
                _proto.onFragLoaded = function onFragLoaded(data) {
                  var frag = data.frag;
                  if (frag.type === "main" && Object(number["isFiniteNumber"])(frag.sn)) {
                    this.clearTimer();
                    this.lastLoadedFragLevel = frag.level;
                    this._nextAutoLevel = -1;
                    if (this.hls.config.abrMaxWithRealBitrate) {
                      var level = this.hls.levels[frag.level];
                      var loadedBytes = (level.loaded ? level.loaded.bytes : 0) + data.stats.loaded;
                      var loadedDuration = (level.loaded ? level.loaded.duration : 0) + data.frag.duration;
                      level.loaded = {
                        bytes: loadedBytes,
                        duration: loadedDuration
                      };
                      level.realBitrate = Math.round(8 * loadedBytes / loadedDuration);
                    }
                    if (data.frag.bitrateTest) {
                      var stats = data.stats;
                      stats.tparsed = stats.tbuffered = stats.tload;
                      this.onFragBuffered(data);
                    }
                  }
                };
                _proto.onFragBuffered = function onFragBuffered(data) {
                  var stats = data.stats;
                  var frag = data.frag;
                  if (stats.aborted !== true && frag.type === "main" && Object(number["isFiniteNumber"])(frag.sn) && (!frag.bitrateTest || stats.tload === stats.tbuffered)) {
                    var fragLoadingProcessingMs = stats.tparsed - stats.trequest;
                    logger["logger"].log("latency/loading/parsing/append/kbps:" + Math.round(stats.tfirst - stats.trequest) + "/" + Math.round(stats.tload - stats.tfirst) + "/" + Math.round(stats.tparsed - stats.tload) + "/" + Math.round(stats.tbuffered - stats.tparsed) + "/" + Math.round(8 * stats.loaded / (stats.tbuffered - stats.trequest)));
                    this._bwEstimator.sample(fragLoadingProcessingMs, stats.loaded);
                    stats.bwEstimate = this._bwEstimator.getEstimate();
                    if (frag.bitrateTest) {
                      this.bitrateTestDelay = fragLoadingProcessingMs / 1e3;
                    } else {
                      this.bitrateTestDelay = 0;
                    }
                  }
                };
                _proto.onError = function onError(data) {
                  switch (data.details) {
                    case errors["ErrorDetails"].FRAG_LOAD_ERROR:
                    case errors["ErrorDetails"].FRAG_LOAD_TIMEOUT:
                      this.clearTimer();
                      break;
                    default:
                      break;
                  }
                };
                _proto.clearTimer = function clearTimer() {
                  clearInterval(this.timer);
                  this.timer = null;
                };
                _proto._findBestLevel = function _findBestLevel(currentLevel, currentFragDuration, currentBw, minAutoLevel, maxAutoLevel, maxFetchDuration, bwFactor, bwUpFactor, levels) {
                  for (var i = maxAutoLevel; i >= minAutoLevel; i--) {
                    var levelInfo = levels[i];
                    if (!levelInfo) {
                      continue;
                    }
                    var levelDetails = levelInfo.details;
                    var avgDuration = levelDetails ? levelDetails.totalduration / levelDetails.fragments.length : currentFragDuration;
                    var live = levelDetails ? levelDetails.live : false;
                    var adjustedbw = void 0;
                    if (i <= currentLevel) {
                      adjustedbw = bwFactor * currentBw;
                    } else {
                      adjustedbw = bwUpFactor * currentBw;
                    }
                    var bitrate = levels[i].realBitrate ? Math.max(levels[i].realBitrate, levels[i].bitrate) : levels[i].bitrate;
                    var fetchDuration = bitrate * avgDuration / adjustedbw;
                    logger["logger"].trace("level/adjustedbw/bitrate/avgDuration/maxFetchDuration/fetchDuration: " + i + "/" + Math.round(adjustedbw) + "/" + bitrate + "/" + avgDuration + "/" + maxFetchDuration + "/" + fetchDuration);
                    if (adjustedbw > bitrate && // fragment fetchDuration unknown OR live stream OR fragment fetchDuration less than max allowed fetch duration, then this level matches
                    // we don't account for max Fetch Duration for live streams, this is to avoid switching down when near the edge of live sliding window ...
                    // special case to support startLevel = -1 (bitrateTest) on live streams : in that case we should not exit loop so that _findBestLevel will return -1
                    (!fetchDuration || live && !this.bitrateTestDelay || fetchDuration < maxFetchDuration)) {
                      return i;
                    }
                  }
                  return -1;
                };
                abr_controller_createClass(AbrController, [{
                  key: "nextAutoLevel",
                  get: function get() {
                    var forcedAutoLevel = this._nextAutoLevel;
                    var bwEstimator = this._bwEstimator;
                    if (forcedAutoLevel !== -1 && (!bwEstimator || !bwEstimator.canEstimate())) {
                      return forcedAutoLevel;
                    }
                    var nextABRAutoLevel = this._nextABRAutoLevel;
                    if (forcedAutoLevel !== -1) {
                      nextABRAutoLevel = Math.min(forcedAutoLevel, nextABRAutoLevel);
                    }
                    return nextABRAutoLevel;
                  },
                  set: function set(nextLevel) {
                    this._nextAutoLevel = nextLevel;
                  }
                }, {
                  key: "_nextABRAutoLevel",
                  get: function get() {
                    var hls = this.hls;
                    var maxAutoLevel = hls.maxAutoLevel, levels = hls.levels, config = hls.config, minAutoLevel = hls.minAutoLevel;
                    var video = hls.media;
                    var currentLevel = this.lastLoadedFragLevel;
                    var currentFragDuration = this.fragCurrent ? this.fragCurrent.duration : 0;
                    var pos = video ? video.currentTime : 0;
                    var playbackRate = video && video.playbackRate !== 0 ? Math.abs(video.playbackRate) : 1;
                    var avgbw = this._bwEstimator ? this._bwEstimator.getEstimate() : config.abrEwmaDefaultEstimate;
                    var bufferStarvationDelay = (BufferHelper.bufferInfo(video, pos, config.maxBufferHole).end - pos) / playbackRate;
                    var bestLevel = this._findBestLevel(currentLevel, currentFragDuration, avgbw, minAutoLevel, maxAutoLevel, bufferStarvationDelay, config.abrBandWidthFactor, config.abrBandWidthUpFactor, levels);
                    if (bestLevel >= 0) {
                      return bestLevel;
                    } else {
                      logger["logger"].trace("rebuffering expected to happen, lets try to find a quality level minimizing the rebuffering");
                      var maxStarvationDelay = currentFragDuration ? Math.min(currentFragDuration, config.maxStarvationDelay) : config.maxStarvationDelay;
                      var bwFactor = config.abrBandWidthFactor;
                      var bwUpFactor = config.abrBandWidthUpFactor;
                      if (bufferStarvationDelay === 0) {
                        var bitrateTestDelay = this.bitrateTestDelay;
                        if (bitrateTestDelay) {
                          var maxLoadingDelay = currentFragDuration ? Math.min(currentFragDuration, config.maxLoadingDelay) : config.maxLoadingDelay;
                          maxStarvationDelay = maxLoadingDelay - bitrateTestDelay;
                          logger["logger"].trace("bitrate test took " + Math.round(1e3 * bitrateTestDelay) + "ms, set first fragment max fetchDuration to " + Math.round(1e3 * maxStarvationDelay) + " ms");
                          bwFactor = bwUpFactor = 1;
                        }
                      }
                      bestLevel = this._findBestLevel(currentLevel, currentFragDuration, avgbw, minAutoLevel, maxAutoLevel, bufferStarvationDelay + maxStarvationDelay, bwFactor, bwUpFactor, levels);
                      return Math.max(bestLevel, 0);
                    }
                  }
                }]);
                return AbrController;
              }(event_handler);
              var abr_controller = abr_controller_AbrController;
              function buffer_controller_inheritsLoose(subClass, superClass) {
                subClass.prototype = Object.create(superClass.prototype);
                subClass.prototype.constructor = subClass;
                subClass.__proto__ = superClass;
              }
              var buffer_controller_MediaSource = getMediaSource();
              var buffer_controller_BufferController = function(_EventHandler) {
                buffer_controller_inheritsLoose(BufferController, _EventHandler);
                function BufferController(hls) {
                  var _this;
                  _this = _EventHandler.call(this, hls, events["default"].MEDIA_ATTACHING, events["default"].MEDIA_DETACHING, events["default"].MANIFEST_PARSED, events["default"].BUFFER_RESET, events["default"].BUFFER_APPENDING, events["default"].BUFFER_CODECS, events["default"].BUFFER_EOS, events["default"].BUFFER_FLUSHING, events["default"].LEVEL_PTS_UPDATED, events["default"].LEVEL_UPDATED) || this;
                  _this._msDuration = null;
                  _this._levelDuration = null;
                  _this._levelTargetDuration = 10;
                  _this._live = null;
                  _this._objectUrl = null;
                  _this._needsFlush = false;
                  _this._needsEos = false;
                  _this.config = void 0;
                  _this.audioTimestampOffset = void 0;
                  _this.bufferCodecEventsExpected = 0;
                  _this._bufferCodecEventsTotal = 0;
                  _this.media = null;
                  _this.mediaSource = null;
                  _this.segments = [];
                  _this.parent = void 0;
                  _this.appending = false;
                  _this.appended = 0;
                  _this.appendError = 0;
                  _this.flushBufferCounter = 0;
                  _this.tracks = {};
                  _this.pendingTracks = {};
                  _this.sourceBuffer = {};
                  _this.flushRange = [];
                  _this._onMediaSourceOpen = function() {
                    logger["logger"].log("media source opened");
                    _this.hls.trigger(events["default"].MEDIA_ATTACHED, {
                      media: _this.media
                    });
                    var mediaSource = _this.mediaSource;
                    if (mediaSource) {
                      mediaSource.removeEventListener("sourceopen", _this._onMediaSourceOpen);
                    }
                    _this.checkPendingTracks();
                  };
                  _this._onMediaSourceClose = function() {
                    logger["logger"].log("media source closed");
                  };
                  _this._onMediaSourceEnded = function() {
                    logger["logger"].log("media source ended");
                  };
                  _this._onSBUpdateEnd = function() {
                    if (_this.audioTimestampOffset && _this.sourceBuffer.audio) {
                      var audioBuffer = _this.sourceBuffer.audio;
                      logger["logger"].warn("change mpeg audio timestamp offset from " + audioBuffer.timestampOffset + " to " + _this.audioTimestampOffset);
                      audioBuffer.timestampOffset = _this.audioTimestampOffset;
                      delete _this.audioTimestampOffset;
                    }
                    if (_this._needsFlush) {
                      _this.doFlush();
                    }
                    if (_this._needsEos) {
                      _this.checkEos();
                    }
                    _this.appending = false;
                    var parent = _this.parent;
                    var pending = _this.segments.reduce(function(counter, segment) {
                      return segment.parent === parent ? counter + 1 : counter;
                    }, 0);
                    var timeRanges = {};
                    var sbSet = _this.sourceBuffer;
                    for (var streamType in sbSet) {
                      var sb = sbSet[streamType];
                      if (!sb) {
                        throw Error("handling source buffer update end error: source buffer for " + streamType + " uninitilized and unable to update buffered TimeRanges.");
                      }
                      timeRanges[streamType] = sb.buffered;
                    }
                    _this.hls.trigger(events["default"].BUFFER_APPENDED, {
                      parent,
                      pending,
                      timeRanges
                    });
                    if (!_this._needsFlush) {
                      _this.doAppending();
                    }
                    _this.updateMediaElementDuration();
                    if (pending === 0) {
                      _this.flushLiveBackBuffer();
                    }
                  };
                  _this._onSBUpdateError = function(event) {
                    logger["logger"].error("sourceBuffer error:", event);
                    _this.hls.trigger(events["default"].ERROR, {
                      type: errors["ErrorTypes"].MEDIA_ERROR,
                      details: errors["ErrorDetails"].BUFFER_APPENDING_ERROR,
                      fatal: false
                    });
                  };
                  _this.config = hls.config;
                  return _this;
                }
                var _proto = BufferController.prototype;
                _proto.destroy = function destroy() {
                  event_handler.prototype.destroy.call(this);
                };
                _proto.onLevelPtsUpdated = function onLevelPtsUpdated(data) {
                  var type = data.type;
                  var audioTrack = this.tracks.audio;
                  if (type === "audio" && audioTrack && audioTrack.container === "audio/mpeg") {
                    var audioBuffer = this.sourceBuffer.audio;
                    if (!audioBuffer) {
                      throw Error("Level PTS Updated and source buffer for audio uninitalized");
                    }
                    var delta = Math.abs(audioBuffer.timestampOffset - data.start);
                    if (delta > 0.1) {
                      var updating = audioBuffer.updating;
                      try {
                        audioBuffer.abort();
                      } catch (err) {
                        logger["logger"].warn("can not abort audio buffer: " + err);
                      }
                      if (!updating) {
                        logger["logger"].warn("change mpeg audio timestamp offset from " + audioBuffer.timestampOffset + " to " + data.start);
                        audioBuffer.timestampOffset = data.start;
                      } else {
                        this.audioTimestampOffset = data.start;
                      }
                    }
                  }
                };
                _proto.onManifestParsed = function onManifestParsed(data) {
                  var codecEvents = 2;
                  if (data.audio && !data.video || !data.altAudio) {
                    codecEvents = 1;
                  }
                  this.bufferCodecEventsExpected = this._bufferCodecEventsTotal = codecEvents;
                  logger["logger"].log(this.bufferCodecEventsExpected + " bufferCodec event(s) expected");
                };
                _proto.onMediaAttaching = function onMediaAttaching(data) {
                  var media = this.media = data.media;
                  if (media && buffer_controller_MediaSource) {
                    var ms = this.mediaSource = new buffer_controller_MediaSource();
                    ms.addEventListener("sourceopen", this._onMediaSourceOpen);
                    ms.addEventListener("sourceended", this._onMediaSourceEnded);
                    ms.addEventListener("sourceclose", this._onMediaSourceClose);
                    media.src = window.URL.createObjectURL(ms);
                    this._objectUrl = media.src;
                  }
                };
                _proto.onMediaDetaching = function onMediaDetaching() {
                  logger["logger"].log("media source detaching");
                  var ms = this.mediaSource;
                  if (ms) {
                    if (ms.readyState === "open") {
                      try {
                        ms.endOfStream();
                      } catch (err) {
                        logger["logger"].warn("onMediaDetaching:" + err.message + " while calling endOfStream");
                      }
                    }
                    ms.removeEventListener("sourceopen", this._onMediaSourceOpen);
                    ms.removeEventListener("sourceended", this._onMediaSourceEnded);
                    ms.removeEventListener("sourceclose", this._onMediaSourceClose);
                    if (this.media) {
                      if (this._objectUrl) {
                        window.URL.revokeObjectURL(this._objectUrl);
                      }
                      if (this.media.src === this._objectUrl) {
                        this.media.removeAttribute("src");
                        this.media.load();
                      } else {
                        logger["logger"].warn("media.src was changed by a third party - skip cleanup");
                      }
                    }
                    this.mediaSource = null;
                    this.media = null;
                    this._objectUrl = null;
                    this.bufferCodecEventsExpected = this._bufferCodecEventsTotal;
                    this.pendingTracks = {};
                    this.tracks = {};
                    this.sourceBuffer = {};
                    this.flushRange = [];
                    this.segments = [];
                    this.appended = 0;
                  }
                  this.hls.trigger(events["default"].MEDIA_DETACHED);
                };
                _proto.checkPendingTracks = function checkPendingTracks() {
                  var bufferCodecEventsExpected = this.bufferCodecEventsExpected, pendingTracks = this.pendingTracks;
                  var pendingTracksCount = Object.keys(pendingTracks).length;
                  if (pendingTracksCount && !bufferCodecEventsExpected || pendingTracksCount === 2) {
                    this.createSourceBuffers(pendingTracks);
                    this.pendingTracks = {};
                    this.doAppending();
                  }
                };
                _proto.onBufferReset = function onBufferReset() {
                  var sourceBuffer = this.sourceBuffer;
                  for (var type in sourceBuffer) {
                    var sb = sourceBuffer[type];
                    try {
                      if (sb) {
                        if (this.mediaSource) {
                          this.mediaSource.removeSourceBuffer(sb);
                        }
                        sb.removeEventListener("updateend", this._onSBUpdateEnd);
                        sb.removeEventListener("error", this._onSBUpdateError);
                      }
                    } catch (err) {
                    }
                  }
                  this.sourceBuffer = {};
                  this.flushRange = [];
                  this.segments = [];
                  this.appended = 0;
                };
                _proto.onBufferCodecs = function onBufferCodecs(tracks) {
                  var _this2 = this;
                  if (Object.keys(this.sourceBuffer).length) {
                    return;
                  }
                  Object.keys(tracks).forEach(function(trackName) {
                    _this2.pendingTracks[trackName] = tracks[trackName];
                  });
                  this.bufferCodecEventsExpected = Math.max(this.bufferCodecEventsExpected - 1, 0);
                  if (this.mediaSource && this.mediaSource.readyState === "open") {
                    this.checkPendingTracks();
                  }
                };
                _proto.createSourceBuffers = function createSourceBuffers(tracks) {
                  var sourceBuffer = this.sourceBuffer, mediaSource = this.mediaSource;
                  if (!mediaSource) {
                    throw Error("createSourceBuffers called when mediaSource was null");
                  }
                  for (var trackName in tracks) {
                    if (!sourceBuffer[trackName]) {
                      var track = tracks[trackName];
                      if (!track) {
                        throw Error("source buffer exists for track " + trackName + ", however track does not");
                      }
                      var codec = track.levelCodec || track.codec;
                      var mimeType = track.container + ";codecs=" + codec;
                      logger["logger"].log("creating sourceBuffer(" + mimeType + ")");
                      try {
                        var sb = sourceBuffer[trackName] = mediaSource.addSourceBuffer(mimeType);
                        sb.addEventListener("updateend", this._onSBUpdateEnd);
                        sb.addEventListener("error", this._onSBUpdateError);
                        this.tracks[trackName] = {
                          buffer: sb,
                          codec,
                          id: track.id,
                          container: track.container,
                          levelCodec: track.levelCodec
                        };
                      } catch (err) {
                        logger["logger"].error("error while trying to add sourceBuffer:" + err.message);
                        this.hls.trigger(events["default"].ERROR, {
                          type: errors["ErrorTypes"].MEDIA_ERROR,
                          details: errors["ErrorDetails"].BUFFER_ADD_CODEC_ERROR,
                          fatal: false,
                          err,
                          mimeType
                        });
                      }
                    }
                  }
                  this.hls.trigger(events["default"].BUFFER_CREATED, {
                    tracks: this.tracks
                  });
                };
                _proto.onBufferAppending = function onBufferAppending(data) {
                  if (!this._needsFlush) {
                    if (!this.segments) {
                      this.segments = [data];
                    } else {
                      this.segments.push(data);
                    }
                    this.doAppending();
                  }
                };
                _proto.onBufferEos = function onBufferEos(data) {
                  for (var type in this.sourceBuffer) {
                    if (!data.type || data.type === type) {
                      var sb = this.sourceBuffer[type];
                      if (sb && !sb.ended) {
                        sb.ended = true;
                        logger["logger"].log(type + " sourceBuffer now EOS");
                      }
                    }
                  }
                  this.checkEos();
                };
                _proto.checkEos = function checkEos() {
                  var sourceBuffer = this.sourceBuffer, mediaSource = this.mediaSource;
                  if (!mediaSource || mediaSource.readyState !== "open") {
                    this._needsEos = false;
                    return;
                  }
                  for (var type in sourceBuffer) {
                    var sb = sourceBuffer[type];
                    if (!sb)
                      continue;
                    if (!sb.ended) {
                      return;
                    }
                    if (sb.updating) {
                      this._needsEos = true;
                      return;
                    }
                  }
                  logger["logger"].log("all media data are available, signal endOfStream() to MediaSource and stop loading fragment");
                  try {
                    mediaSource.endOfStream();
                  } catch (e) {
                    logger["logger"].warn("exception while calling mediaSource.endOfStream()");
                  }
                  this._needsEos = false;
                };
                _proto.onBufferFlushing = function onBufferFlushing(data) {
                  if (data.type) {
                    this.flushRange.push({
                      start: data.startOffset,
                      end: data.endOffset,
                      type: data.type
                    });
                  } else {
                    this.flushRange.push({
                      start: data.startOffset,
                      end: data.endOffset,
                      type: "video"
                    });
                    this.flushRange.push({
                      start: data.startOffset,
                      end: data.endOffset,
                      type: "audio"
                    });
                  }
                  this.flushBufferCounter = 0;
                  this.doFlush();
                };
                _proto.flushLiveBackBuffer = function flushLiveBackBuffer() {
                  if (!this._live) {
                    return;
                  }
                  var liveBackBufferLength = this.config.liveBackBufferLength;
                  if (!isFinite(liveBackBufferLength) || liveBackBufferLength < 0) {
                    return;
                  }
                  if (!this.media) {
                    logger["logger"].error("flushLiveBackBuffer called without attaching media");
                    return;
                  }
                  var currentTime = this.media.currentTime;
                  var sourceBuffer = this.sourceBuffer;
                  var bufferTypes = Object.keys(sourceBuffer);
                  var targetBackBufferPosition = currentTime - Math.max(liveBackBufferLength, this._levelTargetDuration);
                  for (var index = bufferTypes.length - 1; index >= 0; index--) {
                    var bufferType = bufferTypes[index];
                    var sb = sourceBuffer[bufferType];
                    if (sb) {
                      var buffered = sb.buffered;
                      if (buffered.length > 0 && targetBackBufferPosition > buffered.start(0)) {
                        if (this.removeBufferRange(bufferType, sb, 0, targetBackBufferPosition)) {
                          this.hls.trigger(events["default"].LIVE_BACK_BUFFER_REACHED, {
                            bufferEnd: targetBackBufferPosition
                          });
                        }
                      }
                    }
                  }
                };
                _proto.onLevelUpdated = function onLevelUpdated(_ref) {
                  var details = _ref.details;
                  if (details.fragments.length > 0) {
                    this._levelDuration = details.totalduration + details.fragments[0].start;
                    this._levelTargetDuration = details.averagetargetduration || details.targetduration || 10;
                    this._live = details.live;
                    this.updateMediaElementDuration();
                  }
                };
                _proto.updateMediaElementDuration = function updateMediaElementDuration() {
                  var config = this.config;
                  var duration;
                  if (this._levelDuration === null || !this.media || !this.mediaSource || !this.sourceBuffer || this.media.readyState === 0 || this.mediaSource.readyState !== "open") {
                    return;
                  }
                  for (var type in this.sourceBuffer) {
                    var sb = this.sourceBuffer[type];
                    if (sb && sb.updating === true) {
                      return;
                    }
                  }
                  duration = this.media.duration;
                  if (this._msDuration === null) {
                    this._msDuration = this.mediaSource.duration;
                  }
                  if (this._live === true && config.liveDurationInfinity === true) {
                    logger["logger"].log("Media Source duration is set to Infinity");
                    this._msDuration = this.mediaSource.duration = Infinity;
                  } else if (this._levelDuration > this._msDuration && this._levelDuration > duration || !Object(number["isFiniteNumber"])(duration)) {
                    logger["logger"].log("Updating Media Source duration to " + this._levelDuration.toFixed(3));
                    this._msDuration = this.mediaSource.duration = this._levelDuration;
                  }
                };
                _proto.doFlush = function doFlush() {
                  while (this.flushRange.length) {
                    var range = this.flushRange[0];
                    if (this.flushBuffer(range.start, range.end, range.type)) {
                      this.flushRange.shift();
                      this.flushBufferCounter = 0;
                    } else {
                      this._needsFlush = true;
                      return;
                    }
                  }
                  if (this.flushRange.length === 0) {
                    this._needsFlush = false;
                    var appended = 0;
                    var sourceBuffer = this.sourceBuffer;
                    try {
                      for (var type in sourceBuffer) {
                        var sb = sourceBuffer[type];
                        if (sb) {
                          appended += sb.buffered.length;
                        }
                      }
                    } catch (error) {
                      logger["logger"].error("error while accessing sourceBuffer.buffered");
                    }
                    this.appended = appended;
                    this.hls.trigger(events["default"].BUFFER_FLUSHED);
                  }
                };
                _proto.doAppending = function doAppending() {
                  var config = this.config, hls = this.hls, segments = this.segments, sourceBuffer = this.sourceBuffer;
                  if (!Object.keys(sourceBuffer).length) {
                    return;
                  }
                  if (!this.media || this.media.error) {
                    this.segments = [];
                    logger["logger"].error("trying to append although a media error occured, flush segment and abort");
                    return;
                  }
                  if (this.appending) {
                    return;
                  }
                  var segment = segments.shift();
                  if (!segment) {
                    return;
                  }
                  try {
                    var sb = sourceBuffer[segment.type];
                    if (!sb) {
                      this._onSBUpdateEnd();
                      return;
                    }
                    if (sb.updating) {
                      segments.unshift(segment);
                      return;
                    }
                    sb.ended = false;
                    this.parent = segment.parent;
                    sb.appendBuffer(segment.data);
                    this.appendError = 0;
                    this.appended++;
                    this.appending = true;
                  } catch (err) {
                    logger["logger"].error("error while trying to append buffer:" + err.message);
                    segments.unshift(segment);
                    var event = {
                      type: errors["ErrorTypes"].MEDIA_ERROR,
                      parent: segment.parent,
                      details: "",
                      fatal: false
                    };
                    if (err.code === 22) {
                      this.segments = [];
                      event.details = errors["ErrorDetails"].BUFFER_FULL_ERROR;
                    } else {
                      this.appendError++;
                      event.details = errors["ErrorDetails"].BUFFER_APPEND_ERROR;
                      if (this.appendError > config.appendErrorMaxRetry) {
                        logger["logger"].log("fail " + config.appendErrorMaxRetry + " times to append segment in sourceBuffer");
                        this.segments = [];
                        event.fatal = true;
                      }
                    }
                    hls.trigger(events["default"].ERROR, event);
                  }
                };
                _proto.flushBuffer = function flushBuffer(startOffset, endOffset, sbType) {
                  var sourceBuffer = this.sourceBuffer;
                  if (!Object.keys(sourceBuffer).length) {
                    return true;
                  }
                  var currentTime = "null";
                  if (this.media) {
                    currentTime = this.media.currentTime.toFixed(3);
                  }
                  logger["logger"].log("flushBuffer,pos/start/end: " + currentTime + "/" + startOffset + "/" + endOffset);
                  if (this.flushBufferCounter >= this.appended) {
                    logger["logger"].warn("abort flushing too many retries");
                    return true;
                  }
                  var sb = sourceBuffer[sbType];
                  if (sb) {
                    sb.ended = false;
                    if (!sb.updating) {
                      if (this.removeBufferRange(sbType, sb, startOffset, endOffset)) {
                        this.flushBufferCounter++;
                        return false;
                      }
                    } else {
                      logger["logger"].warn("cannot flush, sb updating in progress");
                      return false;
                    }
                  }
                  logger["logger"].log("buffer flushed");
                  return true;
                };
                _proto.removeBufferRange = function removeBufferRange(type, sb, startOffset, endOffset) {
                  try {
                    for (var i = 0; i < sb.buffered.length; i++) {
                      var bufStart = sb.buffered.start(i);
                      var bufEnd = sb.buffered.end(i);
                      var removeStart = Math.max(bufStart, startOffset);
                      var removeEnd = Math.min(bufEnd, endOffset);
                      if (Math.min(removeEnd, bufEnd) - removeStart > 0.5) {
                        var currentTime = "null";
                        if (this.media) {
                          currentTime = this.media.currentTime.toString();
                        }
                        logger["logger"].log("sb remove " + type + " [" + removeStart + "," + removeEnd + "], of [" + bufStart + "," + bufEnd + "], pos:" + currentTime);
                        sb.remove(removeStart, removeEnd);
                        return true;
                      }
                    }
                  } catch (error) {
                    logger["logger"].warn("removeBufferRange failed", error);
                  }
                  return false;
                };
                return BufferController;
              }(event_handler);
              var buffer_controller = buffer_controller_BufferController;
              function cap_level_controller_defineProperties(target, props) {
                for (var i = 0; i < props.length; i++) {
                  var descriptor = props[i];
                  descriptor.enumerable = descriptor.enumerable || false;
                  descriptor.configurable = true;
                  if ("value" in descriptor)
                    descriptor.writable = true;
                  Object.defineProperty(target, descriptor.key, descriptor);
                }
              }
              function cap_level_controller_createClass(Constructor, protoProps, staticProps) {
                if (protoProps)
                  cap_level_controller_defineProperties(Constructor.prototype, protoProps);
                if (staticProps)
                  cap_level_controller_defineProperties(Constructor, staticProps);
                return Constructor;
              }
              function cap_level_controller_inheritsLoose(subClass, superClass) {
                subClass.prototype = Object.create(superClass.prototype);
                subClass.prototype.constructor = subClass;
                subClass.__proto__ = superClass;
              }
              var cap_level_controller_CapLevelController = function(_EventHandler) {
                cap_level_controller_inheritsLoose(CapLevelController, _EventHandler);
                function CapLevelController(hls) {
                  var _this;
                  _this = _EventHandler.call(this, hls, events["default"].FPS_DROP_LEVEL_CAPPING, events["default"].MEDIA_ATTACHING, events["default"].MANIFEST_PARSED, events["default"].LEVELS_UPDATED, events["default"].BUFFER_CODECS, events["default"].MEDIA_DETACHING) || this;
                  _this.autoLevelCapping = Number.POSITIVE_INFINITY;
                  _this.firstLevel = null;
                  _this.levels = [];
                  _this.media = null;
                  _this.restrictedLevels = [];
                  _this.timer = null;
                  _this.clientRect = null;
                  return _this;
                }
                var _proto = CapLevelController.prototype;
                _proto.destroy = function destroy() {
                  if (this.hls.config.capLevelToPlayerSize) {
                    this.media = null;
                    this.clientRect = null;
                    this.stopCapping();
                  }
                };
                _proto.onFpsDropLevelCapping = function onFpsDropLevelCapping(data) {
                  if (CapLevelController.isLevelAllowed(data.droppedLevel, this.restrictedLevels)) {
                    this.restrictedLevels.push(data.droppedLevel);
                  }
                };
                _proto.onMediaAttaching = function onMediaAttaching(data) {
                  this.media = data.media instanceof window.HTMLVideoElement ? data.media : null;
                };
                _proto.onManifestParsed = function onManifestParsed(data) {
                  var hls = this.hls;
                  this.restrictedLevels = [];
                  this.levels = data.levels;
                  this.firstLevel = data.firstLevel;
                  if (hls.config.capLevelToPlayerSize && data.video) {
                    this.startCapping();
                  }
                };
                _proto.onBufferCodecs = function onBufferCodecs(data) {
                  var hls = this.hls;
                  if (hls.config.capLevelToPlayerSize && data.video) {
                    this.startCapping();
                  }
                };
                _proto.onLevelsUpdated = function onLevelsUpdated(data) {
                  this.levels = data.levels;
                };
                _proto.onMediaDetaching = function onMediaDetaching() {
                  this.stopCapping();
                };
                _proto.detectPlayerSize = function detectPlayerSize() {
                  if (this.media) {
                    var levelsLength = this.levels ? this.levels.length : 0;
                    if (levelsLength) {
                      var hls = this.hls;
                      hls.autoLevelCapping = this.getMaxLevel(levelsLength - 1);
                      if (hls.autoLevelCapping > this.autoLevelCapping) {
                        hls.streamController.nextLevelSwitch();
                      }
                      this.autoLevelCapping = hls.autoLevelCapping;
                    }
                  }
                };
                _proto.getMaxLevel = function getMaxLevel(capLevelIndex) {
                  var _this2 = this;
                  if (!this.levels) {
                    return -1;
                  }
                  var validLevels = this.levels.filter(function(level, index) {
                    return CapLevelController.isLevelAllowed(index, _this2.restrictedLevels) && index <= capLevelIndex;
                  });
                  this.clientRect = null;
                  return CapLevelController.getMaxLevelByMediaSize(validLevels, this.mediaWidth, this.mediaHeight);
                };
                _proto.startCapping = function startCapping() {
                  if (this.timer) {
                    return;
                  }
                  this.autoLevelCapping = Number.POSITIVE_INFINITY;
                  this.hls.firstLevel = this.getMaxLevel(this.firstLevel);
                  clearInterval(this.timer);
                  this.timer = setInterval(this.detectPlayerSize.bind(this), 1e3);
                  this.detectPlayerSize();
                };
                _proto.stopCapping = function stopCapping() {
                  this.restrictedLevels = [];
                  this.firstLevel = null;
                  this.autoLevelCapping = Number.POSITIVE_INFINITY;
                  if (this.timer) {
                    this.timer = clearInterval(this.timer);
                    this.timer = null;
                  }
                };
                _proto.getDimensions = function getDimensions() {
                  if (this.clientRect) {
                    return this.clientRect;
                  }
                  var media = this.media;
                  var boundsRect = {
                    width: 0,
                    height: 0
                  };
                  if (media) {
                    var clientRect = media.getBoundingClientRect();
                    boundsRect.width = clientRect.width;
                    boundsRect.height = clientRect.height;
                    if (!boundsRect.width && !boundsRect.height) {
                      boundsRect.width = clientRect.right - clientRect.left || media.width || 0;
                      boundsRect.height = clientRect.bottom - clientRect.top || media.height || 0;
                    }
                  }
                  this.clientRect = boundsRect;
                  return boundsRect;
                };
                CapLevelController.isLevelAllowed = function isLevelAllowed(level, restrictedLevels) {
                  if (restrictedLevels === void 0) {
                    restrictedLevels = [];
                  }
                  return restrictedLevels.indexOf(level) === -1;
                };
                CapLevelController.getMaxLevelByMediaSize = function getMaxLevelByMediaSize(levels, width, height) {
                  if (!levels || levels && !levels.length) {
                    return -1;
                  }
                  var atGreatestBandiwdth = function atGreatestBandiwdth2(curLevel, nextLevel) {
                    if (!nextLevel) {
                      return true;
                    }
                    return curLevel.width !== nextLevel.width || curLevel.height !== nextLevel.height;
                  };
                  var maxLevelIndex = levels.length - 1;
                  for (var i = 0; i < levels.length; i += 1) {
                    var level = levels[i];
                    if ((level.width >= width || level.height >= height) && atGreatestBandiwdth(level, levels[i + 1])) {
                      maxLevelIndex = i;
                      break;
                    }
                  }
                  return maxLevelIndex;
                };
                cap_level_controller_createClass(CapLevelController, [{
                  key: "mediaWidth",
                  get: function get() {
                    return this.getDimensions().width * CapLevelController.contentScaleFactor;
                  }
                }, {
                  key: "mediaHeight",
                  get: function get() {
                    return this.getDimensions().height * CapLevelController.contentScaleFactor;
                  }
                }], [{
                  key: "contentScaleFactor",
                  get: function get() {
                    var pixelRatio = 1;
                    try {
                      pixelRatio = window.devicePixelRatio;
                    } catch (e) {
                    }
                    return pixelRatio;
                  }
                }]);
                return CapLevelController;
              }(event_handler);
              var cap_level_controller = cap_level_controller_CapLevelController;
              function fps_controller_inheritsLoose(subClass, superClass) {
                subClass.prototype = Object.create(superClass.prototype);
                subClass.prototype.constructor = subClass;
                subClass.__proto__ = superClass;
              }
              var fps_controller_window = window, fps_controller_performance = fps_controller_window.performance;
              var fps_controller_FPSController = function(_EventHandler) {
                fps_controller_inheritsLoose(FPSController, _EventHandler);
                function FPSController(hls) {
                  return _EventHandler.call(this, hls, events["default"].MEDIA_ATTACHING) || this;
                }
                var _proto = FPSController.prototype;
                _proto.destroy = function destroy() {
                  if (this.timer) {
                    clearInterval(this.timer);
                  }
                  this.isVideoPlaybackQualityAvailable = false;
                };
                _proto.onMediaAttaching = function onMediaAttaching(data) {
                  var config = this.hls.config;
                  if (config.capLevelOnFPSDrop) {
                    var video = this.video = data.media instanceof window.HTMLVideoElement ? data.media : null;
                    if (typeof video.getVideoPlaybackQuality === "function") {
                      this.isVideoPlaybackQualityAvailable = true;
                    }
                    clearInterval(this.timer);
                    this.timer = setInterval(this.checkFPSInterval.bind(this), config.fpsDroppedMonitoringPeriod);
                  }
                };
                _proto.checkFPS = function checkFPS(video, decodedFrames, droppedFrames) {
                  var currentTime = fps_controller_performance.now();
                  if (decodedFrames) {
                    if (this.lastTime) {
                      var currentPeriod = currentTime - this.lastTime, currentDropped = droppedFrames - this.lastDroppedFrames, currentDecoded = decodedFrames - this.lastDecodedFrames, droppedFPS = 1e3 * currentDropped / currentPeriod, hls = this.hls;
                      hls.trigger(events["default"].FPS_DROP, {
                        currentDropped,
                        currentDecoded,
                        totalDroppedFrames: droppedFrames
                      });
                      if (droppedFPS > 0) {
                        if (currentDropped > hls.config.fpsDroppedMonitoringThreshold * currentDecoded) {
                          var currentLevel = hls.currentLevel;
                          logger["logger"].warn("drop FPS ratio greater than max allowed value for currentLevel: " + currentLevel);
                          if (currentLevel > 0 && (hls.autoLevelCapping === -1 || hls.autoLevelCapping >= currentLevel)) {
                            currentLevel = currentLevel - 1;
                            hls.trigger(events["default"].FPS_DROP_LEVEL_CAPPING, {
                              level: currentLevel,
                              droppedLevel: hls.currentLevel
                            });
                            hls.autoLevelCapping = currentLevel;
                            hls.streamController.nextLevelSwitch();
                          }
                        }
                      }
                    }
                    this.lastTime = currentTime;
                    this.lastDroppedFrames = droppedFrames;
                    this.lastDecodedFrames = decodedFrames;
                  }
                };
                _proto.checkFPSInterval = function checkFPSInterval() {
                  var video = this.video;
                  if (video) {
                    if (this.isVideoPlaybackQualityAvailable) {
                      var videoPlaybackQuality = video.getVideoPlaybackQuality();
                      this.checkFPS(video, videoPlaybackQuality.totalVideoFrames, videoPlaybackQuality.droppedVideoFrames);
                    } else {
                      this.checkFPS(video, video.webkitDecodedFrameCount, video.webkitDroppedFrameCount);
                    }
                  }
                };
                return FPSController;
              }(event_handler);
              var fps_controller = fps_controller_FPSController;
              var xhr_loader_XhrLoader = function() {
                function XhrLoader(config) {
                  if (config && config.xhrSetup) {
                    this.xhrSetup = config.xhrSetup;
                  }
                }
                var _proto = XhrLoader.prototype;
                _proto.destroy = function destroy() {
                  this.abort();
                  this.loader = null;
                };
                _proto.abort = function abort() {
                  var loader = this.loader;
                  if (loader && loader.readyState !== 4) {
                    this.stats.aborted = true;
                    loader.abort();
                  }
                  window.clearTimeout(this.requestTimeout);
                  this.requestTimeout = null;
                  window.clearTimeout(this.retryTimeout);
                  this.retryTimeout = null;
                };
                _proto.load = function load(context, config, callbacks) {
                  this.context = context;
                  this.config = config;
                  this.callbacks = callbacks;
                  this.stats = {
                    trequest: window.performance.now(),
                    retry: 0
                  };
                  this.retryDelay = config.retryDelay;
                  this.loadInternal();
                };
                _proto.loadInternal = function loadInternal() {
                  var xhr, context = this.context;
                  xhr = this.loader = new window.XMLHttpRequest();
                  var stats = this.stats;
                  stats.tfirst = 0;
                  stats.loaded = 0;
                  var xhrSetup = this.xhrSetup;
                  try {
                    if (xhrSetup) {
                      try {
                        xhrSetup(xhr, context.url);
                      } catch (e) {
                        xhr.open("GET", context.url, true);
                        xhrSetup(xhr, context.url);
                      }
                    }
                    if (!xhr.readyState) {
                      xhr.open("GET", context.url, true);
                    }
                  } catch (e) {
                    this.callbacks.onError({
                      code: xhr.status,
                      text: e.message
                    }, context, xhr);
                    return;
                  }
                  if (context.rangeEnd) {
                    xhr.setRequestHeader("Range", "bytes=" + context.rangeStart + "-" + (context.rangeEnd - 1));
                  }
                  xhr.onreadystatechange = this.readystatechange.bind(this);
                  xhr.onprogress = this.loadprogress.bind(this);
                  xhr.responseType = context.responseType;
                  this.requestTimeout = window.setTimeout(this.loadtimeout.bind(this), this.config.timeout);
                  xhr.send();
                };
                _proto.readystatechange = function readystatechange(event) {
                  var xhr = event.currentTarget, readyState = xhr.readyState, stats = this.stats, context = this.context, config = this.config;
                  if (stats.aborted) {
                    return;
                  }
                  if (readyState >= 2) {
                    window.clearTimeout(this.requestTimeout);
                    if (stats.tfirst === 0) {
                      stats.tfirst = Math.max(window.performance.now(), stats.trequest);
                    }
                    if (readyState === 4) {
                      var status = xhr.status;
                      if (status >= 200 && status < 300) {
                        stats.tload = Math.max(stats.tfirst, window.performance.now());
                        var data, len;
                        if (context.responseType === "arraybuffer") {
                          data = xhr.response;
                          len = data.byteLength;
                        } else {
                          data = xhr.responseText;
                          len = data.length;
                        }
                        stats.loaded = stats.total = len;
                        var response = {
                          url: xhr.responseURL,
                          data
                        };
                        this.callbacks.onSuccess(response, stats, context, xhr);
                      } else {
                        if (stats.retry >= config.maxRetry || status >= 400 && status < 499) {
                          logger["logger"].error(status + " while loading " + context.url);
                          this.callbacks.onError({
                            code: status,
                            text: xhr.statusText
                          }, context, xhr);
                        } else {
                          logger["logger"].warn(status + " while loading " + context.url + ", retrying in " + this.retryDelay + "...");
                          this.destroy();
                          this.retryTimeout = window.setTimeout(this.loadInternal.bind(this), this.retryDelay);
                          this.retryDelay = Math.min(2 * this.retryDelay, config.maxRetryDelay);
                          stats.retry++;
                        }
                      }
                    } else {
                      this.requestTimeout = window.setTimeout(this.loadtimeout.bind(this), config.timeout);
                    }
                  }
                };
                _proto.loadtimeout = function loadtimeout() {
                  logger["logger"].warn("timeout while loading " + this.context.url);
                  this.callbacks.onTimeout(this.stats, this.context, null);
                };
                _proto.loadprogress = function loadprogress(event) {
                  var xhr = event.currentTarget, stats = this.stats;
                  stats.loaded = event.loaded;
                  if (event.lengthComputable) {
                    stats.total = event.total;
                  }
                  var onProgress = this.callbacks.onProgress;
                  if (onProgress) {
                    onProgress(stats, this.context, null, xhr);
                  }
                };
                return XhrLoader;
              }();
              var xhr_loader = xhr_loader_XhrLoader;
              function audio_track_controller_defineProperties(target, props) {
                for (var i = 0; i < props.length; i++) {
                  var descriptor = props[i];
                  descriptor.enumerable = descriptor.enumerable || false;
                  descriptor.configurable = true;
                  if ("value" in descriptor)
                    descriptor.writable = true;
                  Object.defineProperty(target, descriptor.key, descriptor);
                }
              }
              function audio_track_controller_createClass(Constructor, protoProps, staticProps) {
                if (protoProps)
                  audio_track_controller_defineProperties(Constructor.prototype, protoProps);
                if (staticProps)
                  audio_track_controller_defineProperties(Constructor, staticProps);
                return Constructor;
              }
              function audio_track_controller_inheritsLoose(subClass, superClass) {
                subClass.prototype = Object.create(superClass.prototype);
                subClass.prototype.constructor = subClass;
                subClass.__proto__ = superClass;
              }
              var audio_track_controller_AudioTrackController = function(_TaskLoop) {
                audio_track_controller_inheritsLoose(AudioTrackController, _TaskLoop);
                function AudioTrackController(hls) {
                  var _this;
                  _this = _TaskLoop.call(this, hls, events["default"].MANIFEST_LOADING, events["default"].MANIFEST_PARSED, events["default"].AUDIO_TRACK_LOADED, events["default"].AUDIO_TRACK_SWITCHED, events["default"].LEVEL_LOADED, events["default"].ERROR) || this;
                  _this._trackId = -1;
                  _this._selectDefaultTrack = true;
                  _this.tracks = [];
                  _this.trackIdBlacklist = /* @__PURE__ */ Object.create(null);
                  _this.audioGroupId = null;
                  return _this;
                }
                var _proto = AudioTrackController.prototype;
                _proto.onManifestLoading = function onManifestLoading() {
                  this.tracks = [];
                  this._trackId = -1;
                  this._selectDefaultTrack = true;
                };
                _proto.onManifestParsed = function onManifestParsed(data) {
                  var tracks = this.tracks = data.audioTracks || [];
                  this.hls.trigger(events["default"].AUDIO_TRACKS_UPDATED, {
                    audioTracks: tracks
                  });
                  this._selectAudioGroup(this.hls.nextLoadLevel);
                };
                _proto.onAudioTrackLoaded = function onAudioTrackLoaded(data) {
                  if (data.id >= this.tracks.length) {
                    logger["logger"].warn("Invalid audio track id:", data.id);
                    return;
                  }
                  logger["logger"].log("audioTrack " + data.id + " loaded");
                  this.tracks[data.id].details = data.details;
                  if (data.details.live && !this.hasInterval()) {
                    var updatePeriodMs = data.details.targetduration * 1e3;
                    this.setInterval(updatePeriodMs);
                  }
                  if (!data.details.live && this.hasInterval()) {
                    this.clearInterval();
                  }
                };
                _proto.onAudioTrackSwitched = function onAudioTrackSwitched(data) {
                  var audioGroupId = this.tracks[data.id].groupId;
                  if (audioGroupId && this.audioGroupId !== audioGroupId) {
                    this.audioGroupId = audioGroupId;
                  }
                };
                _proto.onLevelLoaded = function onLevelLoaded(data) {
                  this._selectAudioGroup(data.level);
                };
                _proto.onError = function onError(data) {
                  if (data.type !== errors["ErrorTypes"].NETWORK_ERROR) {
                    return;
                  }
                  if (data.fatal) {
                    this.clearInterval();
                  }
                  if (data.details !== errors["ErrorDetails"].AUDIO_TRACK_LOAD_ERROR) {
                    return;
                  }
                  logger["logger"].warn("Network failure on audio-track id:", data.context.id);
                  this._handleLoadError();
                };
                _proto._setAudioTrack = function _setAudioTrack(newId) {
                  if (this._trackId === newId && this.tracks[this._trackId].details) {
                    logger["logger"].debug("Same id as current audio-track passed, and track details available -> no-op");
                    return;
                  }
                  if (newId < 0 || newId >= this.tracks.length) {
                    logger["logger"].warn("Invalid id passed to audio-track controller");
                    return;
                  }
                  var audioTrack = this.tracks[newId];
                  logger["logger"].log("Now switching to audio-track index " + newId);
                  this.clearInterval();
                  this._trackId = newId;
                  var url = audioTrack.url, type = audioTrack.type, id = audioTrack.id;
                  this.hls.trigger(events["default"].AUDIO_TRACK_SWITCHING, {
                    id,
                    type,
                    url
                  });
                  this._loadTrackDetailsIfNeeded(audioTrack);
                };
                _proto.doTick = function doTick() {
                  this._updateTrack(this._trackId);
                };
                _proto._selectAudioGroup = function _selectAudioGroup(levelId) {
                  var levelInfo = this.hls.levels[levelId];
                  if (!levelInfo || !levelInfo.audioGroupIds) {
                    return;
                  }
                  var audioGroupId = levelInfo.audioGroupIds[levelInfo.urlId];
                  if (this.audioGroupId !== audioGroupId) {
                    this.audioGroupId = audioGroupId;
                    this._selectInitialAudioTrack();
                  }
                };
                _proto._selectInitialAudioTrack = function _selectInitialAudioTrack() {
                  var _this2 = this;
                  var tracks = this.tracks;
                  if (!tracks.length) {
                    return;
                  }
                  var currentAudioTrack = this.tracks[this._trackId];
                  var name = null;
                  if (currentAudioTrack) {
                    name = currentAudioTrack.name;
                  }
                  if (this._selectDefaultTrack) {
                    var defaultTracks = tracks.filter(function(track) {
                      return track.default;
                    });
                    if (defaultTracks.length) {
                      tracks = defaultTracks;
                    } else {
                      logger["logger"].warn("No default audio tracks defined");
                    }
                  }
                  var trackFound = false;
                  var traverseTracks = function traverseTracks2() {
                    tracks.forEach(function(track) {
                      if (trackFound) {
                        return;
                      }
                      if ((!_this2.audioGroupId || track.groupId === _this2.audioGroupId) && (!name || name === track.name)) {
                        _this2._setAudioTrack(track.id);
                        trackFound = true;
                      }
                    });
                  };
                  traverseTracks();
                  if (!trackFound) {
                    name = null;
                    traverseTracks();
                  }
                  if (!trackFound) {
                    logger["logger"].error("No track found for running audio group-ID: " + this.audioGroupId);
                    this.hls.trigger(events["default"].ERROR, {
                      type: errors["ErrorTypes"].MEDIA_ERROR,
                      details: errors["ErrorDetails"].AUDIO_TRACK_LOAD_ERROR,
                      fatal: true
                    });
                  }
                };
                _proto._needsTrackLoading = function _needsTrackLoading(audioTrack) {
                  var details = audioTrack.details, url = audioTrack.url;
                  if (!details || details.live) {
                    return !!url;
                  }
                  return false;
                };
                _proto._loadTrackDetailsIfNeeded = function _loadTrackDetailsIfNeeded(audioTrack) {
                  if (this._needsTrackLoading(audioTrack)) {
                    var url = audioTrack.url, id = audioTrack.id;
                    logger["logger"].log("loading audio-track playlist for id: " + id);
                    this.hls.trigger(events["default"].AUDIO_TRACK_LOADING, {
                      url,
                      id
                    });
                  }
                };
                _proto._updateTrack = function _updateTrack(newId) {
                  if (newId < 0 || newId >= this.tracks.length) {
                    return;
                  }
                  this.clearInterval();
                  this._trackId = newId;
                  logger["logger"].log("trying to update audio-track " + newId);
                  var audioTrack = this.tracks[newId];
                  this._loadTrackDetailsIfNeeded(audioTrack);
                };
                _proto._handleLoadError = function _handleLoadError() {
                  this.trackIdBlacklist[this._trackId] = true;
                  var previousId = this._trackId;
                  var _this$tracks$previous = this.tracks[previousId], name = _this$tracks$previous.name, language = _this$tracks$previous.language, groupId = _this$tracks$previous.groupId;
                  logger["logger"].warn("Loading failed on audio track id: " + previousId + ", group-id: " + groupId + ', name/language: "' + name + '" / "' + language + '"');
                  var newId = previousId;
                  for (var i = 0; i < this.tracks.length; i++) {
                    if (this.trackIdBlacklist[i]) {
                      continue;
                    }
                    var newTrack = this.tracks[i];
                    if (newTrack.name === name) {
                      newId = i;
                      break;
                    }
                  }
                  if (newId === previousId) {
                    logger["logger"].warn('No fallback audio-track found for name/language: "' + name + '" / "' + language + '"');
                    return;
                  }
                  logger["logger"].log("Attempting audio-track fallback id:", newId, "group-id:", this.tracks[newId].groupId);
                  this._setAudioTrack(newId);
                };
                audio_track_controller_createClass(AudioTrackController, [{
                  key: "audioTracks",
                  get: function get() {
                    return this.tracks;
                  }
                  /**
                   * @type {number} Index into audio-tracks list of currently selected track.
                   */
                }, {
                  key: "audioTrack",
                  get: function get() {
                    return this._trackId;
                  },
                  set: function set(newId) {
                    this._setAudioTrack(newId);
                    this._selectDefaultTrack = false;
                  }
                }]);
                return AudioTrackController;
              }(TaskLoop);
              var audio_track_controller = audio_track_controller_AudioTrackController;
              function audio_stream_controller_defineProperties(target, props) {
                for (var i = 0; i < props.length; i++) {
                  var descriptor = props[i];
                  descriptor.enumerable = descriptor.enumerable || false;
                  descriptor.configurable = true;
                  if ("value" in descriptor)
                    descriptor.writable = true;
                  Object.defineProperty(target, descriptor.key, descriptor);
                }
              }
              function audio_stream_controller_createClass(Constructor, protoProps, staticProps) {
                if (protoProps)
                  audio_stream_controller_defineProperties(Constructor.prototype, protoProps);
                if (staticProps)
                  audio_stream_controller_defineProperties(Constructor, staticProps);
                return Constructor;
              }
              function audio_stream_controller_inheritsLoose(subClass, superClass) {
                subClass.prototype = Object.create(superClass.prototype);
                subClass.prototype.constructor = subClass;
                subClass.__proto__ = superClass;
              }
              var audio_stream_controller_window = window, audio_stream_controller_performance = audio_stream_controller_window.performance;
              var audio_stream_controller_TICK_INTERVAL = 100;
              var audio_stream_controller_AudioStreamController = function(_BaseStreamController) {
                audio_stream_controller_inheritsLoose(AudioStreamController, _BaseStreamController);
                function AudioStreamController(hls, fragmentTracker) {
                  var _this;
                  _this = _BaseStreamController.call(this, hls, events["default"].MEDIA_ATTACHED, events["default"].MEDIA_DETACHING, events["default"].AUDIO_TRACKS_UPDATED, events["default"].AUDIO_TRACK_SWITCHING, events["default"].AUDIO_TRACK_LOADED, events["default"].KEY_LOADED, events["default"].FRAG_LOADED, events["default"].FRAG_PARSING_INIT_SEGMENT, events["default"].FRAG_PARSING_DATA, events["default"].FRAG_PARSED, events["default"].ERROR, events["default"].BUFFER_RESET, events["default"].BUFFER_CREATED, events["default"].BUFFER_APPENDED, events["default"].BUFFER_FLUSHED, events["default"].INIT_PTS_FOUND) || this;
                  _this.fragmentTracker = fragmentTracker;
                  _this.config = hls.config;
                  _this.audioCodecSwap = false;
                  _this._state = State.STOPPED;
                  _this.initPTS = [];
                  _this.waitingFragment = null;
                  _this.videoTrackCC = null;
                  _this.waitingVideoCC = null;
                  return _this;
                }
                var _proto = AudioStreamController.prototype;
                _proto.onInitPtsFound = function onInitPtsFound(data) {
                  var demuxerId = data.id, cc = data.frag.cc, initPTS = data.initPTS;
                  if (demuxerId === "main") {
                    this.initPTS[cc] = initPTS;
                    this.videoTrackCC = cc;
                    logger["logger"].log("InitPTS for cc: " + cc + " found from main: " + initPTS);
                    if (this.state === State.WAITING_INIT_PTS) {
                      this.tick();
                    }
                  }
                };
                _proto.startLoad = function startLoad(startPosition) {
                  if (this.tracks) {
                    var lastCurrentTime = this.lastCurrentTime;
                    this.stopLoad();
                    this.setInterval(audio_stream_controller_TICK_INTERVAL);
                    this.fragLoadError = 0;
                    if (lastCurrentTime > 0 && startPosition === -1) {
                      logger["logger"].log("audio:override startPosition with lastCurrentTime @" + lastCurrentTime.toFixed(3));
                      this.state = State.IDLE;
                    } else {
                      this.lastCurrentTime = this.startPosition ? this.startPosition : startPosition;
                      this.state = State.STARTING;
                    }
                    this.nextLoadPosition = this.startPosition = this.lastCurrentTime;
                    this.tick();
                  } else {
                    this.startPosition = startPosition;
                    this.state = State.STOPPED;
                  }
                };
                _proto.doTick = function doTick() {
                  var pos, track, trackDetails, hls = this.hls, config = hls.config;
                  switch (this.state) {
                    case State.ERROR:
                    case State.PAUSED:
                    case State.BUFFER_FLUSHING:
                      break;
                    case State.STARTING:
                      this.state = State.WAITING_TRACK;
                      this.loadedmetadata = false;
                      break;
                    case State.IDLE:
                      var tracks = this.tracks;
                      if (!tracks) {
                        break;
                      }
                      if (!this.media && (this.startFragRequested || !config.startFragPrefetch)) {
                        break;
                      }
                      if (this.loadedmetadata) {
                        pos = this.media.currentTime;
                      } else {
                        pos = this.nextLoadPosition;
                        if (pos === void 0) {
                          break;
                        }
                      }
                      var media = this.mediaBuffer ? this.mediaBuffer : this.media;
                      var videoBuffer = this.videoBuffer ? this.videoBuffer : this.media;
                      var maxBufferHole = pos < config.maxBufferHole ? Math.max(MAX_START_GAP_JUMP, config.maxBufferHole) : config.maxBufferHole;
                      var bufferInfo = BufferHelper.bufferInfo(media, pos, maxBufferHole);
                      var mainBufferInfo = BufferHelper.bufferInfo(videoBuffer, pos, maxBufferHole);
                      var bufferLen = bufferInfo.len;
                      var bufferEnd = bufferInfo.end;
                      var fragPrevious = this.fragPrevious;
                      var maxConfigBuffer = Math.min(config.maxBufferLength, config.maxMaxBufferLength);
                      var maxBufLen = Math.max(maxConfigBuffer, mainBufferInfo.len);
                      var audioSwitch = this.audioSwitch;
                      var trackId = this.trackId;
                      if ((bufferLen < maxBufLen || audioSwitch) && trackId < tracks.length) {
                        trackDetails = tracks[trackId].details;
                        if (typeof trackDetails === "undefined") {
                          this.state = State.WAITING_TRACK;
                          break;
                        }
                        if (!audioSwitch && this._streamEnded(bufferInfo, trackDetails)) {
                          this.hls.trigger(events["default"].BUFFER_EOS, {
                            type: "audio"
                          });
                          this.state = State.ENDED;
                          return;
                        }
                        var fragments = trackDetails.fragments, fragLen = fragments.length, start = fragments[0].start, end = fragments[fragLen - 1].start + fragments[fragLen - 1].duration, frag;
                        if (audioSwitch) {
                          if (trackDetails.live && !trackDetails.PTSKnown) {
                            logger["logger"].log("switching audiotrack, live stream, unknown PTS,load first fragment");
                            bufferEnd = 0;
                          } else {
                            bufferEnd = pos;
                            if (trackDetails.PTSKnown && pos < start) {
                              if (bufferInfo.end > start || bufferInfo.nextStart) {
                                logger["logger"].log("alt audio track ahead of main track, seek to start of alt audio track");
                                this.media.currentTime = start + 0.05;
                              } else {
                                return;
                              }
                            }
                          }
                        }
                        if (trackDetails.initSegment && !trackDetails.initSegment.data) {
                          frag = trackDetails.initSegment;
                        } else if (bufferEnd <= start) {
                          frag = fragments[0];
                          if (this.videoTrackCC !== null && frag.cc !== this.videoTrackCC) {
                            frag = findFragWithCC(fragments, this.videoTrackCC);
                          }
                          if (trackDetails.live && frag.loadIdx && frag.loadIdx === this.fragLoadIdx) {
                            var nextBuffered = bufferInfo.nextStart ? bufferInfo.nextStart : start;
                            logger["logger"].log("no alt audio available @currentTime:" + this.media.currentTime + ", seeking @" + (nextBuffered + 0.05));
                            this.media.currentTime = nextBuffered + 0.05;
                            return;
                          }
                        } else {
                          var foundFrag;
                          var maxFragLookUpTolerance = config.maxFragLookUpTolerance;
                          var fragNext = fragPrevious ? fragments[fragPrevious.sn - fragments[0].sn + 1] : void 0;
                          if (bufferEnd < end) {
                            if (bufferEnd > end - maxFragLookUpTolerance) {
                              maxFragLookUpTolerance = 0;
                            }
                            if (fragNext && !fragmentWithinToleranceTest(bufferEnd, maxFragLookUpTolerance, fragNext)) {
                              foundFrag = fragNext;
                            } else {
                              foundFrag = binary_search.search(fragments, function(frag2) {
                                return fragmentWithinToleranceTest(bufferEnd, maxFragLookUpTolerance, frag2);
                              });
                            }
                          } else {
                            foundFrag = fragments[fragLen - 1];
                          }
                          if (foundFrag) {
                            frag = foundFrag;
                            start = foundFrag.start;
                            if (fragPrevious && frag.level === fragPrevious.level && frag.sn === fragPrevious.sn) {
                              if (frag.sn < trackDetails.endSN) {
                                frag = fragments[frag.sn + 1 - trackDetails.startSN];
                                if (this.fragmentTracker.getState(frag) !== FragmentState.OK) {
                                  logger["logger"].log("SN just loaded, load next one: " + frag.sn);
                                }
                              } else {
                                frag = null;
                              }
                            }
                          }
                        }
                        if (frag) {
                          if (frag.encrypted) {
                            logger["logger"].log("Loading key for " + frag.sn + " of [" + trackDetails.startSN + " ," + trackDetails.endSN + "],track " + trackId);
                            this.state = State.KEY_LOADING;
                            hls.trigger(events["default"].KEY_LOADING, {
                              frag
                            });
                          } else {
                            this.fragCurrent = frag;
                            if (audioSwitch || this.fragmentTracker.getState(frag) === FragmentState.NOT_LOADED) {
                              logger["logger"].log("Loading " + frag.sn + ", cc: " + frag.cc + " of [" + trackDetails.startSN + " ," + trackDetails.endSN + "],track " + trackId + ", " + (this.loadedmetadata ? "currentTime" : "nextLoadPosition") + ": " + pos + ", bufferEnd: " + bufferEnd.toFixed(3));
                              if (frag.sn !== "initSegment") {
                                this.startFragRequested = true;
                              }
                              if (Object(number["isFiniteNumber"])(frag.sn)) {
                                this.nextLoadPosition = frag.start + frag.duration;
                              }
                              hls.trigger(events["default"].FRAG_LOADING, {
                                frag
                              });
                              this.state = State.FRAG_LOADING;
                            }
                          }
                        }
                      }
                      break;
                    case State.WAITING_TRACK:
                      track = this.tracks[this.trackId];
                      if (track && track.details) {
                        this.state = State.IDLE;
                      }
                      break;
                    case State.FRAG_LOADING_WAITING_RETRY:
                      var now = audio_stream_controller_performance.now();
                      var retryDate = this.retryDate;
                      media = this.media;
                      var isSeeking = media && media.seeking;
                      if (!retryDate || now >= retryDate || isSeeking) {
                        logger["logger"].log("audioStreamController: retryDate reached, switch back to IDLE state");
                        this.state = State.IDLE;
                      }
                      break;
                    case State.WAITING_INIT_PTS:
                      var waitingFrag = this.waitingFragment;
                      if (waitingFrag) {
                        var waitingFragCC = waitingFrag.frag.cc;
                        if (this.initPTS[waitingFragCC] !== void 0) {
                          this.waitingFragment = null;
                          this.state = State.FRAG_LOADING;
                          this.onFragLoaded(waitingFrag);
                        } else if (this.videoTrackCC !== this.waitingVideoCC) {
                          logger["logger"].log("Waiting fragment cc (" + waitingFragCC + ") cancelled because video is at cc " + this.videoTrackCC);
                          this.clearWaitingFragment();
                        } else {
                          var _bufferInfo = BufferHelper.bufferInfo(this.mediaBuffer, this.media.currentTime, config.maxBufferHole);
                          var waitingFragmentAtPosition = fragmentWithinToleranceTest(_bufferInfo.end, config.maxFragLookUpTolerance, waitingFrag.frag);
                          if (waitingFragmentAtPosition < 0) {
                            logger["logger"].log("Waiting fragment cc (" + waitingFragCC + ") @ " + waitingFrag.frag.start + " cancelled because another fragment at " + _bufferInfo.end + " is needed");
                            this.clearWaitingFragment();
                          }
                        }
                      } else {
                        this.state = State.IDLE;
                      }
                      break;
                    case State.STOPPED:
                    case State.FRAG_LOADING:
                    case State.PARSING:
                    case State.PARSED:
                    case State.ENDED:
                      break;
                    default:
                      break;
                  }
                };
                _proto.clearWaitingFragment = function clearWaitingFragment() {
                  var waitingFrag = this.waitingFragment;
                  if (waitingFrag) {
                    this.fragmentTracker.removeFragment(waitingFrag.frag);
                    this.waitingFragment = null;
                    this.waitingVideoCC = null;
                    this.state = State.IDLE;
                  }
                };
                _proto.onMediaAttached = function onMediaAttached(data) {
                  var media = this.media = this.mediaBuffer = data.media;
                  this.onvseeking = this.onMediaSeeking.bind(this);
                  this.onvended = this.onMediaEnded.bind(this);
                  media.addEventListener("seeking", this.onvseeking);
                  media.addEventListener("ended", this.onvended);
                  var config = this.config;
                  if (this.tracks && config.autoStartLoad) {
                    this.startLoad(config.startPosition);
                  }
                };
                _proto.onMediaDetaching = function onMediaDetaching() {
                  var media = this.media;
                  if (media && media.ended) {
                    logger["logger"].log("MSE detaching and video ended, reset startPosition");
                    this.startPosition = this.lastCurrentTime = 0;
                  }
                  if (media) {
                    media.removeEventListener("seeking", this.onvseeking);
                    media.removeEventListener("ended", this.onvended);
                    this.onvseeking = this.onvseeked = this.onvended = null;
                  }
                  this.media = this.mediaBuffer = this.videoBuffer = null;
                  this.loadedmetadata = false;
                  this.fragmentTracker.removeAllFragments();
                  this.stopLoad();
                };
                _proto.onAudioTracksUpdated = function onAudioTracksUpdated(data) {
                  logger["logger"].log("audio tracks updated");
                  this.tracks = data.audioTracks;
                };
                _proto.onAudioTrackSwitching = function onAudioTrackSwitching(data) {
                  var altAudio = !!data.url;
                  this.trackId = data.id;
                  this.fragCurrent = null;
                  this.clearWaitingFragment();
                  this.state = State.PAUSED;
                  if (!altAudio) {
                    if (this.demuxer) {
                      this.demuxer.destroy();
                      this.demuxer = null;
                    }
                  } else {
                    this.setInterval(audio_stream_controller_TICK_INTERVAL);
                  }
                  if (altAudio) {
                    this.audioSwitch = true;
                    this.state = State.IDLE;
                  }
                  this.tick();
                };
                _proto.onAudioTrackLoaded = function onAudioTrackLoaded(data) {
                  var newDetails = data.details, trackId = data.id, track = this.tracks[trackId], curDetails = track.details, duration = newDetails.totalduration, sliding = 0;
                  logger["logger"].log("track " + trackId + " loaded [" + newDetails.startSN + "," + newDetails.endSN + "],duration:" + duration);
                  if (newDetails.live || curDetails && curDetails.live) {
                    if (curDetails && newDetails.fragments.length > 0) {
                      mergeDetails(curDetails, newDetails);
                      sliding = newDetails.fragments[0].start;
                      if (newDetails.PTSKnown) {
                        logger["logger"].log("live audio playlist sliding:" + sliding.toFixed(3));
                      } else {
                        logger["logger"].log("live audio playlist - outdated PTS, unknown sliding");
                      }
                    } else {
                      newDetails.PTSKnown = false;
                      logger["logger"].log("live audio playlist - first load, unknown sliding");
                    }
                  } else {
                    newDetails.PTSKnown = false;
                  }
                  track.details = newDetails;
                  if (!this.startFragRequested) {
                    if (this.startPosition === -1) {
                      var startTimeOffset = newDetails.startTimeOffset;
                      if (Object(number["isFiniteNumber"])(startTimeOffset)) {
                        logger["logger"].log("start time offset found in playlist, adjust startPosition to " + startTimeOffset);
                        this.startPosition = startTimeOffset;
                      } else {
                        if (newDetails.live) {
                          this.startPosition = this.computeLivePosition(sliding, newDetails);
                          logger["logger"].log("compute startPosition for audio-track to " + this.startPosition);
                        } else {
                          this.startPosition = 0;
                        }
                      }
                    }
                    this.nextLoadPosition = this.startPosition;
                  }
                  if (this.state === State.WAITING_TRACK) {
                    this.state = State.IDLE;
                  }
                  this.tick();
                };
                _proto.onKeyLoaded = function onKeyLoaded() {
                  if (this.state === State.KEY_LOADING) {
                    this.state = State.IDLE;
                    this.tick();
                  }
                };
                _proto.onFragLoaded = function onFragLoaded(data) {
                  var fragCurrent = this.fragCurrent, fragLoaded = data.frag;
                  if (this.state === State.FRAG_LOADING && fragCurrent && fragLoaded.type === "audio" && fragLoaded.level === fragCurrent.level && fragLoaded.sn === fragCurrent.sn) {
                    var track = this.tracks[this.trackId], details = track.details, duration = details.totalduration, trackId = fragCurrent.level, sn = fragCurrent.sn, cc = fragCurrent.cc, audioCodec = this.config.defaultAudioCodec || track.audioCodec || "mp4a.40.2", stats = this.stats = data.stats;
                    if (sn === "initSegment") {
                      this.state = State.IDLE;
                      stats.tparsed = stats.tbuffered = audio_stream_controller_performance.now();
                      details.initSegment.data = data.payload;
                      this.hls.trigger(events["default"].FRAG_BUFFERED, {
                        stats,
                        frag: fragCurrent,
                        id: "audio"
                      });
                      this.tick();
                    } else {
                      this.state = State.PARSING;
                      this.appended = false;
                      if (!this.demuxer) {
                        this.demuxer = new demux_demuxer(this.hls, "audio");
                      }
                      var initPTS = this.initPTS[cc];
                      var initSegmentData = details.initSegment ? details.initSegment.data : [];
                      if (initPTS !== void 0) {
                        this.pendingBuffering = true;
                        logger["logger"].log("Demuxing " + sn + " of [" + details.startSN + " ," + details.endSN + "],track " + trackId);
                        var accurateTimeOffset = false;
                        this.demuxer.push(data.payload, initSegmentData, audioCodec, null, fragCurrent, duration, accurateTimeOffset, initPTS);
                      } else {
                        logger["logger"].log("Unknown video PTS for cc " + cc + ", waiting for video PTS before demuxing audio frag " + sn + " of [" + details.startSN + " ," + details.endSN + "],track " + trackId);
                        this.waitingFragment = data;
                        this.waitingVideoCC = this.videoTrackCC;
                        this.state = State.WAITING_INIT_PTS;
                      }
                    }
                  }
                  this.fragLoadError = 0;
                };
                _proto.onFragParsingInitSegment = function onFragParsingInitSegment(data) {
                  var fragCurrent = this.fragCurrent;
                  var fragNew = data.frag;
                  if (fragCurrent && data.id === "audio" && fragNew.sn === fragCurrent.sn && fragNew.level === fragCurrent.level && this.state === State.PARSING) {
                    var tracks = data.tracks, track;
                    if (tracks.video) {
                      delete tracks.video;
                    }
                    track = tracks.audio;
                    if (track) {
                      track.levelCodec = track.codec;
                      track.id = data.id;
                      this.hls.trigger(events["default"].BUFFER_CODECS, tracks);
                      logger["logger"].log("audio track:audio,container:" + track.container + ",codecs[level/parsed]=[" + track.levelCodec + "/" + track.codec + "]");
                      var initSegment = track.initSegment;
                      if (initSegment) {
                        var appendObj = {
                          type: "audio",
                          data: initSegment,
                          parent: "audio",
                          content: "initSegment"
                        };
                        if (this.audioSwitch) {
                          this.pendingData = [appendObj];
                        } else {
                          this.appended = true;
                          this.pendingBuffering = true;
                          this.hls.trigger(events["default"].BUFFER_APPENDING, appendObj);
                        }
                      }
                      this.tick();
                    }
                  }
                };
                _proto.onFragParsingData = function onFragParsingData(data) {
                  var _this2 = this;
                  var fragCurrent = this.fragCurrent;
                  var fragNew = data.frag;
                  if (fragCurrent && data.id === "audio" && data.type === "audio" && fragNew.sn === fragCurrent.sn && fragNew.level === fragCurrent.level && this.state === State.PARSING) {
                    var trackId = this.trackId, track = this.tracks[trackId], hls = this.hls;
                    if (!Object(number["isFiniteNumber"])(data.endPTS)) {
                      data.endPTS = data.startPTS + fragCurrent.duration;
                      data.endDTS = data.startDTS + fragCurrent.duration;
                    }
                    fragCurrent.addElementaryStream(ElementaryStreamTypes.AUDIO);
                    logger["logger"].log("parsed " + data.type + ",PTS:[" + data.startPTS.toFixed(3) + "," + data.endPTS.toFixed(3) + "],DTS:[" + data.startDTS.toFixed(3) + "/" + data.endDTS.toFixed(3) + "],nb:" + data.nb);
                    updateFragPTSDTS(track.details, fragCurrent, data.startPTS, data.endPTS);
                    var media = this.media;
                    var appendOnBufferFlush = false;
                    if (this.audioSwitch) {
                      if (media && media.readyState) {
                        var currentTime = media.currentTime;
                        logger["logger"].log("switching audio track : currentTime:" + currentTime);
                        if (currentTime >= data.startPTS) {
                          logger["logger"].log("switching audio track : flushing all audio");
                          this.state = State.BUFFER_FLUSHING;
                          hls.trigger(events["default"].BUFFER_FLUSHING, {
                            startOffset: 0,
                            endOffset: Number.POSITIVE_INFINITY,
                            type: "audio"
                          });
                          appendOnBufferFlush = true;
                          this.audioSwitch = false;
                          hls.trigger(events["default"].AUDIO_TRACK_SWITCHED, {
                            id: trackId
                          });
                        }
                      } else {
                        this.audioSwitch = false;
                        hls.trigger(events["default"].AUDIO_TRACK_SWITCHED, {
                          id: trackId
                        });
                      }
                    }
                    var pendingData = this.pendingData;
                    if (!pendingData) {
                      logger["logger"].warn("Apparently attempt to enqueue media payload without codec initialization data upfront");
                      hls.trigger(events["default"].ERROR, {
                        type: errors["ErrorTypes"].MEDIA_ERROR,
                        details: null,
                        fatal: true
                      });
                      return;
                    }
                    if (!this.audioSwitch) {
                      [data.data1, data.data2].forEach(function(buffer) {
                        if (buffer && buffer.length) {
                          pendingData.push({
                            type: data.type,
                            data: buffer,
                            parent: "audio",
                            content: "data"
                          });
                        }
                      });
                      if (!appendOnBufferFlush && pendingData.length) {
                        pendingData.forEach(function(appendObj) {
                          if (_this2.state === State.PARSING) {
                            _this2.pendingBuffering = true;
                            _this2.hls.trigger(events["default"].BUFFER_APPENDING, appendObj);
                          }
                        });
                        this.pendingData = [];
                        this.appended = true;
                      }
                    }
                    this.tick();
                  }
                };
                _proto.onFragParsed = function onFragParsed(data) {
                  var fragCurrent = this.fragCurrent;
                  var fragNew = data.frag;
                  if (fragCurrent && data.id === "audio" && fragNew.sn === fragCurrent.sn && fragNew.level === fragCurrent.level && this.state === State.PARSING) {
                    this.stats.tparsed = audio_stream_controller_performance.now();
                    this.state = State.PARSED;
                    this._checkAppendedParsed();
                  }
                };
                _proto.onBufferReset = function onBufferReset() {
                  this.mediaBuffer = this.videoBuffer = null;
                  this.loadedmetadata = false;
                };
                _proto.onBufferCreated = function onBufferCreated(data) {
                  var audioTrack = data.tracks.audio;
                  if (audioTrack) {
                    this.mediaBuffer = audioTrack.buffer;
                    this.loadedmetadata = true;
                  }
                  if (data.tracks.video) {
                    this.videoBuffer = data.tracks.video.buffer;
                  }
                };
                _proto.onBufferAppended = function onBufferAppended(data) {
                  if (data.parent === "audio") {
                    var state = this.state;
                    if (state === State.PARSING || state === State.PARSED) {
                      this.pendingBuffering = data.pending > 0;
                      this._checkAppendedParsed();
                    }
                  }
                };
                _proto._checkAppendedParsed = function _checkAppendedParsed() {
                  if (this.state === State.PARSED && (!this.appended || !this.pendingBuffering)) {
                    var frag = this.fragCurrent, stats = this.stats, hls = this.hls;
                    if (frag) {
                      this.fragPrevious = frag;
                      stats.tbuffered = audio_stream_controller_performance.now();
                      hls.trigger(events["default"].FRAG_BUFFERED, {
                        stats,
                        frag,
                        id: "audio"
                      });
                      var media = this.mediaBuffer ? this.mediaBuffer : this.media;
                      if (media) {
                        logger["logger"].log("audio buffered : " + time_ranges.toString(media.buffered));
                      }
                      if (this.audioSwitch && this.appended) {
                        this.audioSwitch = false;
                        hls.trigger(events["default"].AUDIO_TRACK_SWITCHED, {
                          id: this.trackId
                        });
                      }
                      this.state = State.IDLE;
                    }
                    this.tick();
                  }
                };
                _proto.onError = function onError(data) {
                  var frag = data.frag;
                  if (frag && frag.type !== "audio") {
                    return;
                  }
                  switch (data.details) {
                    case errors["ErrorDetails"].FRAG_LOAD_ERROR:
                    case errors["ErrorDetails"].FRAG_LOAD_TIMEOUT:
                      var _frag = data.frag;
                      if (_frag && _frag.type !== "audio") {
                        break;
                      }
                      if (!data.fatal) {
                        var loadError = this.fragLoadError;
                        if (loadError) {
                          loadError++;
                        } else {
                          loadError = 1;
                        }
                        var config = this.config;
                        if (loadError <= config.fragLoadingMaxRetry) {
                          this.fragLoadError = loadError;
                          var delay = Math.min(Math.pow(2, loadError - 1) * config.fragLoadingRetryDelay, config.fragLoadingMaxRetryTimeout);
                          logger["logger"].warn("AudioStreamController: frag loading failed, retry in " + delay + " ms");
                          this.retryDate = audio_stream_controller_performance.now() + delay;
                          this.state = State.FRAG_LOADING_WAITING_RETRY;
                        } else {
                          logger["logger"].error("AudioStreamController: " + data.details + " reaches max retry, redispatch as fatal ...");
                          data.fatal = true;
                          this.state = State.ERROR;
                        }
                      }
                      break;
                    case errors["ErrorDetails"].AUDIO_TRACK_LOAD_ERROR:
                    case errors["ErrorDetails"].AUDIO_TRACK_LOAD_TIMEOUT:
                    case errors["ErrorDetails"].KEY_LOAD_ERROR:
                    case errors["ErrorDetails"].KEY_LOAD_TIMEOUT:
                      if (this.state !== State.ERROR) {
                        this.state = data.fatal ? State.ERROR : State.IDLE;
                        logger["logger"].warn("AudioStreamController: " + data.details + " while loading frag, now switching to " + this.state + " state ...");
                      }
                      break;
                    case errors["ErrorDetails"].BUFFER_FULL_ERROR:
                      if (data.parent === "audio" && (this.state === State.PARSING || this.state === State.PARSED)) {
                        var media = this.mediaBuffer, currentTime = this.media.currentTime, mediaBuffered = media && BufferHelper.isBuffered(media, currentTime) && BufferHelper.isBuffered(media, currentTime + 0.5);
                        if (mediaBuffered) {
                          var _config = this.config;
                          if (_config.maxMaxBufferLength >= _config.maxBufferLength) {
                            _config.maxMaxBufferLength /= 2;
                            logger["logger"].warn("AudioStreamController: reduce max buffer length to " + _config.maxMaxBufferLength + "s");
                          }
                          this.state = State.IDLE;
                        } else {
                          logger["logger"].warn("AudioStreamController: buffer full error also media.currentTime is not buffered, flush audio buffer");
                          this.fragCurrent = null;
                          this.state = State.BUFFER_FLUSHING;
                          this.hls.trigger(events["default"].BUFFER_FLUSHING, {
                            startOffset: 0,
                            endOffset: Number.POSITIVE_INFINITY,
                            type: "audio"
                          });
                        }
                      }
                      break;
                    default:
                      break;
                  }
                };
                _proto.onBufferFlushed = function onBufferFlushed() {
                  var _this3 = this;
                  var pendingData = this.pendingData;
                  if (pendingData && pendingData.length) {
                    logger["logger"].log("AudioStreamController: appending pending audio data after buffer flushed");
                    pendingData.forEach(function(appendObj) {
                      _this3.hls.trigger(events["default"].BUFFER_APPENDING, appendObj);
                    });
                    this.appended = true;
                    this.pendingData = [];
                    this.state = State.PARSED;
                  } else {
                    this.state = State.IDLE;
                    this.fragPrevious = null;
                    this.tick();
                  }
                };
                audio_stream_controller_createClass(AudioStreamController, [{
                  key: "state",
                  set: function set(nextState) {
                    if (this.state !== nextState) {
                      var previousState = this.state;
                      this._state = nextState;
                      logger["logger"].log("audio stream:" + previousState + "->" + nextState);
                    }
                  },
                  get: function get() {
                    return this._state;
                  }
                }]);
                return AudioStreamController;
              }(base_stream_controller_BaseStreamController);
              var audio_stream_controller = audio_stream_controller_AudioStreamController;
              var vttcue = function() {
                if (typeof window !== "undefined" && window.VTTCue) {
                  return window.VTTCue;
                }
                var autoKeyword = "auto";
                var directionSetting = {
                  "": true,
                  lr: true,
                  rl: true
                };
                var alignSetting = {
                  start: true,
                  middle: true,
                  end: true,
                  left: true,
                  right: true
                };
                function findDirectionSetting(value) {
                  if (typeof value !== "string") {
                    return false;
                  }
                  var dir = directionSetting[value.toLowerCase()];
                  return dir ? value.toLowerCase() : false;
                }
                function findAlignSetting(value) {
                  if (typeof value !== "string") {
                    return false;
                  }
                  var align = alignSetting[value.toLowerCase()];
                  return align ? value.toLowerCase() : false;
                }
                function extend(obj) {
                  var i = 1;
                  for (; i < arguments.length; i++) {
                    var cobj = arguments[i];
                    for (var p in cobj) {
                      obj[p] = cobj[p];
                    }
                  }
                  return obj;
                }
                function VTTCue(startTime, endTime, text) {
                  var cue = this;
                  var baseObj = {};
                  baseObj.enumerable = true;
                  cue.hasBeenReset = false;
                  var _id = "";
                  var _pauseOnExit = false;
                  var _startTime = startTime;
                  var _endTime = endTime;
                  var _text = text;
                  var _region = null;
                  var _vertical = "";
                  var _snapToLines = true;
                  var _line = "auto";
                  var _lineAlign = "start";
                  var _position = 50;
                  var _positionAlign = "middle";
                  var _size = 50;
                  var _align = "middle";
                  Object.defineProperty(cue, "id", extend({}, baseObj, {
                    get: function get() {
                      return _id;
                    },
                    set: function set(value) {
                      _id = "" + value;
                    }
                  }));
                  Object.defineProperty(cue, "pauseOnExit", extend({}, baseObj, {
                    get: function get() {
                      return _pauseOnExit;
                    },
                    set: function set(value) {
                      _pauseOnExit = !!value;
                    }
                  }));
                  Object.defineProperty(cue, "startTime", extend({}, baseObj, {
                    get: function get() {
                      return _startTime;
                    },
                    set: function set(value) {
                      if (typeof value !== "number") {
                        throw new TypeError("Start time must be set to a number.");
                      }
                      _startTime = value;
                      this.hasBeenReset = true;
                    }
                  }));
                  Object.defineProperty(cue, "endTime", extend({}, baseObj, {
                    get: function get() {
                      return _endTime;
                    },
                    set: function set(value) {
                      if (typeof value !== "number") {
                        throw new TypeError("End time must be set to a number.");
                      }
                      _endTime = value;
                      this.hasBeenReset = true;
                    }
                  }));
                  Object.defineProperty(cue, "text", extend({}, baseObj, {
                    get: function get() {
                      return _text;
                    },
                    set: function set(value) {
                      _text = "" + value;
                      this.hasBeenReset = true;
                    }
                  }));
                  Object.defineProperty(cue, "region", extend({}, baseObj, {
                    get: function get() {
                      return _region;
                    },
                    set: function set(value) {
                      _region = value;
                      this.hasBeenReset = true;
                    }
                  }));
                  Object.defineProperty(cue, "vertical", extend({}, baseObj, {
                    get: function get() {
                      return _vertical;
                    },
                    set: function set(value) {
                      var setting = findDirectionSetting(value);
                      if (setting === false) {
                        throw new SyntaxError("An invalid or illegal string was specified.");
                      }
                      _vertical = setting;
                      this.hasBeenReset = true;
                    }
                  }));
                  Object.defineProperty(cue, "snapToLines", extend({}, baseObj, {
                    get: function get() {
                      return _snapToLines;
                    },
                    set: function set(value) {
                      _snapToLines = !!value;
                      this.hasBeenReset = true;
                    }
                  }));
                  Object.defineProperty(cue, "line", extend({}, baseObj, {
                    get: function get() {
                      return _line;
                    },
                    set: function set(value) {
                      if (typeof value !== "number" && value !== autoKeyword) {
                        throw new SyntaxError("An invalid number or illegal string was specified.");
                      }
                      _line = value;
                      this.hasBeenReset = true;
                    }
                  }));
                  Object.defineProperty(cue, "lineAlign", extend({}, baseObj, {
                    get: function get() {
                      return _lineAlign;
                    },
                    set: function set(value) {
                      var setting = findAlignSetting(value);
                      if (!setting) {
                        throw new SyntaxError("An invalid or illegal string was specified.");
                      }
                      _lineAlign = setting;
                      this.hasBeenReset = true;
                    }
                  }));
                  Object.defineProperty(cue, "position", extend({}, baseObj, {
                    get: function get() {
                      return _position;
                    },
                    set: function set(value) {
                      if (value < 0 || value > 100) {
                        throw new Error("Position must be between 0 and 100.");
                      }
                      _position = value;
                      this.hasBeenReset = true;
                    }
                  }));
                  Object.defineProperty(cue, "positionAlign", extend({}, baseObj, {
                    get: function get() {
                      return _positionAlign;
                    },
                    set: function set(value) {
                      var setting = findAlignSetting(value);
                      if (!setting) {
                        throw new SyntaxError("An invalid or illegal string was specified.");
                      }
                      _positionAlign = setting;
                      this.hasBeenReset = true;
                    }
                  }));
                  Object.defineProperty(cue, "size", extend({}, baseObj, {
                    get: function get() {
                      return _size;
                    },
                    set: function set(value) {
                      if (value < 0 || value > 100) {
                        throw new Error("Size must be between 0 and 100.");
                      }
                      _size = value;
                      this.hasBeenReset = true;
                    }
                  }));
                  Object.defineProperty(cue, "align", extend({}, baseObj, {
                    get: function get() {
                      return _align;
                    },
                    set: function set(value) {
                      var setting = findAlignSetting(value);
                      if (!setting) {
                        throw new SyntaxError("An invalid or illegal string was specified.");
                      }
                      _align = setting;
                      this.hasBeenReset = true;
                    }
                  }));
                  cue.displayState = void 0;
                }
                VTTCue.prototype.getCueAsHTML = function() {
                  var WebVTT = window.WebVTT;
                  return WebVTT.convertCueToDOMTree(window, this.text);
                };
                return VTTCue;
              }();
              var StringDecoder = function StringDecoder2() {
                return {
                  decode: function decode(data) {
                    if (!data) {
                      return "";
                    }
                    if (typeof data !== "string") {
                      throw new Error("Error - expected string data.");
                    }
                    return decodeURIComponent(encodeURIComponent(data));
                  }
                };
              };
              function VTTParser() {
                this.window = window;
                this.state = "INITIAL";
                this.buffer = "";
                this.decoder = new StringDecoder();
                this.regionList = [];
              }
              function parseTimeStamp(input) {
                function computeSeconds(h, m2, s, f) {
                  return (h | 0) * 3600 + (m2 | 0) * 60 + (s | 0) + (f | 0) / 1e3;
                }
                var m = input.match(/^(\d+):(\d{2})(:\d{2})?\.(\d{3})/);
                if (!m) {
                  return null;
                }
                if (m[3]) {
                  return computeSeconds(m[1], m[2], m[3].replace(":", ""), m[4]);
                } else if (m[1] > 59) {
                  return computeSeconds(m[1], m[2], 0, m[4]);
                } else {
                  return computeSeconds(0, m[1], m[2], m[4]);
                }
              }
              function Settings() {
                this.values = /* @__PURE__ */ Object.create(null);
              }
              Settings.prototype = {
                // Only accept the first assignment to any key.
                set: function set(k, v) {
                  if (!this.get(k) && v !== "") {
                    this.values[k] = v;
                  }
                },
                // Return the value for a key, or a default value.
                // If 'defaultKey' is passed then 'dflt' is assumed to be an object with
                // a number of possible default values as properties where 'defaultKey' is
                // the key of the property that will be chosen; otherwise it's assumed to be
                // a single value.
                get: function get(k, dflt, defaultKey) {
                  if (defaultKey) {
                    return this.has(k) ? this.values[k] : dflt[defaultKey];
                  }
                  return this.has(k) ? this.values[k] : dflt;
                },
                // Check whether we have a value for a key.
                has: function has(k) {
                  return k in this.values;
                },
                // Accept a setting if its one of the given alternatives.
                alt: function alt(k, v, a) {
                  for (var n = 0; n < a.length; ++n) {
                    if (v === a[n]) {
                      this.set(k, v);
                      break;
                    }
                  }
                },
                // Accept a setting if its a valid (signed) integer.
                integer: function integer(k, v) {
                  if (/^-?\d+$/.test(v)) {
                    this.set(k, parseInt(v, 10));
                  }
                },
                // Accept a setting if its a valid percentage.
                percent: function percent(k, v) {
                  var m;
                  if (m = v.match(/^([\d]{1,3})(\.[\d]*)?%$/)) {
                    v = parseFloat(v);
                    if (v >= 0 && v <= 100) {
                      this.set(k, v);
                      return true;
                    }
                  }
                  return false;
                }
              };
              function parseOptions(input, callback, keyValueDelim, groupDelim) {
                var groups = groupDelim ? input.split(groupDelim) : [input];
                for (var i in groups) {
                  if (typeof groups[i] !== "string") {
                    continue;
                  }
                  var kv = groups[i].split(keyValueDelim);
                  if (kv.length !== 2) {
                    continue;
                  }
                  var k = kv[0];
                  var v = kv[1];
                  callback(k, v);
                }
              }
              var defaults = new vttcue(0, 0, 0);
              var center = defaults.align === "middle" ? "middle" : "center";
              function parseCue(input, cue, regionList) {
                var oInput = input;
                function consumeTimeStamp() {
                  var ts = parseTimeStamp(input);
                  if (ts === null) {
                    throw new Error("Malformed timestamp: " + oInput);
                  }
                  input = input.replace(/^[^\sa-zA-Z-]+/, "");
                  return ts;
                }
                function consumeCueSettings(input2, cue2) {
                  var settings = new Settings();
                  parseOptions(input2, function(k, v) {
                    switch (k) {
                      case "region":
                        for (var i = regionList.length - 1; i >= 0; i--) {
                          if (regionList[i].id === v) {
                            settings.set(k, regionList[i].region);
                            break;
                          }
                        }
                        break;
                      case "vertical":
                        settings.alt(k, v, ["rl", "lr"]);
                        break;
                      case "line":
                        var vals = v.split(","), vals0 = vals[0];
                        settings.integer(k, vals0);
                        if (settings.percent(k, vals0)) {
                          settings.set("snapToLines", false);
                        }
                        settings.alt(k, vals0, ["auto"]);
                        if (vals.length === 2) {
                          settings.alt("lineAlign", vals[1], ["start", center, "end"]);
                        }
                        break;
                      case "position":
                        vals = v.split(",");
                        settings.percent(k, vals[0]);
                        if (vals.length === 2) {
                          settings.alt("positionAlign", vals[1], ["start", center, "end", "line-left", "line-right", "auto"]);
                        }
                        break;
                      case "size":
                        settings.percent(k, v);
                        break;
                      case "align":
                        settings.alt(k, v, ["start", center, "end", "left", "right"]);
                        break;
                    }
                  }, /:/, /\s/);
                  cue2.region = settings.get("region", null);
                  cue2.vertical = settings.get("vertical", "");
                  var line = settings.get("line", "auto");
                  if (line === "auto" && defaults.line === -1) {
                    line = -1;
                  }
                  cue2.line = line;
                  cue2.lineAlign = settings.get("lineAlign", "start");
                  cue2.snapToLines = settings.get("snapToLines", true);
                  cue2.size = settings.get("size", 100);
                  cue2.align = settings.get("align", center);
                  var position = settings.get("position", "auto");
                  if (position === "auto" && defaults.position === 50) {
                    position = cue2.align === "start" || cue2.align === "left" ? 0 : cue2.align === "end" || cue2.align === "right" ? 100 : 50;
                  }
                  cue2.position = position;
                }
                function skipWhitespace() {
                  input = input.replace(/^\s+/, "");
                }
                skipWhitespace();
                cue.startTime = consumeTimeStamp();
                skipWhitespace();
                if (input.substr(0, 3) !== "-->") {
                  throw new Error("Malformed time stamp (time stamps must be separated by '-->'): " + oInput);
                }
                input = input.substr(3);
                skipWhitespace();
                cue.endTime = consumeTimeStamp();
                skipWhitespace();
                consumeCueSettings(input, cue);
              }
              function fixLineBreaks(input) {
                return input.replace(/<br(?: \/)?>/gi, "\n");
              }
              VTTParser.prototype = {
                parse: function parse(data) {
                  var self2 = this;
                  if (data) {
                    self2.buffer += self2.decoder.decode(data, {
                      stream: true
                    });
                  }
                  function collectNextLine() {
                    var buffer = self2.buffer;
                    var pos = 0;
                    buffer = fixLineBreaks(buffer);
                    while (pos < buffer.length && buffer[pos] !== "\r" && buffer[pos] !== "\n") {
                      ++pos;
                    }
                    var line2 = buffer.substr(0, pos);
                    if (buffer[pos] === "\r") {
                      ++pos;
                    }
                    if (buffer[pos] === "\n") {
                      ++pos;
                    }
                    self2.buffer = buffer.substr(pos);
                    return line2;
                  }
                  function parseHeader(input) {
                    parseOptions(input, function(k, v) {
                      switch (k) {
                        case "Region":
                          break;
                      }
                    }, /:/);
                  }
                  try {
                    var line;
                    if (self2.state === "INITIAL") {
                      if (!/\r\n|\n/.test(self2.buffer)) {
                        return this;
                      }
                      line = collectNextLine();
                      var m = line.match(/^(ï»¿)?WEBVTT([ \t].*)?$/);
                      if (!m || !m[0]) {
                        throw new Error("Malformed WebVTT signature.");
                      }
                      self2.state = "HEADER";
                    }
                    var alreadyCollectedLine = false;
                    while (self2.buffer) {
                      if (!/\r\n|\n/.test(self2.buffer)) {
                        return this;
                      }
                      if (!alreadyCollectedLine) {
                        line = collectNextLine();
                      } else {
                        alreadyCollectedLine = false;
                      }
                      switch (self2.state) {
                        case "HEADER":
                          if (/:/.test(line)) {
                            parseHeader(line);
                          } else if (!line) {
                            self2.state = "ID";
                          }
                          continue;
                        case "NOTE":
                          if (!line) {
                            self2.state = "ID";
                          }
                          continue;
                        case "ID":
                          if (/^NOTE($|[ \t])/.test(line)) {
                            self2.state = "NOTE";
                            break;
                          }
                          if (!line) {
                            continue;
                          }
                          self2.cue = new vttcue(0, 0, "");
                          self2.state = "CUE";
                          if (line.indexOf("-->") === -1) {
                            self2.cue.id = line;
                            continue;
                          }
                        case "CUE":
                          try {
                            parseCue(line, self2.cue, self2.regionList);
                          } catch (e) {
                            self2.cue = null;
                            self2.state = "BADCUE";
                            continue;
                          }
                          self2.state = "CUETEXT";
                          continue;
                        case "CUETEXT":
                          var hasSubstring = line.indexOf("-->") !== -1;
                          if (!line || hasSubstring && (alreadyCollectedLine = true)) {
                            if (self2.oncue) {
                              self2.oncue(self2.cue);
                            }
                            self2.cue = null;
                            self2.state = "ID";
                            continue;
                          }
                          if (self2.cue.text) {
                            self2.cue.text += "\n";
                          }
                          self2.cue.text += line;
                          continue;
                        case "BADCUE":
                          if (!line) {
                            self2.state = "ID";
                          }
                          continue;
                      }
                    }
                  } catch (e) {
                    if (self2.state === "CUETEXT" && self2.cue && self2.oncue) {
                      self2.oncue(self2.cue);
                    }
                    self2.cue = null;
                    self2.state = self2.state === "INITIAL" ? "BADWEBVTT" : "BADCUE";
                  }
                  return this;
                },
                flush: function flush() {
                  var self2 = this;
                  try {
                    self2.buffer += self2.decoder.decode();
                    if (self2.cue || self2.state === "HEADER") {
                      self2.buffer += "\n\n";
                      self2.parse();
                    }
                    if (self2.state === "INITIAL") {
                      throw new Error("Malformed WebVTT signature.");
                    }
                  } catch (e) {
                    throw e;
                  }
                  if (self2.onflush) {
                    self2.onflush();
                  }
                  return this;
                }
              };
              var vttparser = VTTParser;
              function newCue(track, startTime, endTime, captionScreen) {
                var result = [];
                var row;
                var cue;
                var indenting;
                var indent;
                var text;
                var VTTCue = window.VTTCue || TextTrackCue;
                for (var r = 0; r < captionScreen.rows.length; r++) {
                  row = captionScreen.rows[r];
                  indenting = true;
                  indent = 0;
                  text = "";
                  if (!row.isEmpty()) {
                    for (var c = 0; c < row.chars.length; c++) {
                      if (row.chars[c].uchar.match(/\s/) && indenting) {
                        indent++;
                      } else {
                        text += row.chars[c].uchar;
                        indenting = false;
                      }
                    }
                    row.cueStartTime = startTime;
                    if (startTime === endTime) {
                      endTime += 1e-4;
                    }
                    cue = new VTTCue(startTime, endTime, fixLineBreaks(text.trim()));
                    if (indent >= 16) {
                      indent--;
                    } else {
                      indent++;
                    }
                    if (navigator.userAgent.match(/Firefox\//)) {
                      cue.line = r + 1;
                    } else {
                      cue.line = r > 7 ? r - 2 : r + 1;
                    }
                    cue.align = "left";
                    cue.position = Math.max(0, Math.min(100, 100 * (indent / 32)));
                    result.push(cue);
                    if (track) {
                      track.addCue(cue);
                    }
                  }
                }
                return result;
              }
              var specialCea608CharsCodes = {
                42: 225,
                // lowercase a, acute accent
                92: 233,
                // lowercase e, acute accent
                94: 237,
                // lowercase i, acute accent
                95: 243,
                // lowercase o, acute accent
                96: 250,
                // lowercase u, acute accent
                123: 231,
                // lowercase c with cedilla
                124: 247,
                // division symbol
                125: 209,
                // uppercase N tilde
                126: 241,
                // lowercase n tilde
                127: 9608,
                // Full block
                // THIS BLOCK INCLUDES THE 16 EXTENDED (TWO-BYTE) LINE 21 CHARACTERS
                // THAT COME FROM HI BYTE=0x11 AND LOW BETWEEN 0x30 AND 0x3F
                // THIS MEANS THAT \x50 MUST BE ADDED TO THE VALUES
                128: 174,
                // Registered symbol (R)
                129: 176,
                // degree sign
                130: 189,
                // 1/2 symbol
                131: 191,
                // Inverted (open) question mark
                132: 8482,
                // Trademark symbol (TM)
                133: 162,
                // Cents symbol
                134: 163,
                // Pounds sterling
                135: 9834,
                // Music 8'th note
                136: 224,
                // lowercase a, grave accent
                137: 32,
                // transparent space (regular)
                138: 232,
                // lowercase e, grave accent
                139: 226,
                // lowercase a, circumflex accent
                140: 234,
                // lowercase e, circumflex accent
                141: 238,
                // lowercase i, circumflex accent
                142: 244,
                // lowercase o, circumflex accent
                143: 251,
                // lowercase u, circumflex accent
                // THIS BLOCK INCLUDES THE 32 EXTENDED (TWO-BYTE) LINE 21 CHARACTERS
                // THAT COME FROM HI BYTE=0x12 AND LOW BETWEEN 0x20 AND 0x3F
                144: 193,
                // capital letter A with acute
                145: 201,
                // capital letter E with acute
                146: 211,
                // capital letter O with acute
                147: 218,
                // capital letter U with acute
                148: 220,
                // capital letter U with diaresis
                149: 252,
                // lowercase letter U with diaeresis
                150: 8216,
                // opening single quote
                151: 161,
                // inverted exclamation mark
                152: 42,
                // asterisk
                153: 8217,
                // closing single quote
                154: 9473,
                // box drawings heavy horizontal
                155: 169,
                // copyright sign
                156: 8480,
                // Service mark
                157: 8226,
                // (round) bullet
                158: 8220,
                // Left double quotation mark
                159: 8221,
                // Right double quotation mark
                160: 192,
                // uppercase A, grave accent
                161: 194,
                // uppercase A, circumflex
                162: 199,
                // uppercase C with cedilla
                163: 200,
                // uppercase E, grave accent
                164: 202,
                // uppercase E, circumflex
                165: 203,
                // capital letter E with diaresis
                166: 235,
                // lowercase letter e with diaresis
                167: 206,
                // uppercase I, circumflex
                168: 207,
                // uppercase I, with diaresis
                169: 239,
                // lowercase i, with diaresis
                170: 212,
                // uppercase O, circumflex
                171: 217,
                // uppercase U, grave accent
                172: 249,
                // lowercase u, grave accent
                173: 219,
                // uppercase U, circumflex
                174: 171,
                // left-pointing double angle quotation mark
                175: 187,
                // right-pointing double angle quotation mark
                // THIS BLOCK INCLUDES THE 32 EXTENDED (TWO-BYTE) LINE 21 CHARACTERS
                // THAT COME FROM HI BYTE=0x13 AND LOW BETWEEN 0x20 AND 0x3F
                176: 195,
                // Uppercase A, tilde
                177: 227,
                // Lowercase a, tilde
                178: 205,
                // Uppercase I, acute accent
                179: 204,
                // Uppercase I, grave accent
                180: 236,
                // Lowercase i, grave accent
                181: 210,
                // Uppercase O, grave accent
                182: 242,
                // Lowercase o, grave accent
                183: 213,
                // Uppercase O, tilde
                184: 245,
                // Lowercase o, tilde
                185: 123,
                // Open curly brace
                186: 125,
                // Closing curly brace
                187: 92,
                // Backslash
                188: 94,
                // Caret
                189: 95,
                // Underscore
                190: 124,
                // Pipe (vertical line)
                191: 8764,
                // Tilde operator
                192: 196,
                // Uppercase A, umlaut
                193: 228,
                // Lowercase A, umlaut
                194: 214,
                // Uppercase O, umlaut
                195: 246,
                // Lowercase o, umlaut
                196: 223,
                // Esszett (sharp S)
                197: 165,
                // Yen symbol
                198: 164,
                // Generic currency sign
                199: 9475,
                // Box drawings heavy vertical
                200: 197,
                // Uppercase A, ring
                201: 229,
                // Lowercase A, ring
                202: 216,
                // Uppercase O, stroke
                203: 248,
                // Lowercase o, strok
                204: 9487,
                // Box drawings heavy down and right
                205: 9491,
                // Box drawings heavy down and left
                206: 9495,
                // Box drawings heavy up and right
                207: 9499
                // Box drawings heavy up and left
              };
              var getCharForByte = function getCharForByte2(_byte) {
                var charCode = _byte;
                if (specialCea608CharsCodes.hasOwnProperty(_byte)) {
                  charCode = specialCea608CharsCodes[_byte];
                }
                return String.fromCharCode(charCode);
              };
              var NR_ROWS = 15;
              var NR_COLS = 100;
              var rowsLowCh1 = {
                17: 1,
                18: 3,
                21: 5,
                22: 7,
                23: 9,
                16: 11,
                19: 12,
                20: 14
              };
              var rowsHighCh1 = {
                17: 2,
                18: 4,
                21: 6,
                22: 8,
                23: 10,
                19: 13,
                20: 15
              };
              var rowsLowCh2 = {
                25: 1,
                26: 3,
                29: 5,
                30: 7,
                31: 9,
                24: 11,
                27: 12,
                28: 14
              };
              var rowsHighCh2 = {
                25: 2,
                26: 4,
                29: 6,
                30: 8,
                31: 10,
                27: 13,
                28: 15
              };
              var backgroundColors = ["white", "green", "blue", "cyan", "red", "yellow", "magenta", "black", "transparent"];
              var VerboseLevel;
              (function(VerboseLevel2) {
                VerboseLevel2[VerboseLevel2["ERROR"] = 0] = "ERROR";
                VerboseLevel2[VerboseLevel2["TEXT"] = 1] = "TEXT";
                VerboseLevel2[VerboseLevel2["WARNING"] = 2] = "WARNING";
                VerboseLevel2[VerboseLevel2["INFO"] = 2] = "INFO";
                VerboseLevel2[VerboseLevel2["DEBUG"] = 3] = "DEBUG";
                VerboseLevel2[VerboseLevel2["DATA"] = 3] = "DATA";
              })(VerboseLevel || (VerboseLevel = {}));
              var cea_608_parser_CaptionsLogger = function() {
                function CaptionsLogger() {
                  this.time = null;
                  this.verboseLevel = VerboseLevel.ERROR;
                }
                var _proto = CaptionsLogger.prototype;
                _proto.log = function log(severity, msg) {
                  if (this.verboseLevel >= severity) {
                    logger["logger"].log(this.time + " [" + severity + "] " + msg);
                  }
                };
                return CaptionsLogger;
              }();
              var numArrayToHexArray = function numArrayToHexArray2(numArray) {
                var hexArray = [];
                for (var j = 0; j < numArray.length; j++) {
                  hexArray.push(numArray[j].toString(16));
                }
                return hexArray;
              };
              var PenState = function() {
                function PenState2(foreground, underline, italics, background, flash) {
                  this.foreground = void 0;
                  this.underline = void 0;
                  this.italics = void 0;
                  this.background = void 0;
                  this.flash = void 0;
                  this.foreground = foreground || "white";
                  this.underline = underline || false;
                  this.italics = italics || false;
                  this.background = background || "black";
                  this.flash = flash || false;
                }
                var _proto2 = PenState2.prototype;
                _proto2.reset = function reset() {
                  this.foreground = "white";
                  this.underline = false;
                  this.italics = false;
                  this.background = "black";
                  this.flash = false;
                };
                _proto2.setStyles = function setStyles(styles) {
                  var attribs = ["foreground", "underline", "italics", "background", "flash"];
                  for (var i = 0; i < attribs.length; i++) {
                    var style = attribs[i];
                    if (styles.hasOwnProperty(style)) {
                      this[style] = styles[style];
                    }
                  }
                };
                _proto2.isDefault = function isDefault() {
                  return this.foreground === "white" && !this.underline && !this.italics && this.background === "black" && !this.flash;
                };
                _proto2.equals = function equals(other) {
                  return this.foreground === other.foreground && this.underline === other.underline && this.italics === other.italics && this.background === other.background && this.flash === other.flash;
                };
                _proto2.copy = function copy(newPenState) {
                  this.foreground = newPenState.foreground;
                  this.underline = newPenState.underline;
                  this.italics = newPenState.italics;
                  this.background = newPenState.background;
                  this.flash = newPenState.flash;
                };
                _proto2.toString = function toString() {
                  return "color=" + this.foreground + ", underline=" + this.underline + ", italics=" + this.italics + ", background=" + this.background + ", flash=" + this.flash;
                };
                return PenState2;
              }();
              var StyledUnicodeChar = function() {
                function StyledUnicodeChar2(uchar, foreground, underline, italics, background, flash) {
                  this.uchar = void 0;
                  this.penState = void 0;
                  this.uchar = uchar || " ";
                  this.penState = new PenState(foreground, underline, italics, background, flash);
                }
                var _proto3 = StyledUnicodeChar2.prototype;
                _proto3.reset = function reset() {
                  this.uchar = " ";
                  this.penState.reset();
                };
                _proto3.setChar = function setChar(uchar, newPenState) {
                  this.uchar = uchar;
                  this.penState.copy(newPenState);
                };
                _proto3.setPenState = function setPenState(newPenState) {
                  this.penState.copy(newPenState);
                };
                _proto3.equals = function equals(other) {
                  return this.uchar === other.uchar && this.penState.equals(other.penState);
                };
                _proto3.copy = function copy(newChar) {
                  this.uchar = newChar.uchar;
                  this.penState.copy(newChar.penState);
                };
                _proto3.isEmpty = function isEmpty() {
                  return this.uchar === " " && this.penState.isDefault();
                };
                return StyledUnicodeChar2;
              }();
              var Row = function() {
                function Row2(logger2) {
                  this.chars = void 0;
                  this.pos = void 0;
                  this.currPenState = void 0;
                  this.cueStartTime = void 0;
                  this.logger = void 0;
                  this.chars = [];
                  for (var i = 0; i < NR_COLS; i++) {
                    this.chars.push(new StyledUnicodeChar());
                  }
                  this.logger = logger2;
                  this.pos = 0;
                  this.currPenState = new PenState();
                }
                var _proto4 = Row2.prototype;
                _proto4.equals = function equals(other) {
                  var equal = true;
                  for (var i = 0; i < NR_COLS; i++) {
                    if (!this.chars[i].equals(other.chars[i])) {
                      equal = false;
                      break;
                    }
                  }
                  return equal;
                };
                _proto4.copy = function copy(other) {
                  for (var i = 0; i < NR_COLS; i++) {
                    this.chars[i].copy(other.chars[i]);
                  }
                };
                _proto4.isEmpty = function isEmpty() {
                  var empty = true;
                  for (var i = 0; i < NR_COLS; i++) {
                    if (!this.chars[i].isEmpty()) {
                      empty = false;
                      break;
                    }
                  }
                  return empty;
                };
                _proto4.setCursor = function setCursor(absPos) {
                  if (this.pos !== absPos) {
                    this.pos = absPos;
                  }
                  if (this.pos < 0) {
                    this.logger.log(VerboseLevel.DEBUG, "Negative cursor position " + this.pos);
                    this.pos = 0;
                  } else if (this.pos > NR_COLS) {
                    this.logger.log(VerboseLevel.DEBUG, "Too large cursor position " + this.pos);
                    this.pos = NR_COLS;
                  }
                };
                _proto4.moveCursor = function moveCursor(relPos) {
                  var newPos = this.pos + relPos;
                  if (relPos > 1) {
                    for (var i = this.pos + 1; i < newPos + 1; i++) {
                      this.chars[i].setPenState(this.currPenState);
                    }
                  }
                  this.setCursor(newPos);
                };
                _proto4.backSpace = function backSpace() {
                  this.moveCursor(-1);
                  this.chars[this.pos].setChar(" ", this.currPenState);
                };
                _proto4.insertChar = function insertChar(_byte2) {
                  if (_byte2 >= 144) {
                    this.backSpace();
                  }
                  var _char = getCharForByte(_byte2);
                  if (this.pos >= NR_COLS) {
                    this.logger.log(VerboseLevel.ERROR, "Cannot insert " + _byte2.toString(16) + " (" + _char + ") at position " + this.pos + ". Skipping it!");
                    return;
                  }
                  this.chars[this.pos].setChar(_char, this.currPenState);
                  this.moveCursor(1);
                };
                _proto4.clearFromPos = function clearFromPos(startPos) {
                  var i;
                  for (i = startPos; i < NR_COLS; i++) {
                    this.chars[i].reset();
                  }
                };
                _proto4.clear = function clear() {
                  this.clearFromPos(0);
                  this.pos = 0;
                  this.currPenState.reset();
                };
                _proto4.clearToEndOfRow = function clearToEndOfRow() {
                  this.clearFromPos(this.pos);
                };
                _proto4.getTextString = function getTextString() {
                  var chars = [];
                  var empty = true;
                  for (var i = 0; i < NR_COLS; i++) {
                    var _char2 = this.chars[i].uchar;
                    if (_char2 !== " ") {
                      empty = false;
                    }
                    chars.push(_char2);
                  }
                  if (empty) {
                    return "";
                  } else {
                    return chars.join("");
                  }
                };
                _proto4.setPenStyles = function setPenStyles(styles) {
                  this.currPenState.setStyles(styles);
                  var currChar = this.chars[this.pos];
                  currChar.setPenState(this.currPenState);
                };
                return Row2;
              }();
              var CaptionScreen = function() {
                function CaptionScreen2(logger2) {
                  this.rows = void 0;
                  this.currRow = void 0;
                  this.nrRollUpRows = void 0;
                  this.lastOutputScreen = void 0;
                  this.logger = void 0;
                  this.rows = [];
                  for (var i = 0; i < NR_ROWS; i++) {
                    this.rows.push(new Row(logger2));
                  }
                  this.logger = logger2;
                  this.currRow = NR_ROWS - 1;
                  this.nrRollUpRows = null;
                  this.lastOutputScreen = null;
                  this.reset();
                }
                var _proto5 = CaptionScreen2.prototype;
                _proto5.reset = function reset() {
                  for (var i = 0; i < NR_ROWS; i++) {
                    this.rows[i].clear();
                  }
                  this.currRow = NR_ROWS - 1;
                };
                _proto5.equals = function equals(other) {
                  var equal = true;
                  for (var i = 0; i < NR_ROWS; i++) {
                    if (!this.rows[i].equals(other.rows[i])) {
                      equal = false;
                      break;
                    }
                  }
                  return equal;
                };
                _proto5.copy = function copy(other) {
                  for (var i = 0; i < NR_ROWS; i++) {
                    this.rows[i].copy(other.rows[i]);
                  }
                };
                _proto5.isEmpty = function isEmpty() {
                  var empty = true;
                  for (var i = 0; i < NR_ROWS; i++) {
                    if (!this.rows[i].isEmpty()) {
                      empty = false;
                      break;
                    }
                  }
                  return empty;
                };
                _proto5.backSpace = function backSpace() {
                  var row = this.rows[this.currRow];
                  row.backSpace();
                };
                _proto5.clearToEndOfRow = function clearToEndOfRow() {
                  var row = this.rows[this.currRow];
                  row.clearToEndOfRow();
                };
                _proto5.insertChar = function insertChar(_char3) {
                  var row = this.rows[this.currRow];
                  row.insertChar(_char3);
                };
                _proto5.setPen = function setPen(styles) {
                  var row = this.rows[this.currRow];
                  row.setPenStyles(styles);
                };
                _proto5.moveCursor = function moveCursor(relPos) {
                  var row = this.rows[this.currRow];
                  row.moveCursor(relPos);
                };
                _proto5.setCursor = function setCursor(absPos) {
                  this.logger.log(VerboseLevel.INFO, "setCursor: " + absPos);
                  var row = this.rows[this.currRow];
                  row.setCursor(absPos);
                };
                _proto5.setPAC = function setPAC(pacData) {
                  this.logger.log(VerboseLevel.INFO, "pacData = " + JSON.stringify(pacData));
                  var newRow = pacData.row - 1;
                  if (this.nrRollUpRows && newRow < this.nrRollUpRows - 1) {
                    newRow = this.nrRollUpRows - 1;
                  }
                  if (this.nrRollUpRows && this.currRow !== newRow) {
                    for (var i = 0; i < NR_ROWS; i++) {
                      this.rows[i].clear();
                    }
                    var topRowIndex = this.currRow + 1 - this.nrRollUpRows;
                    var lastOutputScreen = this.lastOutputScreen;
                    if (lastOutputScreen) {
                      var prevLineTime = lastOutputScreen.rows[topRowIndex].cueStartTime;
                      var time = this.logger.time;
                      if (prevLineTime && time !== null && prevLineTime < time) {
                        for (var _i = 0; _i < this.nrRollUpRows; _i++) {
                          this.rows[newRow - this.nrRollUpRows + _i + 1].copy(lastOutputScreen.rows[topRowIndex + _i]);
                        }
                      }
                    }
                  }
                  this.currRow = newRow;
                  var row = this.rows[this.currRow];
                  if (pacData.indent !== null) {
                    var indent = pacData.indent;
                    var prevPos = Math.max(indent - 1, 0);
                    row.setCursor(pacData.indent);
                    pacData.color = row.chars[prevPos].penState.foreground;
                  }
                  var styles = {
                    foreground: pacData.color,
                    underline: pacData.underline,
                    italics: pacData.italics,
                    background: "black",
                    flash: false
                  };
                  this.setPen(styles);
                };
                _proto5.setBkgData = function setBkgData(bkgData) {
                  this.logger.log(VerboseLevel.INFO, "bkgData = " + JSON.stringify(bkgData));
                  this.backSpace();
                  this.setPen(bkgData);
                  this.insertChar(32);
                };
                _proto5.setRollUpRows = function setRollUpRows(nrRows) {
                  this.nrRollUpRows = nrRows;
                };
                _proto5.rollUp = function rollUp() {
                  if (this.nrRollUpRows === null) {
                    this.logger.log(VerboseLevel.DEBUG, "roll_up but nrRollUpRows not set yet");
                    return;
                  }
                  this.logger.log(VerboseLevel.TEXT, this.getDisplayText());
                  var topRowIndex = this.currRow + 1 - this.nrRollUpRows;
                  var topRow = this.rows.splice(topRowIndex, 1)[0];
                  topRow.clear();
                  this.rows.splice(this.currRow, 0, topRow);
                  this.logger.log(VerboseLevel.INFO, "Rolling up");
                };
                _proto5.getDisplayText = function getDisplayText(asOneRow) {
                  asOneRow = asOneRow || false;
                  var displayText = [];
                  var text = "";
                  var rowNr = -1;
                  for (var i = 0; i < NR_ROWS; i++) {
                    var rowText = this.rows[i].getTextString();
                    if (rowText) {
                      rowNr = i + 1;
                      if (asOneRow) {
                        displayText.push("Row " + rowNr + ": '" + rowText + "'");
                      } else {
                        displayText.push(rowText.trim());
                      }
                    }
                  }
                  if (displayText.length > 0) {
                    if (asOneRow) {
                      text = "[" + displayText.join(" | ") + "]";
                    } else {
                      text = displayText.join("\n");
                    }
                  }
                  return text;
                };
                _proto5.getTextAndFormat = function getTextAndFormat() {
                  return this.rows;
                };
                return CaptionScreen2;
              }();
              var Cea608Channel = function() {
                function Cea608Channel2(channelNumber, outputFilter, logger2) {
                  this.chNr = void 0;
                  this.outputFilter = void 0;
                  this.mode = void 0;
                  this.verbose = void 0;
                  this.displayedMemory = void 0;
                  this.nonDisplayedMemory = void 0;
                  this.lastOutputScreen = void 0;
                  this.currRollUpRow = void 0;
                  this.writeScreen = void 0;
                  this.cueStartTime = void 0;
                  this.logger = void 0;
                  this.chNr = channelNumber;
                  this.outputFilter = outputFilter;
                  this.mode = null;
                  this.verbose = 0;
                  this.displayedMemory = new CaptionScreen(logger2);
                  this.nonDisplayedMemory = new CaptionScreen(logger2);
                  this.lastOutputScreen = new CaptionScreen(logger2);
                  this.currRollUpRow = this.displayedMemory.rows[NR_ROWS - 1];
                  this.writeScreen = this.displayedMemory;
                  this.mode = null;
                  this.cueStartTime = null;
                  this.logger = logger2;
                }
                var _proto6 = Cea608Channel2.prototype;
                _proto6.reset = function reset() {
                  this.mode = null;
                  this.displayedMemory.reset();
                  this.nonDisplayedMemory.reset();
                  this.lastOutputScreen.reset();
                  this.outputFilter.reset();
                  this.currRollUpRow = this.displayedMemory.rows[NR_ROWS - 1];
                  this.writeScreen = this.displayedMemory;
                  this.mode = null;
                  this.cueStartTime = null;
                };
                _proto6.getHandler = function getHandler() {
                  return this.outputFilter;
                };
                _proto6.setHandler = function setHandler(newHandler) {
                  this.outputFilter = newHandler;
                };
                _proto6.setPAC = function setPAC(pacData) {
                  this.writeScreen.setPAC(pacData);
                };
                _proto6.setBkgData = function setBkgData(bkgData) {
                  this.writeScreen.setBkgData(bkgData);
                };
                _proto6.setMode = function setMode(newMode) {
                  if (newMode === this.mode) {
                    return;
                  }
                  this.mode = newMode;
                  this.logger.log(VerboseLevel.INFO, "MODE=" + newMode);
                  if (this.mode === "MODE_POP-ON") {
                    this.writeScreen = this.nonDisplayedMemory;
                  } else {
                    this.writeScreen = this.displayedMemory;
                    this.writeScreen.reset();
                  }
                  if (this.mode !== "MODE_ROLL-UP") {
                    this.displayedMemory.nrRollUpRows = null;
                    this.nonDisplayedMemory.nrRollUpRows = null;
                  }
                  this.mode = newMode;
                };
                _proto6.insertChars = function insertChars(chars) {
                  for (var i = 0; i < chars.length; i++) {
                    this.writeScreen.insertChar(chars[i]);
                  }
                  var screen = this.writeScreen === this.displayedMemory ? "DISP" : "NON_DISP";
                  this.logger.log(VerboseLevel.INFO, screen + ": " + this.writeScreen.getDisplayText(true));
                  if (this.mode === "MODE_PAINT-ON" || this.mode === "MODE_ROLL-UP") {
                    this.logger.log(VerboseLevel.TEXT, "DISPLAYED: " + this.displayedMemory.getDisplayText(true));
                    this.outputDataUpdate();
                  }
                };
                _proto6.ccRCL = function ccRCL() {
                  this.logger.log(VerboseLevel.INFO, "RCL - Resume Caption Loading");
                  this.setMode("MODE_POP-ON");
                };
                _proto6.ccBS = function ccBS() {
                  this.logger.log(VerboseLevel.INFO, "BS - BackSpace");
                  if (this.mode === "MODE_TEXT") {
                    return;
                  }
                  this.writeScreen.backSpace();
                  if (this.writeScreen === this.displayedMemory) {
                    this.outputDataUpdate();
                  }
                };
                _proto6.ccAOF = function ccAOF() {
                };
                _proto6.ccAON = function ccAON() {
                };
                _proto6.ccDER = function ccDER() {
                  this.logger.log(VerboseLevel.INFO, "DER- Delete to End of Row");
                  this.writeScreen.clearToEndOfRow();
                  this.outputDataUpdate();
                };
                _proto6.ccRU = function ccRU(nrRows) {
                  this.logger.log(VerboseLevel.INFO, "RU(" + nrRows + ") - Roll Up");
                  this.writeScreen = this.displayedMemory;
                  this.setMode("MODE_ROLL-UP");
                  this.writeScreen.setRollUpRows(nrRows);
                };
                _proto6.ccFON = function ccFON() {
                  this.logger.log(VerboseLevel.INFO, "FON - Flash On");
                  this.writeScreen.setPen({
                    flash: true
                  });
                };
                _proto6.ccRDC = function ccRDC() {
                  this.logger.log(VerboseLevel.INFO, "RDC - Resume Direct Captioning");
                  this.setMode("MODE_PAINT-ON");
                };
                _proto6.ccTR = function ccTR() {
                  this.logger.log(VerboseLevel.INFO, "TR");
                  this.setMode("MODE_TEXT");
                };
                _proto6.ccRTD = function ccRTD() {
                  this.logger.log(VerboseLevel.INFO, "RTD");
                  this.setMode("MODE_TEXT");
                };
                _proto6.ccEDM = function ccEDM() {
                  this.logger.log(VerboseLevel.INFO, "EDM - Erase Displayed Memory");
                  this.displayedMemory.reset();
                  this.outputDataUpdate(true);
                };
                _proto6.ccCR = function ccCR() {
                  this.logger.log(VerboseLevel.INFO, "CR - Carriage Return");
                  this.writeScreen.rollUp();
                  this.outputDataUpdate(true);
                };
                _proto6.ccENM = function ccENM() {
                  this.logger.log(VerboseLevel.INFO, "ENM - Erase Non-displayed Memory");
                  this.nonDisplayedMemory.reset();
                };
                _proto6.ccEOC = function ccEOC() {
                  this.logger.log(VerboseLevel.INFO, "EOC - End Of Caption");
                  if (this.mode === "MODE_POP-ON") {
                    var tmp = this.displayedMemory;
                    this.displayedMemory = this.nonDisplayedMemory;
                    this.nonDisplayedMemory = tmp;
                    this.writeScreen = this.nonDisplayedMemory;
                    this.logger.log(VerboseLevel.TEXT, "DISP: " + this.displayedMemory.getDisplayText());
                  }
                  this.outputDataUpdate(true);
                };
                _proto6.ccTO = function ccTO(nrCols) {
                  this.logger.log(VerboseLevel.INFO, "TO(" + nrCols + ") - Tab Offset");
                  this.writeScreen.moveCursor(nrCols);
                };
                _proto6.ccMIDROW = function ccMIDROW(secondByte) {
                  var styles = {
                    flash: false
                  };
                  styles.underline = secondByte % 2 === 1;
                  styles.italics = secondByte >= 46;
                  if (!styles.italics) {
                    var colorIndex = Math.floor(secondByte / 2) - 16;
                    var colors = ["white", "green", "blue", "cyan", "red", "yellow", "magenta"];
                    styles.foreground = colors[colorIndex];
                  } else {
                    styles.foreground = "white";
                  }
                  this.logger.log(VerboseLevel.INFO, "MIDROW: " + JSON.stringify(styles));
                  this.writeScreen.setPen(styles);
                };
                _proto6.outputDataUpdate = function outputDataUpdate(dispatch) {
                  if (dispatch === void 0) {
                    dispatch = false;
                  }
                  var time = this.logger.time;
                  if (time === null) {
                    return;
                  }
                  if (this.outputFilter) {
                    if (this.cueStartTime === null && !this.displayedMemory.isEmpty()) {
                      this.cueStartTime = time;
                    } else {
                      if (!this.displayedMemory.equals(this.lastOutputScreen)) {
                        this.outputFilter.newCue(this.cueStartTime, time, this.lastOutputScreen);
                        if (dispatch && this.outputFilter.dispatchCue) {
                          this.outputFilter.dispatchCue();
                        }
                        this.cueStartTime = this.displayedMemory.isEmpty() ? null : time;
                      }
                    }
                    this.lastOutputScreen.copy(this.displayedMemory);
                  }
                };
                _proto6.cueSplitAtTime = function cueSplitAtTime(t) {
                  if (this.outputFilter) {
                    if (!this.displayedMemory.isEmpty()) {
                      if (this.outputFilter.newCue) {
                        this.outputFilter.newCue(this.cueStartTime, t, this.displayedMemory);
                      }
                      this.cueStartTime = t;
                    }
                  }
                };
                return Cea608Channel2;
              }();
              var Cea608Parser = function() {
                function Cea608Parser2(field, out1, out2) {
                  this.channels = void 0;
                  this.currentChannel = 0;
                  this.cmdHistory = void 0;
                  this.logger = void 0;
                  var logger2 = new cea_608_parser_CaptionsLogger();
                  this.channels = [null, new Cea608Channel(field, out1, logger2), new Cea608Channel(field + 1, out2, logger2)];
                  this.cmdHistory = createCmdHistory();
                  this.logger = logger2;
                }
                var _proto7 = Cea608Parser2.prototype;
                _proto7.getHandler = function getHandler(channel) {
                  return this.channels[channel].getHandler();
                };
                _proto7.setHandler = function setHandler(channel, newHandler) {
                  this.channels[channel].setHandler(newHandler);
                };
                _proto7.addData = function addData(time, byteList) {
                  var cmdFound;
                  var a;
                  var b;
                  var charsFound = false;
                  this.logger.time = time;
                  for (var i = 0; i < byteList.length; i += 2) {
                    a = byteList[i] & 127;
                    b = byteList[i + 1] & 127;
                    if (a === 0 && b === 0) {
                      continue;
                    } else {
                      this.logger.log(VerboseLevel.DATA, "[" + numArrayToHexArray([byteList[i], byteList[i + 1]]) + "] -> (" + numArrayToHexArray([a, b]) + ")");
                    }
                    cmdFound = this.parseCmd(a, b);
                    if (!cmdFound) {
                      cmdFound = this.parseMidrow(a, b);
                    }
                    if (!cmdFound) {
                      cmdFound = this.parsePAC(a, b);
                    }
                    if (!cmdFound) {
                      cmdFound = this.parseBackgroundAttributes(a, b);
                    }
                    if (!cmdFound) {
                      charsFound = this.parseChars(a, b);
                      if (charsFound) {
                        var currChNr = this.currentChannel;
                        if (currChNr && currChNr > 0) {
                          var channel = this.channels[currChNr];
                          channel.insertChars(charsFound);
                        } else {
                          this.logger.log(VerboseLevel.WARNING, "No channel found yet. TEXT-MODE?");
                        }
                      }
                    }
                    if (!cmdFound && !charsFound) {
                      this.logger.log(VerboseLevel.WARNING, "Couldn't parse cleaned data " + numArrayToHexArray([a, b]) + " orig: " + numArrayToHexArray([byteList[i], byteList[i + 1]]));
                    }
                  }
                };
                _proto7.parseCmd = function parseCmd(a, b) {
                  var cmdHistory = this.cmdHistory;
                  var cond1 = (a === 20 || a === 28 || a === 21 || a === 29) && b >= 32 && b <= 47;
                  var cond2 = (a === 23 || a === 31) && b >= 33 && b <= 35;
                  if (!(cond1 || cond2)) {
                    return false;
                  }
                  if (hasCmdRepeated(a, b, cmdHistory)) {
                    setLastCmd(null, null, cmdHistory);
                    this.logger.log(VerboseLevel.DEBUG, "Repeated command (" + numArrayToHexArray([a, b]) + ") is dropped");
                    return true;
                  }
                  var chNr = a === 20 || a === 21 || a === 23 ? 1 : 2;
                  var channel = this.channels[chNr];
                  if (a === 20 || a === 21 || a === 28 || a === 29) {
                    if (b === 32) {
                      channel.ccRCL();
                    } else if (b === 33) {
                      channel.ccBS();
                    } else if (b === 34) {
                      channel.ccAOF();
                    } else if (b === 35) {
                      channel.ccAON();
                    } else if (b === 36) {
                      channel.ccDER();
                    } else if (b === 37) {
                      channel.ccRU(2);
                    } else if (b === 38) {
                      channel.ccRU(3);
                    } else if (b === 39) {
                      channel.ccRU(4);
                    } else if (b === 40) {
                      channel.ccFON();
                    } else if (b === 41) {
                      channel.ccRDC();
                    } else if (b === 42) {
                      channel.ccTR();
                    } else if (b === 43) {
                      channel.ccRTD();
                    } else if (b === 44) {
                      channel.ccEDM();
                    } else if (b === 45) {
                      channel.ccCR();
                    } else if (b === 46) {
                      channel.ccENM();
                    } else if (b === 47) {
                      channel.ccEOC();
                    }
                  } else {
                    channel.ccTO(b - 32);
                  }
                  setLastCmd(a, b, cmdHistory);
                  this.currentChannel = chNr;
                  return true;
                };
                _proto7.parseMidrow = function parseMidrow(a, b) {
                  var chNr = 0;
                  if ((a === 17 || a === 25) && b >= 32 && b <= 47) {
                    if (a === 17) {
                      chNr = 1;
                    } else {
                      chNr = 2;
                    }
                    if (chNr !== this.currentChannel) {
                      this.logger.log(VerboseLevel.ERROR, "Mismatch channel in midrow parsing");
                      return false;
                    }
                    var channel = this.channels[chNr];
                    if (!channel) {
                      return false;
                    }
                    channel.ccMIDROW(b);
                    this.logger.log(VerboseLevel.DEBUG, "MIDROW (" + numArrayToHexArray([a, b]) + ")");
                    return true;
                  }
                  return false;
                };
                _proto7.parsePAC = function parsePAC(a, b) {
                  var row;
                  var cmdHistory = this.cmdHistory;
                  var case1 = (a >= 17 && a <= 23 || a >= 25 && a <= 31) && b >= 64 && b <= 127;
                  var case2 = (a === 16 || a === 24) && b >= 64 && b <= 95;
                  if (!(case1 || case2)) {
                    return false;
                  }
                  if (hasCmdRepeated(a, b, cmdHistory)) {
                    setLastCmd(null, null, cmdHistory);
                    return true;
                  }
                  var chNr = a <= 23 ? 1 : 2;
                  if (b >= 64 && b <= 95) {
                    row = chNr === 1 ? rowsLowCh1[a] : rowsLowCh2[a];
                  } else {
                    row = chNr === 1 ? rowsHighCh1[a] : rowsHighCh2[a];
                  }
                  var channel = this.channels[chNr];
                  if (!channel) {
                    return false;
                  }
                  channel.setPAC(this.interpretPAC(row, b));
                  setLastCmd(a, b, cmdHistory);
                  this.currentChannel = chNr;
                  return true;
                };
                _proto7.interpretPAC = function interpretPAC(row, _byte3) {
                  var pacIndex = _byte3;
                  var pacData = {
                    color: null,
                    italics: false,
                    indent: null,
                    underline: false,
                    row
                  };
                  if (_byte3 > 95) {
                    pacIndex = _byte3 - 96;
                  } else {
                    pacIndex = _byte3 - 64;
                  }
                  pacData.underline = (pacIndex & 1) === 1;
                  if (pacIndex <= 13) {
                    pacData.color = ["white", "green", "blue", "cyan", "red", "yellow", "magenta", "white"][Math.floor(pacIndex / 2)];
                  } else if (pacIndex <= 15) {
                    pacData.italics = true;
                    pacData.color = "white";
                  } else {
                    pacData.indent = Math.floor((pacIndex - 16) / 2) * 4;
                  }
                  return pacData;
                };
                _proto7.parseChars = function parseChars(a, b) {
                  var channelNr;
                  var charCodes = null;
                  var charCode1 = null;
                  if (a >= 25) {
                    channelNr = 2;
                    charCode1 = a - 8;
                  } else {
                    channelNr = 1;
                    charCode1 = a;
                  }
                  if (charCode1 >= 17 && charCode1 <= 19) {
                    var oneCode = b;
                    if (charCode1 === 17) {
                      oneCode = b + 80;
                    } else if (charCode1 === 18) {
                      oneCode = b + 112;
                    } else {
                      oneCode = b + 144;
                    }
                    this.logger.log(VerboseLevel.INFO, "Special char '" + getCharForByte(oneCode) + "' in channel " + channelNr);
                    charCodes = [oneCode];
                  } else if (a >= 32 && a <= 127) {
                    charCodes = b === 0 ? [a] : [a, b];
                  }
                  if (charCodes) {
                    var hexCodes = numArrayToHexArray(charCodes);
                    this.logger.log(VerboseLevel.DEBUG, "Char codes =  " + hexCodes.join(","));
                    setLastCmd(a, b, this.cmdHistory);
                  }
                  return charCodes;
                };
                _proto7.parseBackgroundAttributes = function parseBackgroundAttributes(a, b) {
                  var case1 = (a === 16 || a === 24) && b >= 32 && b <= 47;
                  var case2 = (a === 23 || a === 31) && b >= 45 && b <= 47;
                  if (!(case1 || case2)) {
                    return false;
                  }
                  var index;
                  var bkgData = {};
                  if (a === 16 || a === 24) {
                    index = Math.floor((b - 32) / 2);
                    bkgData.background = backgroundColors[index];
                    if (b % 2 === 1) {
                      bkgData.background = bkgData.background + "_semi";
                    }
                  } else if (b === 45) {
                    bkgData.background = "transparent";
                  } else {
                    bkgData.foreground = "black";
                    if (b === 47) {
                      bkgData.underline = true;
                    }
                  }
                  var chNr = a <= 23 ? 1 : 2;
                  var channel = this.channels[chNr];
                  channel.setBkgData(bkgData);
                  setLastCmd(a, b, this.cmdHistory);
                  return true;
                };
                _proto7.reset = function reset() {
                  for (var i = 0; i < Object.keys(this.channels).length; i++) {
                    var channel = this.channels[i];
                    if (channel) {
                      channel.reset();
                    }
                  }
                  this.cmdHistory = createCmdHistory();
                };
                _proto7.cueSplitAtTime = function cueSplitAtTime(t) {
                  for (var i = 0; i < this.channels.length; i++) {
                    var channel = this.channels[i];
                    if (channel) {
                      channel.cueSplitAtTime(t);
                    }
                  }
                };
                return Cea608Parser2;
              }();
              function setLastCmd(a, b, cmdHistory) {
                cmdHistory.a = a;
                cmdHistory.b = b;
              }
              function hasCmdRepeated(a, b, cmdHistory) {
                return cmdHistory.a === a && cmdHistory.b === b;
              }
              function createCmdHistory() {
                return {
                  a: null,
                  b: null
                };
              }
              var cea_608_parser = Cea608Parser;
              var OutputFilter = function() {
                function OutputFilter2(timelineController, trackName) {
                  this.timelineController = void 0;
                  this.cueRanges = [];
                  this.trackName = void 0;
                  this.startTime = null;
                  this.endTime = null;
                  this.screen = null;
                  this.timelineController = timelineController;
                  this.trackName = trackName;
                }
                var _proto = OutputFilter2.prototype;
                _proto.dispatchCue = function dispatchCue() {
                  if (this.startTime === null) {
                    return;
                  }
                  this.timelineController.addCues(this.trackName, this.startTime, this.endTime, this.screen, this.cueRanges);
                  this.startTime = null;
                };
                _proto.newCue = function newCue2(startTime, endTime, screen) {
                  if (this.startTime === null || this.startTime > startTime) {
                    this.startTime = startTime;
                  }
                  this.endTime = endTime;
                  this.screen = screen;
                  this.timelineController.createCaptionsTrack(this.trackName);
                };
                _proto.reset = function reset() {
                  this.cueRanges = [];
                };
                return OutputFilter2;
              }();
              var startsWith = function startsWith2(inputString, searchString, position) {
                return inputString.substr(position || 0, searchString.length) === searchString;
              };
              var webvtt_parser_cueString2millis = function cueString2millis(timeString) {
                var ts = parseInt(timeString.substr(-3));
                var secs = parseInt(timeString.substr(-6, 2));
                var mins = parseInt(timeString.substr(-9, 2));
                var hours = timeString.length > 9 ? parseInt(timeString.substr(0, timeString.indexOf(":"))) : 0;
                if (!Object(number["isFiniteNumber"])(ts) || !Object(number["isFiniteNumber"])(secs) || !Object(number["isFiniteNumber"])(mins) || !Object(number["isFiniteNumber"])(hours)) {
                  throw Error("Malformed X-TIMESTAMP-MAP: Local:" + timeString);
                }
                ts += 1e3 * secs;
                ts += 60 * 1e3 * mins;
                ts += 60 * 60 * 1e3 * hours;
                return ts;
              };
              var hash = function hash2(text) {
                var hash3 = 5381;
                var i = text.length;
                while (i) {
                  hash3 = hash3 * 33 ^ text.charCodeAt(--i);
                }
                return (hash3 >>> 0).toString();
              };
              var calculateOffset = function calculateOffset2(vttCCs, cc, presentationTime) {
                var currCC = vttCCs[cc];
                var prevCC = vttCCs[currCC.prevCC];
                if (!prevCC || !prevCC.new && currCC.new) {
                  vttCCs.ccOffset = vttCCs.presentationOffset = currCC.start;
                  currCC.new = false;
                  return;
                }
                while (prevCC && prevCC.new) {
                  vttCCs.ccOffset += currCC.start - prevCC.start;
                  currCC.new = false;
                  currCC = prevCC;
                  prevCC = vttCCs[currCC.prevCC];
                }
                vttCCs.presentationOffset = presentationTime;
              };
              var WebVTTParser = {
                parse: function parse(vttByteArray, syncPTS, vttCCs, cc, callBack, errorCallBack) {
                  var re = /\r\n|\n\r|\n|\r/g;
                  var vttLines = Object(id3["utf8ArrayToStr"])(new Uint8Array(vttByteArray)).trim().replace(re, "\n").split("\n");
                  var cueTime = "00:00.000";
                  var mpegTs = 0;
                  var localTime = 0;
                  var presentationTime = 0;
                  var cues = [];
                  var parsingError;
                  var inHeader = true;
                  var timestampMap = false;
                  var parser = new vttparser();
                  parser.oncue = function(cue) {
                    var currCC = vttCCs[cc];
                    var cueOffset = vttCCs.ccOffset;
                    if (currCC && currCC.new) {
                      if (localTime !== void 0) {
                        cueOffset = vttCCs.ccOffset = currCC.start;
                      } else {
                        calculateOffset(vttCCs, cc, presentationTime);
                      }
                    }
                    if (presentationTime) {
                      cueOffset = presentationTime - vttCCs.presentationOffset;
                    }
                    if (timestampMap) {
                      cue.startTime += cueOffset - localTime;
                      cue.endTime += cueOffset - localTime;
                    }
                    cue.id = hash(cue.startTime.toString()) + hash(cue.endTime.toString()) + hash(cue.text);
                    cue.text = decodeURIComponent(encodeURIComponent(cue.text));
                    if (cue.endTime > 0) {
                      cues.push(cue);
                    }
                  };
                  parser.onparsingerror = function(e) {
                    parsingError = e;
                  };
                  parser.onflush = function() {
                    if (parsingError && errorCallBack) {
                      errorCallBack(parsingError);
                      return;
                    }
                    callBack(cues);
                  };
                  vttLines.forEach(function(line) {
                    if (inHeader) {
                      if (startsWith(line, "X-TIMESTAMP-MAP=")) {
                        inHeader = false;
                        timestampMap = true;
                        line.substr(16).split(",").forEach(function(timestamp) {
                          if (startsWith(timestamp, "LOCAL:")) {
                            cueTime = timestamp.substr(6);
                          } else if (startsWith(timestamp, "MPEGTS:")) {
                            mpegTs = parseInt(timestamp.substr(7));
                          }
                        });
                        try {
                          if (syncPTS + (vttCCs[cc].start * 9e4 || 0) < 0) {
                            syncPTS += 8589934592;
                          }
                          mpegTs -= syncPTS;
                          localTime = webvtt_parser_cueString2millis(cueTime) / 1e3;
                          presentationTime = mpegTs / 9e4;
                        } catch (e) {
                          timestampMap = false;
                          parsingError = e;
                        }
                        return;
                      } else if (line === "") {
                        inHeader = false;
                      }
                    }
                    parser.parse(line + "\n");
                  });
                  parser.flush();
                }
              };
              var webvtt_parser = WebVTTParser;
              function timeline_controller_assertThisInitialized(self2) {
                if (self2 === void 0) {
                  throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                }
                return self2;
              }
              function timeline_controller_inheritsLoose(subClass, superClass) {
                subClass.prototype = Object.create(superClass.prototype);
                subClass.prototype.constructor = subClass;
                subClass.__proto__ = superClass;
              }
              var timeline_controller_TimelineController = function(_EventHandler) {
                timeline_controller_inheritsLoose(TimelineController, _EventHandler);
                function TimelineController(hls) {
                  var _this;
                  _this = _EventHandler.call(this, hls, events["default"].MEDIA_ATTACHING, events["default"].MEDIA_DETACHING, events["default"].FRAG_PARSING_USERDATA, events["default"].FRAG_DECRYPTED, events["default"].MANIFEST_LOADING, events["default"].MANIFEST_LOADED, events["default"].FRAG_LOADED, events["default"].INIT_PTS_FOUND) || this;
                  _this.media = null;
                  _this.config = void 0;
                  _this.enabled = true;
                  _this.Cues = void 0;
                  _this.textTracks = [];
                  _this.tracks = [];
                  _this.initPTS = [];
                  _this.unparsedVttFrags = [];
                  _this.captionsTracks = {};
                  _this.nonNativeCaptionsTracks = {};
                  _this.captionsProperties = void 0;
                  _this.cea608Parser1 = void 0;
                  _this.cea608Parser2 = void 0;
                  _this.lastSn = -1;
                  _this.prevCC = -1;
                  _this.vttCCs = newVTTCCs();
                  _this.hls = hls;
                  _this.config = hls.config;
                  _this.Cues = hls.config.cueHandler;
                  _this.captionsProperties = {
                    textTrack1: {
                      label: _this.config.captionsTextTrack1Label,
                      languageCode: _this.config.captionsTextTrack1LanguageCode
                    },
                    textTrack2: {
                      label: _this.config.captionsTextTrack2Label,
                      languageCode: _this.config.captionsTextTrack2LanguageCode
                    },
                    textTrack3: {
                      label: _this.config.captionsTextTrack3Label,
                      languageCode: _this.config.captionsTextTrack3LanguageCode
                    },
                    textTrack4: {
                      label: _this.config.captionsTextTrack4Label,
                      languageCode: _this.config.captionsTextTrack4LanguageCode
                    }
                  };
                  if (_this.config.enableCEA708Captions) {
                    var channel1 = new OutputFilter(timeline_controller_assertThisInitialized(_this), "textTrack1");
                    var channel2 = new OutputFilter(timeline_controller_assertThisInitialized(_this), "textTrack2");
                    var channel3 = new OutputFilter(timeline_controller_assertThisInitialized(_this), "textTrack3");
                    var channel4 = new OutputFilter(timeline_controller_assertThisInitialized(_this), "textTrack4");
                    _this.cea608Parser1 = new cea_608_parser(1, channel1, channel2);
                    _this.cea608Parser2 = new cea_608_parser(3, channel3, channel4);
                  }
                  return _this;
                }
                var _proto = TimelineController.prototype;
                _proto.addCues = function addCues(trackName, startTime, endTime, screen, cueRanges) {
                  var merged = false;
                  for (var i = cueRanges.length; i--; ) {
                    var cueRange = cueRanges[i];
                    var overlap = intersection(cueRange[0], cueRange[1], startTime, endTime);
                    if (overlap >= 0) {
                      cueRange[0] = Math.min(cueRange[0], startTime);
                      cueRange[1] = Math.max(cueRange[1], endTime);
                      merged = true;
                      if (overlap / (endTime - startTime) > 0.5) {
                        return;
                      }
                    }
                  }
                  if (!merged) {
                    cueRanges.push([startTime, endTime]);
                  }
                  if (this.config.renderTextTracksNatively) {
                    this.Cues.newCue(this.captionsTracks[trackName], startTime, endTime, screen);
                  } else {
                    var cues = this.Cues.newCue(null, startTime, endTime, screen);
                    this.hls.trigger(events["default"].CUES_PARSED, {
                      type: "captions",
                      cues,
                      track: trackName
                    });
                  }
                };
                _proto.onInitPtsFound = function onInitPtsFound(data) {
                  var _this2 = this;
                  var frag = data.frag, id = data.id, initPTS = data.initPTS;
                  var unparsedVttFrags = this.unparsedVttFrags;
                  if (id === "main") {
                    this.initPTS[frag.cc] = initPTS;
                  }
                  if (unparsedVttFrags.length) {
                    this.unparsedVttFrags = [];
                    unparsedVttFrags.forEach(function(frag2) {
                      _this2.onFragLoaded(frag2);
                    });
                  }
                };
                _proto.getExistingTrack = function getExistingTrack(trackName) {
                  var media = this.media;
                  if (media) {
                    for (var i = 0; i < media.textTracks.length; i++) {
                      var textTrack = media.textTracks[i];
                      if (textTrack[trackName]) {
                        return textTrack;
                      }
                    }
                  }
                  return null;
                };
                _proto.createCaptionsTrack = function createCaptionsTrack(trackName) {
                  if (this.config.renderTextTracksNatively) {
                    this.createNativeTrack(trackName);
                  } else {
                    this.createNonNativeTrack(trackName);
                  }
                };
                _proto.createNativeTrack = function createNativeTrack(trackName) {
                  if (this.captionsTracks[trackName]) {
                    return;
                  }
                  var captionsProperties = this.captionsProperties, captionsTracks = this.captionsTracks, media = this.media;
                  var _captionsProperties$t = captionsProperties[trackName], label = _captionsProperties$t.label, languageCode = _captionsProperties$t.languageCode;
                  var existingTrack = this.getExistingTrack(trackName);
                  if (!existingTrack) {
                    var textTrack = this.createTextTrack("captions", label, languageCode);
                    if (textTrack) {
                      textTrack[trackName] = true;
                      captionsTracks[trackName] = textTrack;
                    }
                  } else {
                    captionsTracks[trackName] = existingTrack;
                    clearCurrentCues(captionsTracks[trackName]);
                    sendAddTrackEvent(captionsTracks[trackName], media);
                  }
                };
                _proto.createNonNativeTrack = function createNonNativeTrack(trackName) {
                  if (this.nonNativeCaptionsTracks[trackName]) {
                    return;
                  }
                  var trackProperties = this.captionsProperties[trackName];
                  if (!trackProperties) {
                    return;
                  }
                  var label = trackProperties.label;
                  var track = {
                    _id: trackName,
                    label,
                    kind: "captions",
                    default: trackProperties.media ? !!trackProperties.media.default : false,
                    closedCaptions: trackProperties.media
                  };
                  this.nonNativeCaptionsTracks[trackName] = track;
                  this.hls.trigger(events["default"].NON_NATIVE_TEXT_TRACKS_FOUND, {
                    tracks: [track]
                  });
                };
                _proto.createTextTrack = function createTextTrack(kind, label, lang) {
                  var media = this.media;
                  if (!media) {
                    return;
                  }
                  return media.addTextTrack(kind, label, lang);
                };
                _proto.destroy = function destroy() {
                  _EventHandler.prototype.destroy.call(this);
                };
                _proto.onMediaAttaching = function onMediaAttaching(data) {
                  this.media = data.media;
                  this._cleanTracks();
                };
                _proto.onMediaDetaching = function onMediaDetaching() {
                  var captionsTracks = this.captionsTracks;
                  Object.keys(captionsTracks).forEach(function(trackName) {
                    clearCurrentCues(captionsTracks[trackName]);
                    delete captionsTracks[trackName];
                  });
                  this.nonNativeCaptionsTracks = {};
                };
                _proto.onManifestLoading = function onManifestLoading() {
                  this.lastSn = -1;
                  this.prevCC = -1;
                  this.vttCCs = newVTTCCs();
                  this._cleanTracks();
                  this.tracks = [];
                  this.captionsTracks = {};
                  this.nonNativeCaptionsTracks = {};
                };
                _proto._cleanTracks = function _cleanTracks() {
                  var media = this.media;
                  if (!media) {
                    return;
                  }
                  var textTracks = media.textTracks;
                  if (textTracks) {
                    for (var i = 0; i < textTracks.length; i++) {
                      clearCurrentCues(textTracks[i]);
                    }
                  }
                };
                _proto.onManifestLoaded = function onManifestLoaded(data) {
                  var _this3 = this;
                  this.textTracks = [];
                  this.unparsedVttFrags = this.unparsedVttFrags || [];
                  this.initPTS = [];
                  if (this.cea608Parser1 && this.cea608Parser2) {
                    this.cea608Parser1.reset();
                    this.cea608Parser2.reset();
                  }
                  if (this.config.enableWebVTT) {
                    var tracks = data.subtitles || [];
                    var sameTracks = this.tracks && tracks && this.tracks.length === tracks.length;
                    this.tracks = data.subtitles || [];
                    if (this.config.renderTextTracksNatively) {
                      var inUseTracks = this.media ? this.media.textTracks : [];
                      this.tracks.forEach(function(track, index) {
                        var textTrack;
                        if (index < inUseTracks.length) {
                          var inUseTrack = null;
                          for (var i = 0; i < inUseTracks.length; i++) {
                            if (canReuseVttTextTrack(inUseTracks[i], track)) {
                              inUseTrack = inUseTracks[i];
                              break;
                            }
                          }
                          if (inUseTrack) {
                            textTrack = inUseTrack;
                          }
                        }
                        if (!textTrack) {
                          textTrack = _this3.createTextTrack("subtitles", track.name, track.lang);
                        }
                        if (track.default) {
                          textTrack.mode = _this3.hls.subtitleDisplay ? "showing" : "hidden";
                        } else {
                          textTrack.mode = "disabled";
                        }
                        _this3.textTracks.push(textTrack);
                      });
                    } else if (!sameTracks && this.tracks && this.tracks.length) {
                      var tracksList = this.tracks.map(function(track) {
                        return {
                          label: track.name,
                          kind: track.type.toLowerCase(),
                          default: track.default,
                          subtitleTrack: track
                        };
                      });
                      this.hls.trigger(events["default"].NON_NATIVE_TEXT_TRACKS_FOUND, {
                        tracks: tracksList
                      });
                    }
                  }
                  if (this.config.enableCEA708Captions && data.captions) {
                    data.captions.forEach(function(captionsTrack) {
                      var instreamIdMatch = /(?:CC|SERVICE)([1-4])/.exec(captionsTrack.instreamId);
                      if (!instreamIdMatch) {
                        return;
                      }
                      var trackName = "textTrack" + instreamIdMatch[1];
                      var trackProperties = _this3.captionsProperties[trackName];
                      if (!trackProperties) {
                        return;
                      }
                      trackProperties.label = captionsTrack.name;
                      if (captionsTrack.lang) {
                        trackProperties.languageCode = captionsTrack.lang;
                      }
                      trackProperties.media = captionsTrack;
                    });
                  }
                };
                _proto.onFragLoaded = function onFragLoaded(data) {
                  var frag = data.frag, payload = data.payload;
                  var cea608Parser1 = this.cea608Parser1, cea608Parser2 = this.cea608Parser2, initPTS = this.initPTS, lastSn = this.lastSn, unparsedVttFrags = this.unparsedVttFrags;
                  if (frag.type === "main") {
                    var sn = frag.sn;
                    if (frag.sn !== lastSn + 1) {
                      if (cea608Parser1 && cea608Parser2) {
                        cea608Parser1.reset();
                        cea608Parser2.reset();
                      }
                    }
                    this.lastSn = sn;
                  } else if (frag.type === "subtitle") {
                    if (payload.byteLength) {
                      if (!Object(number["isFiniteNumber"])(initPTS[frag.cc])) {
                        unparsedVttFrags.push(data);
                        if (initPTS.length) {
                          this.hls.trigger(events["default"].SUBTITLE_FRAG_PROCESSED, {
                            success: false,
                            frag
                          });
                        }
                        return;
                      }
                      var decryptData = frag.decryptdata;
                      if (decryptData == null || decryptData.key == null || decryptData.method !== "AES-128") {
                        this._parseVTTs(frag, payload);
                      }
                    } else {
                      this.hls.trigger(events["default"].SUBTITLE_FRAG_PROCESSED, {
                        success: false,
                        frag
                      });
                    }
                  }
                };
                _proto._parseVTTs = function _parseVTTs(frag, payload) {
                  var _this4 = this;
                  var hls = this.hls, prevCC = this.prevCC, textTracks = this.textTracks, vttCCs = this.vttCCs;
                  if (!vttCCs[frag.cc]) {
                    vttCCs[frag.cc] = {
                      start: frag.start,
                      prevCC,
                      new: true
                    };
                    this.prevCC = frag.cc;
                  }
                  webvtt_parser.parse(payload, this.initPTS[frag.cc], vttCCs, frag.cc, function(cues) {
                    if (_this4.config.renderTextTracksNatively) {
                      var currentTrack = textTracks[frag.level];
                      if (currentTrack.mode === "disabled") {
                        hls.trigger(events["default"].SUBTITLE_FRAG_PROCESSED, {
                          success: false,
                          frag
                        });
                        return;
                      }
                      cues.forEach(function(cue) {
                        if (!currentTrack.cues.getCueById(cue.id)) {
                          try {
                            currentTrack.addCue(cue);
                            if (!currentTrack.cues.getCueById(cue.id)) {
                              throw new Error("addCue is failed for: " + cue);
                            }
                          } catch (err) {
                            logger["logger"].debug("Failed occurred on adding cues: " + err);
                            var textTrackCue = new window.TextTrackCue(cue.startTime, cue.endTime, cue.text);
                            textTrackCue.id = cue.id;
                            currentTrack.addCue(textTrackCue);
                          }
                        }
                      });
                    } else {
                      var trackId = _this4.tracks[frag.level].default ? "default" : "subtitles" + frag.level;
                      hls.trigger(events["default"].CUES_PARSED, {
                        type: "subtitles",
                        cues,
                        track: trackId
                      });
                    }
                    hls.trigger(events["default"].SUBTITLE_FRAG_PROCESSED, {
                      success: true,
                      frag
                    });
                  }, function(e) {
                    logger["logger"].log("Failed to parse VTT cue: " + e);
                    hls.trigger(events["default"].SUBTITLE_FRAG_PROCESSED, {
                      success: false,
                      frag
                    });
                  });
                };
                _proto.onFragDecrypted = function onFragDecrypted(data) {
                  var frag = data.frag, payload = data.payload;
                  if (frag.type === "subtitle") {
                    if (!Object(number["isFiniteNumber"])(this.initPTS[frag.cc])) {
                      this.unparsedVttFrags.push(data);
                      return;
                    }
                    this._parseVTTs(frag, payload);
                  }
                };
                _proto.onFragParsingUserdata = function onFragParsingUserdata(data) {
                  var cea608Parser1 = this.cea608Parser1, cea608Parser2 = this.cea608Parser2;
                  if (!this.enabled || !(cea608Parser1 && cea608Parser2)) {
                    return;
                  }
                  for (var i = 0; i < data.samples.length; i++) {
                    var ccBytes = data.samples[i].bytes;
                    if (ccBytes) {
                      var ccdatas = this.extractCea608Data(ccBytes);
                      cea608Parser1.addData(data.samples[i].pts, ccdatas[0]);
                      cea608Parser2.addData(data.samples[i].pts, ccdatas[1]);
                    }
                  }
                };
                _proto.extractCea608Data = function extractCea608Data(byteArray) {
                  var count = byteArray[0] & 31;
                  var position = 2;
                  var actualCCBytes = [[], []];
                  for (var j = 0; j < count; j++) {
                    var tmpByte = byteArray[position++];
                    var ccbyte1 = 127 & byteArray[position++];
                    var ccbyte2 = 127 & byteArray[position++];
                    var ccValid = (4 & tmpByte) !== 0;
                    var ccType = 3 & tmpByte;
                    if (ccbyte1 === 0 && ccbyte2 === 0) {
                      continue;
                    }
                    if (ccValid) {
                      if (ccType === 0 || ccType === 1) {
                        actualCCBytes[ccType].push(ccbyte1);
                        actualCCBytes[ccType].push(ccbyte2);
                      }
                    }
                  }
                  return actualCCBytes;
                };
                return TimelineController;
              }(event_handler);
              function canReuseVttTextTrack(inUseTrack, manifestTrack) {
                return inUseTrack && inUseTrack.label === manifestTrack.name && !(inUseTrack.textTrack1 || inUseTrack.textTrack2);
              }
              function intersection(x1, x2, y1, y2) {
                return Math.min(x2, y2) - Math.max(x1, y1);
              }
              function newVTTCCs() {
                return {
                  ccOffset: 0,
                  presentationOffset: 0,
                  0: {
                    start: 0,
                    prevCC: -1,
                    new: false
                  }
                };
              }
              var timeline_controller = timeline_controller_TimelineController;
              function subtitle_track_controller_defineProperties(target, props) {
                for (var i = 0; i < props.length; i++) {
                  var descriptor = props[i];
                  descriptor.enumerable = descriptor.enumerable || false;
                  descriptor.configurable = true;
                  if ("value" in descriptor)
                    descriptor.writable = true;
                  Object.defineProperty(target, descriptor.key, descriptor);
                }
              }
              function subtitle_track_controller_createClass(Constructor, protoProps, staticProps) {
                if (protoProps)
                  subtitle_track_controller_defineProperties(Constructor.prototype, protoProps);
                if (staticProps)
                  subtitle_track_controller_defineProperties(Constructor, staticProps);
                return Constructor;
              }
              function subtitle_track_controller_inheritsLoose(subClass, superClass) {
                subClass.prototype = Object.create(superClass.prototype);
                subClass.prototype.constructor = subClass;
                subClass.__proto__ = superClass;
              }
              var subtitle_track_controller_SubtitleTrackController = function(_EventHandler) {
                subtitle_track_controller_inheritsLoose(SubtitleTrackController, _EventHandler);
                function SubtitleTrackController(hls) {
                  var _this;
                  _this = _EventHandler.call(this, hls, events["default"].MEDIA_ATTACHED, events["default"].MEDIA_DETACHING, events["default"].MANIFEST_LOADED, events["default"].SUBTITLE_TRACK_LOADED) || this;
                  _this.tracks = [];
                  _this.trackId = -1;
                  _this.media = null;
                  _this.stopped = true;
                  _this.subtitleDisplay = true;
                  _this.queuedDefaultTrack = null;
                  return _this;
                }
                var _proto = SubtitleTrackController.prototype;
                _proto.destroy = function destroy() {
                  event_handler.prototype.destroy.call(this);
                };
                _proto.onMediaAttached = function onMediaAttached(data) {
                  var _this2 = this;
                  this.media = data.media;
                  if (!this.media) {
                    return;
                  }
                  if (Object(number["isFiniteNumber"])(this.queuedDefaultTrack)) {
                    this.subtitleTrack = this.queuedDefaultTrack;
                    this.queuedDefaultTrack = null;
                  }
                  this.trackChangeListener = this._onTextTracksChanged.bind(this);
                  this.useTextTrackPolling = !(this.media.textTracks && "onchange" in this.media.textTracks);
                  if (this.useTextTrackPolling) {
                    this.subtitlePollingInterval = setInterval(function() {
                      _this2.trackChangeListener();
                    }, 500);
                  } else {
                    this.media.textTracks.addEventListener("change", this.trackChangeListener);
                  }
                };
                _proto.onMediaDetaching = function onMediaDetaching() {
                  if (!this.media) {
                    return;
                  }
                  if (this.useTextTrackPolling) {
                    clearInterval(this.subtitlePollingInterval);
                  } else {
                    this.media.textTracks.removeEventListener("change", this.trackChangeListener);
                  }
                  if (Object(number["isFiniteNumber"])(this.subtitleTrack)) {
                    this.queuedDefaultTrack = this.subtitleTrack;
                  }
                  var textTracks = filterSubtitleTracks(this.media.textTracks);
                  textTracks.forEach(function(track) {
                    clearCurrentCues(track);
                  });
                  this.subtitleTrack = -1;
                  this.media = null;
                };
                _proto.onManifestLoaded = function onManifestLoaded(data) {
                  var _this3 = this;
                  var tracks = data.subtitles || [];
                  this.tracks = tracks;
                  this.hls.trigger(events["default"].SUBTITLE_TRACKS_UPDATED, {
                    subtitleTracks: tracks
                  });
                  tracks.forEach(function(track) {
                    if (track.default) {
                      if (_this3.media) {
                        _this3.subtitleTrack = track.id;
                      } else {
                        _this3.queuedDefaultTrack = track.id;
                      }
                    }
                  });
                };
                _proto.onSubtitleTrackLoaded = function onSubtitleTrackLoaded(data) {
                  var _this4 = this;
                  var id = data.id, details = data.details;
                  var trackId = this.trackId, tracks = this.tracks;
                  var currentTrack = tracks[trackId];
                  if (id >= tracks.length || id !== trackId || !currentTrack || this.stopped) {
                    this._clearReloadTimer();
                    return;
                  }
                  logger["logger"].log("subtitle track " + id + " loaded");
                  if (details.live) {
                    var reloadInterval = computeReloadInterval(currentTrack.details, details, data.stats.trequest);
                    logger["logger"].log("Reloading live subtitle playlist in " + reloadInterval + "ms");
                    this.timer = setTimeout(function() {
                      _this4._loadCurrentTrack();
                    }, reloadInterval);
                  } else {
                    this._clearReloadTimer();
                  }
                };
                _proto.startLoad = function startLoad() {
                  this.stopped = false;
                  this._loadCurrentTrack();
                };
                _proto.stopLoad = function stopLoad() {
                  this.stopped = true;
                  this._clearReloadTimer();
                };
                _proto._clearReloadTimer = function _clearReloadTimer() {
                  if (this.timer) {
                    clearTimeout(this.timer);
                    this.timer = null;
                  }
                };
                _proto._loadCurrentTrack = function _loadCurrentTrack() {
                  var trackId = this.trackId, tracks = this.tracks, hls = this.hls;
                  var currentTrack = tracks[trackId];
                  if (trackId < 0 || !currentTrack || currentTrack.details && !currentTrack.details.live) {
                    return;
                  }
                  logger["logger"].log("Loading subtitle track " + trackId);
                  hls.trigger(events["default"].SUBTITLE_TRACK_LOADING, {
                    url: currentTrack.url,
                    id: trackId
                  });
                };
                _proto._toggleTrackModes = function _toggleTrackModes(newId) {
                  var media = this.media, subtitleDisplay = this.subtitleDisplay, trackId = this.trackId;
                  if (!media) {
                    return;
                  }
                  var textTracks = filterSubtitleTracks(media.textTracks);
                  if (newId === -1) {
                    [].slice.call(textTracks).forEach(function(track) {
                      track.mode = "disabled";
                    });
                  } else {
                    var oldTrack = textTracks[trackId];
                    if (oldTrack) {
                      oldTrack.mode = "disabled";
                    }
                  }
                  var nextTrack = textTracks[newId];
                  if (nextTrack) {
                    nextTrack.mode = subtitleDisplay ? "showing" : "hidden";
                  }
                };
                _proto._setSubtitleTrackInternal = function _setSubtitleTrackInternal(newId) {
                  var hls = this.hls, tracks = this.tracks;
                  if (!Object(number["isFiniteNumber"])(newId) || newId < -1 || newId >= tracks.length) {
                    return;
                  }
                  this.trackId = newId;
                  logger["logger"].log("Switching to subtitle track " + newId);
                  hls.trigger(events["default"].SUBTITLE_TRACK_SWITCH, {
                    id: newId
                  });
                  this._loadCurrentTrack();
                };
                _proto._onTextTracksChanged = function _onTextTracksChanged() {
                  if (!this.media || !this.hls.config.renderTextTracksNatively) {
                    return;
                  }
                  var trackId = -1;
                  var tracks = filterSubtitleTracks(this.media.textTracks);
                  for (var id = 0; id < tracks.length; id++) {
                    if (tracks[id].mode === "hidden") {
                      trackId = id;
                    } else if (tracks[id].mode === "showing") {
                      trackId = id;
                      break;
                    }
                  }
                  this.subtitleTrack = trackId;
                };
                subtitle_track_controller_createClass(SubtitleTrackController, [{
                  key: "subtitleTracks",
                  get: function get() {
                    return this.tracks;
                  }
                  /** get index of the selected subtitle track (index in subtitle track lists) **/
                }, {
                  key: "subtitleTrack",
                  get: function get() {
                    return this.trackId;
                  },
                  set: function set(subtitleTrackId) {
                    if (this.trackId !== subtitleTrackId) {
                      this._toggleTrackModes(subtitleTrackId);
                      this._setSubtitleTrackInternal(subtitleTrackId);
                    }
                  }
                }]);
                return SubtitleTrackController;
              }(event_handler);
              function filterSubtitleTracks(textTrackList) {
                var tracks = [];
                for (var i = 0; i < textTrackList.length; i++) {
                  var track = textTrackList[i];
                  if (track.kind === "subtitles" && track.label) {
                    tracks.push(textTrackList[i]);
                  }
                }
                return tracks;
              }
              var subtitle_track_controller = subtitle_track_controller_SubtitleTrackController;
              var decrypter = __webpack_require__("./src/crypt/decrypter.js");
              function subtitle_stream_controller_assertThisInitialized(self2) {
                if (self2 === void 0) {
                  throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                }
                return self2;
              }
              function subtitle_stream_controller_inheritsLoose(subClass, superClass) {
                subClass.prototype = Object.create(superClass.prototype);
                subClass.prototype.constructor = subClass;
                subClass.__proto__ = superClass;
              }
              var subtitle_stream_controller_window = window, subtitle_stream_controller_performance = subtitle_stream_controller_window.performance;
              var subtitle_stream_controller_TICK_INTERVAL = 500;
              var subtitle_stream_controller_SubtitleStreamController = function(_BaseStreamController) {
                subtitle_stream_controller_inheritsLoose(SubtitleStreamController, _BaseStreamController);
                function SubtitleStreamController(hls, fragmentTracker) {
                  var _this;
                  _this = _BaseStreamController.call(this, hls, events["default"].MEDIA_ATTACHED, events["default"].MEDIA_DETACHING, events["default"].ERROR, events["default"].KEY_LOADED, events["default"].FRAG_LOADED, events["default"].SUBTITLE_TRACKS_UPDATED, events["default"].SUBTITLE_TRACK_SWITCH, events["default"].SUBTITLE_TRACK_LOADED, events["default"].SUBTITLE_FRAG_PROCESSED, events["default"].LEVEL_UPDATED) || this;
                  _this.fragmentTracker = fragmentTracker;
                  _this.config = hls.config;
                  _this.state = State.STOPPED;
                  _this.tracks = [];
                  _this.tracksBuffered = [];
                  _this.currentTrackId = -1;
                  _this.decrypter = new decrypter["default"](hls, hls.config);
                  _this.lastAVStart = 0;
                  _this._onMediaSeeking = _this.onMediaSeeking.bind(subtitle_stream_controller_assertThisInitialized(_this));
                  return _this;
                }
                var _proto = SubtitleStreamController.prototype;
                _proto.startLoad = function startLoad() {
                  this.stopLoad();
                  this.state = State.IDLE;
                  var currentTrack = this.tracks[this.currentTrackId];
                  if (currentTrack && currentTrack.details) {
                    this.setInterval(subtitle_stream_controller_TICK_INTERVAL);
                    this.tick();
                  }
                };
                _proto.onSubtitleFragProcessed = function onSubtitleFragProcessed(data) {
                  var frag = data.frag, success = data.success;
                  this.fragPrevious = frag;
                  this.state = State.IDLE;
                  if (!success) {
                    return;
                  }
                  var buffered = this.tracksBuffered[this.currentTrackId];
                  if (!buffered) {
                    return;
                  }
                  var timeRange;
                  var fragStart = frag.start;
                  for (var i = 0; i < buffered.length; i++) {
                    if (fragStart >= buffered[i].start && fragStart <= buffered[i].end) {
                      timeRange = buffered[i];
                      break;
                    }
                  }
                  var fragEnd = frag.start + frag.duration;
                  if (timeRange) {
                    timeRange.end = fragEnd;
                  } else {
                    timeRange = {
                      start: fragStart,
                      end: fragEnd
                    };
                    buffered.push(timeRange);
                  }
                };
                _proto.onMediaAttached = function onMediaAttached(_ref) {
                  var media = _ref.media;
                  this.media = media;
                  media.addEventListener("seeking", this._onMediaSeeking);
                  this.state = State.IDLE;
                };
                _proto.onMediaDetaching = function onMediaDetaching() {
                  var _this2 = this;
                  if (!this.media) {
                    return;
                  }
                  this.media.removeEventListener("seeking", this._onMediaSeeking);
                  this.fragmentTracker.removeAllFragments();
                  this.currentTrackId = -1;
                  this.tracks.forEach(function(track) {
                    _this2.tracksBuffered[track.id] = [];
                  });
                  this.media = null;
                  this.state = State.STOPPED;
                };
                _proto.onError = function onError(data) {
                  var frag = data.frag;
                  if (!frag || frag.type !== "subtitle") {
                    return;
                  }
                  if (this.fragCurrent && this.fragCurrent.loader) {
                    this.fragCurrent.loader.abort();
                  }
                  this.state = State.IDLE;
                };
                _proto.onSubtitleTracksUpdated = function onSubtitleTracksUpdated(data) {
                  var _this3 = this;
                  logger["logger"].log("subtitle tracks updated");
                  this.tracksBuffered = [];
                  this.tracks = data.subtitleTracks;
                  this.tracks.forEach(function(track) {
                    _this3.tracksBuffered[track.id] = [];
                  });
                };
                _proto.onSubtitleTrackSwitch = function onSubtitleTrackSwitch(data) {
                  this.currentTrackId = data.id;
                  if (!this.tracks || !this.tracks.length || this.currentTrackId === -1) {
                    this.clearInterval();
                    return;
                  }
                  var currentTrack = this.tracks[this.currentTrackId];
                  if (currentTrack && currentTrack.details) {
                    this.setInterval(subtitle_stream_controller_TICK_INTERVAL);
                  }
                };
                _proto.onSubtitleTrackLoaded = function onSubtitleTrackLoaded(data) {
                  var id = data.id, details = data.details;
                  var currentTrackId = this.currentTrackId, tracks = this.tracks;
                  var currentTrack = tracks[currentTrackId];
                  if (id >= tracks.length || id !== currentTrackId || !currentTrack) {
                    return;
                  }
                  if (details.live) {
                    mergeSubtitlePlaylists(currentTrack.details, details, this.lastAVStart);
                  }
                  currentTrack.details = details;
                  this.setInterval(subtitle_stream_controller_TICK_INTERVAL);
                };
                _proto.onKeyLoaded = function onKeyLoaded() {
                  if (this.state === State.KEY_LOADING) {
                    this.state = State.IDLE;
                  }
                };
                _proto.onFragLoaded = function onFragLoaded(data) {
                  var fragCurrent = this.fragCurrent;
                  var decryptData = data.frag.decryptdata;
                  var fragLoaded = data.frag;
                  var hls = this.hls;
                  if (this.state === State.FRAG_LOADING && fragCurrent && data.frag.type === "subtitle" && fragCurrent.sn === data.frag.sn) {
                    if (data.payload.byteLength > 0 && decryptData && decryptData.key && decryptData.method === "AES-128") {
                      var startTime = subtitle_stream_controller_performance.now();
                      this.decrypter.decrypt(data.payload, decryptData.key.buffer, decryptData.iv.buffer, function(decryptedData) {
                        var endTime = subtitle_stream_controller_performance.now();
                        hls.trigger(events["default"].FRAG_DECRYPTED, {
                          frag: fragLoaded,
                          payload: decryptedData,
                          stats: {
                            tstart: startTime,
                            tdecrypt: endTime
                          }
                        });
                      });
                    }
                  }
                };
                _proto.onLevelUpdated = function onLevelUpdated(_ref2) {
                  var details = _ref2.details;
                  var frags = details.fragments;
                  this.lastAVStart = frags.length ? frags[0].start : 0;
                };
                _proto.doTick = function doTick() {
                  if (!this.media) {
                    this.state = State.IDLE;
                    return;
                  }
                  switch (this.state) {
                    case State.IDLE: {
                      var config = this.config, currentTrackId = this.currentTrackId, fragmentTracker = this.fragmentTracker, media = this.media, tracks = this.tracks;
                      if (!tracks || !tracks[currentTrackId] || !tracks[currentTrackId].details) {
                        break;
                      }
                      var maxBufferHole = config.maxBufferHole, maxFragLookUpTolerance = config.maxFragLookUpTolerance;
                      var maxConfigBuffer = Math.min(config.maxBufferLength, config.maxMaxBufferLength);
                      var bufferedInfo = BufferHelper.bufferedInfo(this._getBuffered(), media.currentTime, maxBufferHole);
                      var bufferEnd = bufferedInfo.end, bufferLen = bufferedInfo.len;
                      var trackDetails = tracks[currentTrackId].details;
                      var fragments = trackDetails.fragments;
                      var fragLen = fragments.length;
                      var end = fragments[fragLen - 1].start + fragments[fragLen - 1].duration;
                      if (bufferLen > maxConfigBuffer) {
                        return;
                      }
                      var foundFrag;
                      var fragPrevious = this.fragPrevious;
                      if (bufferEnd < end) {
                        if (fragPrevious && trackDetails.hasProgramDateTime) {
                          foundFrag = findFragmentByPDT(fragments, fragPrevious.endProgramDateTime, maxFragLookUpTolerance);
                        }
                        if (!foundFrag) {
                          foundFrag = findFragmentByPTS(fragPrevious, fragments, bufferEnd, maxFragLookUpTolerance);
                        }
                      } else {
                        foundFrag = fragments[fragLen - 1];
                      }
                      if (foundFrag && foundFrag.encrypted) {
                        logger["logger"].log("Loading key for " + foundFrag.sn);
                        this.state = State.KEY_LOADING;
                        this.hls.trigger(events["default"].KEY_LOADING, {
                          frag: foundFrag
                        });
                      } else if (foundFrag && fragmentTracker.getState(foundFrag) === FragmentState.NOT_LOADED) {
                        this.fragCurrent = foundFrag;
                        this.state = State.FRAG_LOADING;
                        this.hls.trigger(events["default"].FRAG_LOADING, {
                          frag: foundFrag
                        });
                      }
                    }
                  }
                };
                _proto.stopLoad = function stopLoad() {
                  this.lastAVStart = 0;
                  this.fragPrevious = null;
                  _BaseStreamController.prototype.stopLoad.call(this);
                };
                _proto._getBuffered = function _getBuffered() {
                  return this.tracksBuffered[this.currentTrackId] || [];
                };
                _proto.onMediaSeeking = function onMediaSeeking() {
                  if (this.fragCurrent) {
                    var currentTime = this.media ? this.media.currentTime : 0;
                    var tolerance = this.config.maxFragLookUpTolerance;
                    var fragStartOffset = this.fragCurrent.start - tolerance;
                    var fragEndOffset = this.fragCurrent.start + this.fragCurrent.duration + tolerance;
                    if (currentTime < fragStartOffset || currentTime > fragEndOffset) {
                      if (this.fragCurrent.loader) {
                        this.fragCurrent.loader.abort();
                      }
                      this.fragmentTracker.removeFragment(this.fragCurrent);
                      this.fragCurrent = null;
                      this.fragPrevious = null;
                      this.state = State.IDLE;
                      this.tick();
                    }
                  }
                };
                return SubtitleStreamController;
              }(base_stream_controller_BaseStreamController);
              var KeySystems;
              (function(KeySystems2) {
                KeySystems2["WIDEVINE"] = "com.widevine.alpha";
                KeySystems2["PLAYREADY"] = "com.microsoft.playready";
              })(KeySystems || (KeySystems = {}));
              var requestMediaKeySystemAccess = function() {
                if (typeof window !== "undefined" && window.navigator && window.navigator.requestMediaKeySystemAccess) {
                  return window.navigator.requestMediaKeySystemAccess.bind(window.navigator);
                } else {
                  return null;
                }
              }();
              function eme_controller_defineProperties(target, props) {
                for (var i = 0; i < props.length; i++) {
                  var descriptor = props[i];
                  descriptor.enumerable = descriptor.enumerable || false;
                  descriptor.configurable = true;
                  if ("value" in descriptor)
                    descriptor.writable = true;
                  Object.defineProperty(target, descriptor.key, descriptor);
                }
              }
              function eme_controller_createClass(Constructor, protoProps, staticProps) {
                if (protoProps)
                  eme_controller_defineProperties(Constructor.prototype, protoProps);
                if (staticProps)
                  eme_controller_defineProperties(Constructor, staticProps);
                return Constructor;
              }
              function eme_controller_inheritsLoose(subClass, superClass) {
                subClass.prototype = Object.create(superClass.prototype);
                subClass.prototype.constructor = subClass;
                subClass.__proto__ = superClass;
              }
              var MAX_LICENSE_REQUEST_FAILURES = 3;
              var createWidevineMediaKeySystemConfigurations = function createWidevineMediaKeySystemConfigurations2(audioCodecs, videoCodecs, drmSystemOptions) {
                var baseConfig = {
                  // initDataTypes: ['keyids', 'mp4'],
                  // label: "",
                  // persistentState: "not-allowed", // or "required" ?
                  // distinctiveIdentifier: "not-allowed", // or "required" ?
                  // sessionTypes: ['temporary'],
                  audioCapabilities: [],
                  // { contentType: 'audio/mp4; codecs="mp4a.40.2"' }
                  videoCapabilities: []
                  // { contentType: 'video/mp4; codecs="avc1.42E01E"' }
                };
                audioCodecs.forEach(function(codec) {
                  baseConfig.audioCapabilities.push({
                    contentType: 'audio/mp4; codecs="' + codec + '"',
                    robustness: drmSystemOptions.audioRobustness || ""
                  });
                });
                videoCodecs.forEach(function(codec) {
                  baseConfig.videoCapabilities.push({
                    contentType: 'video/mp4; codecs="' + codec + '"',
                    robustness: drmSystemOptions.videoRobustness || ""
                  });
                });
                return [baseConfig];
              };
              var eme_controller_getSupportedMediaKeySystemConfigurations = function getSupportedMediaKeySystemConfigurations(keySystem, audioCodecs, videoCodecs, drmSystemOptions) {
                switch (keySystem) {
                  case KeySystems.WIDEVINE:
                    return createWidevineMediaKeySystemConfigurations(audioCodecs, videoCodecs, drmSystemOptions);
                  default:
                    throw new Error("Unknown key-system: " + keySystem);
                }
              };
              var eme_controller_EMEController = function(_EventHandler) {
                eme_controller_inheritsLoose(EMEController, _EventHandler);
                function EMEController(hls) {
                  var _this;
                  _this = _EventHandler.call(this, hls, events["default"].MEDIA_ATTACHED, events["default"].MEDIA_DETACHED, events["default"].MANIFEST_PARSED) || this;
                  _this._widevineLicenseUrl = void 0;
                  _this._licenseXhrSetup = void 0;
                  _this._emeEnabled = void 0;
                  _this._requestMediaKeySystemAccess = void 0;
                  _this._drmSystemOptions = void 0;
                  _this._config = void 0;
                  _this._mediaKeysList = [];
                  _this._media = null;
                  _this._hasSetMediaKeys = false;
                  _this._requestLicenseFailureCount = 0;
                  _this.mediaKeysPromise = null;
                  _this._onMediaEncrypted = function(e) {
                    logger["logger"].log('Media is encrypted using "' + e.initDataType + '" init data type');
                    if (!_this.mediaKeysPromise) {
                      logger["logger"].error("Fatal: Media is encrypted but no CDM access or no keys have been requested");
                      _this.hls.trigger(events["default"].ERROR, {
                        type: errors["ErrorTypes"].KEY_SYSTEM_ERROR,
                        details: errors["ErrorDetails"].KEY_SYSTEM_NO_KEYS,
                        fatal: true
                      });
                      return;
                    }
                    var finallySetKeyAndStartSession = function finallySetKeyAndStartSession2(mediaKeys) {
                      if (!_this._media) {
                        return;
                      }
                      _this._attemptSetMediaKeys(mediaKeys);
                      _this._generateRequestWithPreferredKeySession(e.initDataType, e.initData);
                    };
                    _this.mediaKeysPromise.then(finallySetKeyAndStartSession).catch(finallySetKeyAndStartSession);
                  };
                  _this._config = hls.config;
                  _this._widevineLicenseUrl = _this._config.widevineLicenseUrl;
                  _this._licenseXhrSetup = _this._config.licenseXhrSetup;
                  _this._emeEnabled = _this._config.emeEnabled;
                  _this._requestMediaKeySystemAccess = _this._config.requestMediaKeySystemAccessFunc;
                  _this._drmSystemOptions = hls.config.drmSystemOptions;
                  return _this;
                }
                var _proto = EMEController.prototype;
                _proto.getLicenseServerUrl = function getLicenseServerUrl(keySystem) {
                  switch (keySystem) {
                    case KeySystems.WIDEVINE:
                      if (!this._widevineLicenseUrl) {
                        break;
                      }
                      return this._widevineLicenseUrl;
                  }
                  throw new Error('no license server URL configured for key-system "' + keySystem + '"');
                };
                _proto._attemptKeySystemAccess = function _attemptKeySystemAccess(keySystem, audioCodecs, videoCodecs) {
                  var _this2 = this;
                  var mediaKeySystemConfigs = eme_controller_getSupportedMediaKeySystemConfigurations(keySystem, audioCodecs, videoCodecs, this._drmSystemOptions);
                  logger["logger"].log("Requesting encrypted media key-system access");
                  var keySystemAccessPromise = this.requestMediaKeySystemAccess(keySystem, mediaKeySystemConfigs);
                  this.mediaKeysPromise = keySystemAccessPromise.then(function(mediaKeySystemAccess) {
                    return _this2._onMediaKeySystemAccessObtained(keySystem, mediaKeySystemAccess);
                  });
                  keySystemAccessPromise.catch(function(err) {
                    logger["logger"].error('Failed to obtain key-system "' + keySystem + '" access:', err);
                  });
                };
                _proto._onMediaKeySystemAccessObtained = function _onMediaKeySystemAccessObtained(keySystem, mediaKeySystemAccess) {
                  var _this3 = this;
                  logger["logger"].log('Access for key-system "' + keySystem + '" obtained');
                  var mediaKeysListItem = {
                    mediaKeysSessionInitialized: false,
                    mediaKeySystemAccess,
                    mediaKeySystemDomain: keySystem
                  };
                  this._mediaKeysList.push(mediaKeysListItem);
                  var mediaKeysPromise = Promise.resolve().then(function() {
                    return mediaKeySystemAccess.createMediaKeys();
                  }).then(function(mediaKeys) {
                    mediaKeysListItem.mediaKeys = mediaKeys;
                    logger["logger"].log('Media-keys created for key-system "' + keySystem + '"');
                    _this3._onMediaKeysCreated();
                    return mediaKeys;
                  });
                  mediaKeysPromise.catch(function(err) {
                    logger["logger"].error("Failed to create media-keys:", err);
                  });
                  return mediaKeysPromise;
                };
                _proto._onMediaKeysCreated = function _onMediaKeysCreated() {
                  var _this4 = this;
                  this._mediaKeysList.forEach(function(mediaKeysListItem) {
                    if (!mediaKeysListItem.mediaKeysSession) {
                      mediaKeysListItem.mediaKeysSession = mediaKeysListItem.mediaKeys.createSession();
                      _this4._onNewMediaKeySession(mediaKeysListItem.mediaKeysSession);
                    }
                  });
                };
                _proto._onNewMediaKeySession = function _onNewMediaKeySession(keySession) {
                  var _this5 = this;
                  logger["logger"].log("New key-system session " + keySession.sessionId);
                  keySession.addEventListener("message", function(event) {
                    _this5._onKeySessionMessage(keySession, event.message);
                  }, false);
                };
                _proto._onKeySessionMessage = function _onKeySessionMessage(keySession, message) {
                  logger["logger"].log("Got EME message event, creating license request");
                  this._requestLicense(message, function(data) {
                    logger["logger"].log("Received license data (length: " + (data ? data.byteLength : data) + "), updating key-session");
                    keySession.update(data);
                  });
                };
                _proto._attemptSetMediaKeys = function _attemptSetMediaKeys(mediaKeys) {
                  if (!this._media) {
                    throw new Error("Attempted to set mediaKeys without first attaching a media element");
                  }
                  if (!this._hasSetMediaKeys) {
                    var keysListItem = this._mediaKeysList[0];
                    if (!keysListItem || !keysListItem.mediaKeys) {
                      logger["logger"].error("Fatal: Media is encrypted but no CDM access or no keys have been obtained yet");
                      this.hls.trigger(events["default"].ERROR, {
                        type: errors["ErrorTypes"].KEY_SYSTEM_ERROR,
                        details: errors["ErrorDetails"].KEY_SYSTEM_NO_KEYS,
                        fatal: true
                      });
                      return;
                    }
                    logger["logger"].log("Setting keys for encrypted media");
                    this._media.setMediaKeys(keysListItem.mediaKeys);
                    this._hasSetMediaKeys = true;
                  }
                };
                _proto._generateRequestWithPreferredKeySession = function _generateRequestWithPreferredKeySession(initDataType, initData) {
                  var _this6 = this;
                  var keysListItem = this._mediaKeysList[0];
                  if (!keysListItem) {
                    logger["logger"].error("Fatal: Media is encrypted but not any key-system access has been obtained yet");
                    this.hls.trigger(events["default"].ERROR, {
                      type: errors["ErrorTypes"].KEY_SYSTEM_ERROR,
                      details: errors["ErrorDetails"].KEY_SYSTEM_NO_ACCESS,
                      fatal: true
                    });
                    return;
                  }
                  if (keysListItem.mediaKeysSessionInitialized) {
                    logger["logger"].warn("Key-Session already initialized but requested again");
                    return;
                  }
                  var keySession = keysListItem.mediaKeysSession;
                  if (!keySession) {
                    logger["logger"].error("Fatal: Media is encrypted but no key-session existing");
                    this.hls.trigger(events["default"].ERROR, {
                      type: errors["ErrorTypes"].KEY_SYSTEM_ERROR,
                      details: errors["ErrorDetails"].KEY_SYSTEM_NO_SESSION,
                      fatal: true
                    });
                    return;
                  }
                  if (!initData) {
                    logger["logger"].warn("Fatal: initData required for generating a key session is null");
                    this.hls.trigger(events["default"].ERROR, {
                      type: errors["ErrorTypes"].KEY_SYSTEM_ERROR,
                      details: errors["ErrorDetails"].KEY_SYSTEM_NO_INIT_DATA,
                      fatal: true
                    });
                    return;
                  }
                  logger["logger"].log('Generating key-session request for "' + initDataType + '" init data type');
                  keysListItem.mediaKeysSessionInitialized = true;
                  keySession.generateRequest(initDataType, initData).then(function() {
                    logger["logger"].debug("Key-session generation succeeded");
                  }).catch(function(err) {
                    logger["logger"].error("Error generating key-session request:", err);
                    _this6.hls.trigger(events["default"].ERROR, {
                      type: errors["ErrorTypes"].KEY_SYSTEM_ERROR,
                      details: errors["ErrorDetails"].KEY_SYSTEM_NO_SESSION,
                      fatal: false
                    });
                  });
                };
                _proto._createLicenseXhr = function _createLicenseXhr(url, keyMessage, callback) {
                  var xhr = new XMLHttpRequest();
                  var licenseXhrSetup = this._licenseXhrSetup;
                  try {
                    if (licenseXhrSetup) {
                      try {
                        licenseXhrSetup(xhr, url);
                      } catch (e) {
                        xhr.open("POST", url, true);
                        licenseXhrSetup(xhr, url);
                      }
                    }
                    if (!xhr.readyState) {
                      xhr.open("POST", url, true);
                    }
                  } catch (e) {
                    throw new Error("issue setting up KeySystem license XHR " + e);
                  }
                  xhr.responseType = "arraybuffer";
                  xhr.onreadystatechange = this._onLicenseRequestReadyStageChange.bind(this, xhr, url, keyMessage, callback);
                  return xhr;
                };
                _proto._onLicenseRequestReadyStageChange = function _onLicenseRequestReadyStageChange(xhr, url, keyMessage, callback) {
                  switch (xhr.readyState) {
                    case 4:
                      if (xhr.status === 200) {
                        this._requestLicenseFailureCount = 0;
                        logger["logger"].log("License request succeeded");
                        if (xhr.responseType !== "arraybuffer") {
                          logger["logger"].warn("xhr response type was not set to the expected arraybuffer for license request");
                        }
                        callback(xhr.response);
                      } else {
                        logger["logger"].error("License Request XHR failed (" + url + "). Status: " + xhr.status + " (" + xhr.statusText + ")");
                        this._requestLicenseFailureCount++;
                        if (this._requestLicenseFailureCount > MAX_LICENSE_REQUEST_FAILURES) {
                          this.hls.trigger(events["default"].ERROR, {
                            type: errors["ErrorTypes"].KEY_SYSTEM_ERROR,
                            details: errors["ErrorDetails"].KEY_SYSTEM_LICENSE_REQUEST_FAILED,
                            fatal: true
                          });
                          return;
                        }
                        var attemptsLeft = MAX_LICENSE_REQUEST_FAILURES - this._requestLicenseFailureCount + 1;
                        logger["logger"].warn("Retrying license request, " + attemptsLeft + " attempts left");
                        this._requestLicense(keyMessage, callback);
                      }
                      break;
                  }
                };
                _proto._generateLicenseRequestChallenge = function _generateLicenseRequestChallenge(keysListItem, keyMessage) {
                  switch (keysListItem.mediaKeySystemDomain) {
                    case KeySystems.WIDEVINE:
                      return keyMessage;
                  }
                  throw new Error("unsupported key-system: " + keysListItem.mediaKeySystemDomain);
                };
                _proto._requestLicense = function _requestLicense(keyMessage, callback) {
                  logger["logger"].log("Requesting content license for key-system");
                  var keysListItem = this._mediaKeysList[0];
                  if (!keysListItem) {
                    logger["logger"].error("Fatal error: Media is encrypted but no key-system access has been obtained yet");
                    this.hls.trigger(events["default"].ERROR, {
                      type: errors["ErrorTypes"].KEY_SYSTEM_ERROR,
                      details: errors["ErrorDetails"].KEY_SYSTEM_NO_ACCESS,
                      fatal: true
                    });
                    return;
                  }
                  try {
                    var _url = this.getLicenseServerUrl(keysListItem.mediaKeySystemDomain);
                    var _xhr = this._createLicenseXhr(_url, keyMessage, callback);
                    logger["logger"].log("Sending license request to URL: " + _url);
                    var challenge = this._generateLicenseRequestChallenge(keysListItem, keyMessage);
                    _xhr.send(challenge);
                  } catch (e) {
                    logger["logger"].error("Failure requesting DRM license: " + e);
                    this.hls.trigger(events["default"].ERROR, {
                      type: errors["ErrorTypes"].KEY_SYSTEM_ERROR,
                      details: errors["ErrorDetails"].KEY_SYSTEM_LICENSE_REQUEST_FAILED,
                      fatal: true
                    });
                  }
                };
                _proto.onMediaAttached = function onMediaAttached(data) {
                  if (!this._emeEnabled) {
                    return;
                  }
                  var media = data.media;
                  this._media = media;
                  media.addEventListener("encrypted", this._onMediaEncrypted);
                };
                _proto.onMediaDetached = function onMediaDetached() {
                  var media = this._media;
                  var mediaKeysList = this._mediaKeysList;
                  if (!media) {
                    return;
                  }
                  media.removeEventListener("encrypted", this._onMediaEncrypted);
                  this._media = null;
                  this._mediaKeysList = [];
                  Promise.all(mediaKeysList.map(function(mediaKeysListItem) {
                    if (mediaKeysListItem.mediaKeysSession) {
                      return mediaKeysListItem.mediaKeysSession.close().catch(function() {
                      });
                    }
                  })).then(function() {
                    return media.setMediaKeys(null);
                  }).catch(function() {
                  });
                };
                _proto.onManifestParsed = function onManifestParsed(data) {
                  if (!this._emeEnabled) {
                    return;
                  }
                  var audioCodecs = data.levels.map(function(level) {
                    return level.audioCodec;
                  });
                  var videoCodecs = data.levels.map(function(level) {
                    return level.videoCodec;
                  });
                  this._attemptKeySystemAccess(KeySystems.WIDEVINE, audioCodecs, videoCodecs);
                };
                eme_controller_createClass(EMEController, [{
                  key: "requestMediaKeySystemAccess",
                  get: function get() {
                    if (!this._requestMediaKeySystemAccess) {
                      throw new Error("No requestMediaKeySystemAccess function configured");
                    }
                    return this._requestMediaKeySystemAccess;
                  }
                }]);
                return EMEController;
              }(event_handler);
              var eme_controller = eme_controller_EMEController;
              function ownKeys(object, enumerableOnly) {
                var keys = Object.keys(object);
                if (Object.getOwnPropertySymbols) {
                  var symbols = Object.getOwnPropertySymbols(object);
                  if (enumerableOnly)
                    symbols = symbols.filter(function(sym) {
                      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
                    });
                  keys.push.apply(keys, symbols);
                }
                return keys;
              }
              function _objectSpread(target) {
                for (var i = 1; i < arguments.length; i++) {
                  var source = arguments[i] != null ? arguments[i] : {};
                  if (i % 2) {
                    ownKeys(Object(source), true).forEach(function(key) {
                      _defineProperty(target, key, source[key]);
                    });
                  } else if (Object.getOwnPropertyDescriptors) {
                    Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
                  } else {
                    ownKeys(Object(source)).forEach(function(key) {
                      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
                    });
                  }
                }
                return target;
              }
              function _defineProperty(obj, key, value) {
                if (key in obj) {
                  Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
                } else {
                  obj[key] = value;
                }
                return obj;
              }
              var hlsDefaultConfig = _objectSpread(_objectSpread({
                autoStartLoad: true,
                // used by stream-controller
                startPosition: -1,
                // used by stream-controller
                defaultAudioCodec: void 0,
                // used by stream-controller
                debug: false,
                // used by logger
                capLevelOnFPSDrop: false,
                // used by fps-controller
                capLevelToPlayerSize: false,
                // used by cap-level-controller
                initialLiveManifestSize: 1,
                // used by stream-controller
                maxBufferLength: 30,
                // used by stream-controller
                maxBufferSize: 60 * 1e3 * 1e3,
                // used by stream-controller
                maxBufferHole: 0.5,
                // used by stream-controller
                lowBufferWatchdogPeriod: 0.5,
                // used by stream-controller
                highBufferWatchdogPeriod: 3,
                // used by stream-controller
                nudgeOffset: 0.1,
                // used by stream-controller
                nudgeMaxRetry: 3,
                // used by stream-controller
                maxFragLookUpTolerance: 0.25,
                // used by stream-controller
                liveSyncDurationCount: 3,
                // used by stream-controller
                liveMaxLatencyDurationCount: Infinity,
                // used by stream-controller
                liveSyncDuration: void 0,
                // used by stream-controller
                liveMaxLatencyDuration: void 0,
                // used by stream-controller
                liveDurationInfinity: false,
                // used by buffer-controller
                liveBackBufferLength: Infinity,
                // used by buffer-controller
                maxMaxBufferLength: 600,
                // used by stream-controller
                enableWorker: true,
                // used by demuxer
                enableSoftwareAES: true,
                // used by decrypter
                manifestLoadingTimeOut: 1e4,
                // used by playlist-loader
                manifestLoadingMaxRetry: 1,
                // used by playlist-loader
                manifestLoadingRetryDelay: 1e3,
                // used by playlist-loader
                manifestLoadingMaxRetryTimeout: 64e3,
                // used by playlist-loader
                startLevel: void 0,
                // used by level-controller
                levelLoadingTimeOut: 1e4,
                // used by playlist-loader
                levelLoadingMaxRetry: 4,
                // used by playlist-loader
                levelLoadingRetryDelay: 1e3,
                // used by playlist-loader
                levelLoadingMaxRetryTimeout: 64e3,
                // used by playlist-loader
                fragLoadingTimeOut: 2e4,
                // used by fragment-loader
                fragLoadingMaxRetry: 6,
                // used by fragment-loader
                fragLoadingRetryDelay: 1e3,
                // used by fragment-loader
                fragLoadingMaxRetryTimeout: 64e3,
                // used by fragment-loader
                startFragPrefetch: false,
                // used by stream-controller
                fpsDroppedMonitoringPeriod: 5e3,
                // used by fps-controller
                fpsDroppedMonitoringThreshold: 0.2,
                // used by fps-controller
                appendErrorMaxRetry: 3,
                // used by buffer-controller
                loader: xhr_loader,
                // loader: FetchLoader,
                fLoader: void 0,
                // used by fragment-loader
                pLoader: void 0,
                // used by playlist-loader
                xhrSetup: void 0,
                // used by xhr-loader
                licenseXhrSetup: void 0,
                // used by eme-controller
                // fetchSetup: void 0,
                abrController: abr_controller,
                bufferController: buffer_controller,
                capLevelController: cap_level_controller,
                fpsController: fps_controller,
                stretchShortVideoTrack: false,
                // used by mp4-remuxer
                maxAudioFramesDrift: 1,
                // used by mp4-remuxer
                forceKeyFrameOnDiscontinuity: true,
                // used by ts-demuxer
                abrEwmaFastLive: 3,
                // used by abr-controller
                abrEwmaSlowLive: 9,
                // used by abr-controller
                abrEwmaFastVoD: 3,
                // used by abr-controller
                abrEwmaSlowVoD: 9,
                // used by abr-controller
                abrEwmaDefaultEstimate: 5e5,
                // 500 kbps  // used by abr-controller
                abrBandWidthFactor: 0.95,
                // used by abr-controller
                abrBandWidthUpFactor: 0.7,
                // used by abr-controller
                abrMaxWithRealBitrate: false,
                // used by abr-controller
                maxStarvationDelay: 4,
                // used by abr-controller
                maxLoadingDelay: 4,
                // used by abr-controller
                minAutoBitrate: 0,
                // used by hls
                emeEnabled: false,
                // used by eme-controller
                widevineLicenseUrl: void 0,
                // used by eme-controller
                drmSystemOptions: {},
                // used by eme-controller
                requestMediaKeySystemAccessFunc: requestMediaKeySystemAccess,
                // used by eme-controller
                testBandwidth: true
              }, timelineConfig()), {}, {
                subtitleStreamController: true ? subtitle_stream_controller_SubtitleStreamController : void 0,
                subtitleTrackController: true ? subtitle_track_controller : void 0,
                timelineController: true ? timeline_controller : void 0,
                audioStreamController: true ? audio_stream_controller : void 0,
                audioTrackController: true ? audio_track_controller : void 0,
                emeController: true ? eme_controller : void 0
              });
              function timelineConfig() {
                return {
                  cueHandler: cues_namespaceObject,
                  // used by timeline-controller
                  enableCEA708Captions: true,
                  // used by timeline-controller
                  enableWebVTT: true,
                  // used by timeline-controller
                  captionsTextTrack1Label: "English",
                  // used by timeline-controller
                  captionsTextTrack1LanguageCode: "en",
                  // used by timeline-controller
                  captionsTextTrack2Label: "Spanish",
                  // used by timeline-controller
                  captionsTextTrack2LanguageCode: "es",
                  // used by timeline-controller
                  captionsTextTrack3Label: "Unknown CC",
                  // used by timeline-controller
                  captionsTextTrack3LanguageCode: "",
                  // used by timeline-controller
                  captionsTextTrack4Label: "Unknown CC",
                  // used by timeline-controller
                  captionsTextTrack4LanguageCode: "",
                  // used by timeline-controller
                  renderTextTracksNatively: true
                };
              }
              function hls_ownKeys(object, enumerableOnly) {
                var keys = Object.keys(object);
                if (Object.getOwnPropertySymbols) {
                  var symbols = Object.getOwnPropertySymbols(object);
                  if (enumerableOnly)
                    symbols = symbols.filter(function(sym) {
                      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
                    });
                  keys.push.apply(keys, symbols);
                }
                return keys;
              }
              function hls_objectSpread(target) {
                for (var i = 1; i < arguments.length; i++) {
                  var source = arguments[i] != null ? arguments[i] : {};
                  if (i % 2) {
                    hls_ownKeys(Object(source), true).forEach(function(key) {
                      hls_defineProperty(target, key, source[key]);
                    });
                  } else if (Object.getOwnPropertyDescriptors) {
                    Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
                  } else {
                    hls_ownKeys(Object(source)).forEach(function(key) {
                      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
                    });
                  }
                }
                return target;
              }
              function hls_defineProperty(obj, key, value) {
                if (key in obj) {
                  Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
                } else {
                  obj[key] = value;
                }
                return obj;
              }
              function hls_assertThisInitialized(self2) {
                if (self2 === void 0) {
                  throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                }
                return self2;
              }
              function hls_defineProperties(target, props) {
                for (var i = 0; i < props.length; i++) {
                  var descriptor = props[i];
                  descriptor.enumerable = descriptor.enumerable || false;
                  descriptor.configurable = true;
                  if ("value" in descriptor)
                    descriptor.writable = true;
                  Object.defineProperty(target, descriptor.key, descriptor);
                }
              }
              function hls_createClass(Constructor, protoProps, staticProps) {
                if (protoProps)
                  hls_defineProperties(Constructor.prototype, protoProps);
                if (staticProps)
                  hls_defineProperties(Constructor, staticProps);
                return Constructor;
              }
              function hls_inheritsLoose(subClass, superClass) {
                subClass.prototype = Object.create(superClass.prototype);
                subClass.prototype.constructor = subClass;
                subClass.__proto__ = superClass;
              }
              var hls_Hls = function(_Observer) {
                hls_inheritsLoose(Hls2, _Observer);
                Hls2.isSupported = function isSupported() {
                  return is_supported_isSupported();
                };
                hls_createClass(Hls2, null, [{
                  key: "version",
                  /**
                   * @type {string}
                   */
                  get: function get() {
                    return "0.14.17";
                  }
                }, {
                  key: "Events",
                  get: function get() {
                    return events["default"];
                  }
                  /**
                   * @type {HlsErrorTypes}
                   */
                }, {
                  key: "ErrorTypes",
                  get: function get() {
                    return errors["ErrorTypes"];
                  }
                  /**
                   * @type {HlsErrorDetails}
                   */
                }, {
                  key: "ErrorDetails",
                  get: function get() {
                    return errors["ErrorDetails"];
                  }
                  /**
                   * @type {HlsConfig}
                   */
                }, {
                  key: "DefaultConfig",
                  get: function get() {
                    if (!Hls2.defaultConfig) {
                      return hlsDefaultConfig;
                    }
                    return Hls2.defaultConfig;
                  },
                  set: function set(defaultConfig) {
                    Hls2.defaultConfig = defaultConfig;
                  }
                  /**
                   * Creates an instance of an HLS client that can attach to exactly one `HTMLMediaElement`.
                   *
                   * @constructs Hls
                   * @param {HlsConfig} config
                   */
                }]);
                function Hls2(userConfig) {
                  var _this;
                  if (userConfig === void 0) {
                    userConfig = {};
                  }
                  _this = _Observer.call(this) || this;
                  _this.config = void 0;
                  _this._autoLevelCapping = void 0;
                  _this.abrController = void 0;
                  _this.capLevelController = void 0;
                  _this.levelController = void 0;
                  _this.streamController = void 0;
                  _this.networkControllers = void 0;
                  _this.audioTrackController = void 0;
                  _this.subtitleTrackController = void 0;
                  _this.emeController = void 0;
                  _this.coreComponents = void 0;
                  _this.media = null;
                  _this.url = null;
                  var defaultConfig = Hls2.DefaultConfig;
                  if ((userConfig.liveSyncDurationCount || userConfig.liveMaxLatencyDurationCount) && (userConfig.liveSyncDuration || userConfig.liveMaxLatencyDuration)) {
                    throw new Error("Illegal hls.js config: don't mix up liveSyncDurationCount/liveMaxLatencyDurationCount and liveSyncDuration/liveMaxLatencyDuration");
                  }
                  _this.config = hls_objectSpread(hls_objectSpread({}, defaultConfig), userConfig);
                  var _assertThisInitialize = hls_assertThisInitialized(_this), config = _assertThisInitialize.config;
                  if (config.liveMaxLatencyDurationCount !== void 0 && config.liveMaxLatencyDurationCount <= config.liveSyncDurationCount) {
                    throw new Error('Illegal hls.js config: "liveMaxLatencyDurationCount" must be gt "liveSyncDurationCount"');
                  }
                  if (config.liveMaxLatencyDuration !== void 0 && (config.liveSyncDuration === void 0 || config.liveMaxLatencyDuration <= config.liveSyncDuration)) {
                    throw new Error('Illegal hls.js config: "liveMaxLatencyDuration" must be gt "liveSyncDuration"');
                  }
                  Object(logger["enableLogs"])(config.debug);
                  _this._autoLevelCapping = -1;
                  var abrController = _this.abrController = new config.abrController(hls_assertThisInitialized(_this));
                  var bufferController = new config.bufferController(hls_assertThisInitialized(_this));
                  var capLevelController = _this.capLevelController = new config.capLevelController(hls_assertThisInitialized(_this));
                  var fpsController = new config.fpsController(hls_assertThisInitialized(_this));
                  var playListLoader = new playlist_loader(hls_assertThisInitialized(_this));
                  var fragmentLoader = new fragment_loader(hls_assertThisInitialized(_this));
                  var keyLoader = new key_loader(hls_assertThisInitialized(_this));
                  var id3TrackController = new id3_track_controller(hls_assertThisInitialized(_this));
                  var levelController = _this.levelController = new level_controller_LevelController(hls_assertThisInitialized(_this));
                  var fragmentTracker = new fragment_tracker_FragmentTracker(hls_assertThisInitialized(_this));
                  var streamController = _this.streamController = new stream_controller(hls_assertThisInitialized(_this), fragmentTracker);
                  var networkControllers = [levelController, streamController];
                  var Controller = config.audioStreamController;
                  if (Controller) {
                    networkControllers.push(new Controller(hls_assertThisInitialized(_this), fragmentTracker));
                  }
                  _this.networkControllers = networkControllers;
                  var coreComponents = [playListLoader, fragmentLoader, keyLoader, abrController, bufferController, capLevelController, fpsController, id3TrackController, fragmentTracker];
                  Controller = config.audioTrackController;
                  if (Controller) {
                    var audioTrackController = new Controller(hls_assertThisInitialized(_this));
                    _this.audioTrackController = audioTrackController;
                    coreComponents.push(audioTrackController);
                  }
                  Controller = config.subtitleTrackController;
                  if (Controller) {
                    var subtitleTrackController = new Controller(hls_assertThisInitialized(_this));
                    _this.subtitleTrackController = subtitleTrackController;
                    networkControllers.push(subtitleTrackController);
                  }
                  Controller = config.emeController;
                  if (Controller) {
                    var emeController = new Controller(hls_assertThisInitialized(_this));
                    _this.emeController = emeController;
                    coreComponents.push(emeController);
                  }
                  Controller = config.subtitleStreamController;
                  if (Controller) {
                    networkControllers.push(new Controller(hls_assertThisInitialized(_this), fragmentTracker));
                  }
                  Controller = config.timelineController;
                  if (Controller) {
                    coreComponents.push(new Controller(hls_assertThisInitialized(_this)));
                  }
                  _this.coreComponents = coreComponents;
                  return _this;
                }
                var _proto = Hls2.prototype;
                _proto.destroy = function destroy() {
                  logger["logger"].log("destroy");
                  this.trigger(events["default"].DESTROYING);
                  this.detachMedia();
                  this.coreComponents.concat(this.networkControllers).forEach(function(component) {
                    component.destroy();
                  });
                  this.url = null;
                  this.removeAllListeners();
                  this._autoLevelCapping = -1;
                };
                _proto.attachMedia = function attachMedia(media) {
                  logger["logger"].log("attachMedia");
                  this.media = media;
                  this.trigger(events["default"].MEDIA_ATTACHING, {
                    media
                  });
                };
                _proto.detachMedia = function detachMedia() {
                  logger["logger"].log("detachMedia");
                  this.trigger(events["default"].MEDIA_DETACHING);
                  this.media = null;
                };
                _proto.loadSource = function loadSource(url) {
                  url = url_toolkit["buildAbsoluteURL"](window.location.href, url, {
                    alwaysNormalize: true
                  });
                  logger["logger"].log("loadSource:" + url);
                  this.url = url;
                  this.trigger(events["default"].MANIFEST_LOADING, {
                    url
                  });
                };
                _proto.startLoad = function startLoad(startPosition) {
                  if (startPosition === void 0) {
                    startPosition = -1;
                  }
                  logger["logger"].log("startLoad(" + startPosition + ")");
                  this.networkControllers.forEach(function(controller) {
                    controller.startLoad(startPosition);
                  });
                };
                _proto.stopLoad = function stopLoad() {
                  logger["logger"].log("stopLoad");
                  this.networkControllers.forEach(function(controller) {
                    controller.stopLoad();
                  });
                };
                _proto.swapAudioCodec = function swapAudioCodec() {
                  logger["logger"].log("swapAudioCodec");
                  this.streamController.swapAudioCodec();
                };
                _proto.recoverMediaError = function recoverMediaError() {
                  logger["logger"].log("recoverMediaError");
                  var media = this.media;
                  this.detachMedia();
                  if (media) {
                    this.attachMedia(media);
                  }
                };
                _proto.removeLevel = function removeLevel(levelIndex, urlId) {
                  if (urlId === void 0) {
                    urlId = 0;
                  }
                  this.levelController.removeLevel(levelIndex, urlId);
                };
                hls_createClass(Hls2, [{
                  key: "levels",
                  get: function get() {
                    return this.levelController.levels;
                  }
                  /**
                   * Index of quality level currently played
                   * @type {number}
                   */
                }, {
                  key: "currentLevel",
                  get: function get() {
                    return this.streamController.currentLevel;
                  },
                  set: function set(newLevel) {
                    logger["logger"].log("set currentLevel:" + newLevel);
                    this.loadLevel = newLevel;
                    this.streamController.immediateLevelSwitch();
                  }
                  /**
                   * Index of next quality level loaded as scheduled by stream controller.
                   * @type {number}
                   */
                }, {
                  key: "nextLevel",
                  get: function get() {
                    return this.streamController.nextLevel;
                  },
                  set: function set(newLevel) {
                    logger["logger"].log("set nextLevel:" + newLevel);
                    this.levelController.manualLevel = newLevel;
                    this.streamController.nextLevelSwitch();
                  }
                  /**
                   * Return the quality level of the currently or last (of none is loaded currently) segment
                   * @type {number}
                   */
                }, {
                  key: "loadLevel",
                  get: function get() {
                    return this.levelController.level;
                  },
                  set: function set(newLevel) {
                    logger["logger"].log("set loadLevel:" + newLevel);
                    this.levelController.manualLevel = newLevel;
                  }
                  /**
                   * get next quality level loaded
                   * @type {number}
                   */
                }, {
                  key: "nextLoadLevel",
                  get: function get() {
                    return this.levelController.nextLoadLevel;
                  },
                  set: function set(level) {
                    this.levelController.nextLoadLevel = level;
                  }
                  /**
                   * Return "first level": like a default level, if not set,
                   * falls back to index of first level referenced in manifest
                   * @type {number}
                   */
                }, {
                  key: "firstLevel",
                  get: function get() {
                    return Math.max(this.levelController.firstLevel, this.minAutoLevel);
                  },
                  set: function set(newLevel) {
                    logger["logger"].log("set firstLevel:" + newLevel);
                    this.levelController.firstLevel = newLevel;
                  }
                  /**
                   * Return start level (level of first fragment that will be played back)
                   * if not overrided by user, first level appearing in manifest will be used as start level
                   * if -1 : automatic start level selection, playback will start from level matching download bandwidth
                   * (determined from download of first segment)
                   * @type {number}
                   */
                }, {
                  key: "startLevel",
                  get: function get() {
                    return this.levelController.startLevel;
                  },
                  set: function set(newLevel) {
                    logger["logger"].log("set startLevel:" + newLevel);
                    if (newLevel !== -1) {
                      newLevel = Math.max(newLevel, this.minAutoLevel);
                    }
                    this.levelController.startLevel = newLevel;
                  }
                  /**
                   * set  dynamically set capLevelToPlayerSize against (`CapLevelController`)
                   *
                   * @type {boolean}
                   */
                }, {
                  key: "capLevelToPlayerSize",
                  set: function set(shouldStartCapping) {
                    var newCapLevelToPlayerSize = !!shouldStartCapping;
                    if (newCapLevelToPlayerSize !== this.config.capLevelToPlayerSize) {
                      if (newCapLevelToPlayerSize) {
                        this.capLevelController.startCapping();
                      } else {
                        this.capLevelController.stopCapping();
                        this.autoLevelCapping = -1;
                        this.streamController.nextLevelSwitch();
                      }
                      this.config.capLevelToPlayerSize = newCapLevelToPlayerSize;
                    }
                  }
                  /**
                   * Capping/max level value that should be used by automatic level selection algorithm (`ABRController`)
                   * @type {number}
                   */
                }, {
                  key: "autoLevelCapping",
                  get: function get() {
                    return this._autoLevelCapping;
                  },
                  /**
                   * Capping/max level value that should be used by automatic level selection algorithm (`ABRController`)
                   * @type {number}
                   */
                  set: function set(newLevel) {
                    logger["logger"].log("set autoLevelCapping:" + newLevel);
                    this._autoLevelCapping = newLevel;
                  }
                  /**
                   * True when automatic level selection enabled
                   * @type {boolean}
                   */
                }, {
                  key: "bandwidthEstimate",
                  get: function get() {
                    var bwEstimator = this.abrController._bwEstimator;
                    return bwEstimator ? bwEstimator.getEstimate() : NaN;
                  }
                }, {
                  key: "autoLevelEnabled",
                  get: function get() {
                    return this.levelController.manualLevel === -1;
                  }
                  /**
                   * Level set manually (if any)
                   * @type {number}
                   */
                }, {
                  key: "manualLevel",
                  get: function get() {
                    return this.levelController.manualLevel;
                  }
                  /**
                   * min level selectable in auto mode according to config.minAutoBitrate
                   * @type {number}
                   */
                }, {
                  key: "minAutoLevel",
                  get: function get() {
                    var levels = this.levels, minAutoBitrate = this.config.minAutoBitrate;
                    var len = levels ? levels.length : 0;
                    for (var i = 0; i < len; i++) {
                      var levelNextBitrate = levels[i].realBitrate ? Math.max(levels[i].realBitrate, levels[i].bitrate) : levels[i].bitrate;
                      if (levelNextBitrate > minAutoBitrate) {
                        return i;
                      }
                    }
                    return 0;
                  }
                  /**
                   * max level selectable in auto mode according to autoLevelCapping
                   * @type {number}
                   */
                }, {
                  key: "maxAutoLevel",
                  get: function get() {
                    var levels = this.levels, autoLevelCapping = this.autoLevelCapping;
                    var maxAutoLevel;
                    if (autoLevelCapping === -1 && levels && levels.length) {
                      maxAutoLevel = levels.length - 1;
                    } else {
                      maxAutoLevel = autoLevelCapping;
                    }
                    return maxAutoLevel;
                  }
                  /**
                   * next automatically selected quality level
                   * @type {number}
                   */
                }, {
                  key: "nextAutoLevel",
                  get: function get() {
                    return Math.min(Math.max(this.abrController.nextAutoLevel, this.minAutoLevel), this.maxAutoLevel);
                  },
                  set: function set(nextLevel) {
                    this.abrController.nextAutoLevel = Math.max(this.minAutoLevel, nextLevel);
                  }
                  /**
                   * @type {AudioTrack[]}
                   */
                  // todo(typescript-audioTrackController)
                }, {
                  key: "audioTracks",
                  get: function get() {
                    var audioTrackController = this.audioTrackController;
                    return audioTrackController ? audioTrackController.audioTracks : [];
                  }
                  /**
                   * index of the selected audio track (index in audio track lists)
                   * @type {number}
                   */
                }, {
                  key: "audioTrack",
                  get: function get() {
                    var audioTrackController = this.audioTrackController;
                    return audioTrackController ? audioTrackController.audioTrack : -1;
                  },
                  set: function set(audioTrackId) {
                    var audioTrackController = this.audioTrackController;
                    if (audioTrackController) {
                      audioTrackController.audioTrack = audioTrackId;
                    }
                  }
                  /**
                   * @type {Seconds}
                   */
                }, {
                  key: "liveSyncPosition",
                  get: function get() {
                    return this.streamController.liveSyncPosition;
                  }
                  /**
                   * get alternate subtitle tracks list from playlist
                   * @type {SubtitleTrack[]}
                   */
                  // todo(typescript-subtitleTrackController)
                }, {
                  key: "subtitleTracks",
                  get: function get() {
                    var subtitleTrackController = this.subtitleTrackController;
                    return subtitleTrackController ? subtitleTrackController.subtitleTracks : [];
                  }
                  /**
                   * index of the selected subtitle track (index in subtitle track lists)
                   * @type {number}
                   */
                }, {
                  key: "subtitleTrack",
                  get: function get() {
                    var subtitleTrackController = this.subtitleTrackController;
                    return subtitleTrackController ? subtitleTrackController.subtitleTrack : -1;
                  },
                  set: function set(subtitleTrackId) {
                    var subtitleTrackController = this.subtitleTrackController;
                    if (subtitleTrackController) {
                      subtitleTrackController.subtitleTrack = subtitleTrackId;
                    }
                  }
                  /**
                   * @type {boolean}
                   */
                }, {
                  key: "subtitleDisplay",
                  get: function get() {
                    var subtitleTrackController = this.subtitleTrackController;
                    return subtitleTrackController ? subtitleTrackController.subtitleDisplay : false;
                  },
                  set: function set(value) {
                    var subtitleTrackController = this.subtitleTrackController;
                    if (subtitleTrackController) {
                      subtitleTrackController.subtitleDisplay = value;
                    }
                  }
                }]);
                return Hls2;
              }(Observer);
              hls_Hls.defaultConfig = void 0;
            }
          ),
          /***/
          "./src/polyfills/number.js": (
            /*!*********************************!*\
              !*** ./src/polyfills/number.js ***!
              \*********************************/
            /*! exports provided: isFiniteNumber, MAX_SAFE_INTEGER */
            /***/
            function(module2, __webpack_exports__, __webpack_require__) {
              "use strict";
              __webpack_require__.r(__webpack_exports__);
              __webpack_require__.d(__webpack_exports__, "isFiniteNumber", function() {
                return isFiniteNumber;
              });
              __webpack_require__.d(__webpack_exports__, "MAX_SAFE_INTEGER", function() {
                return MAX_SAFE_INTEGER;
              });
              var isFiniteNumber = Number.isFinite || function(value) {
                return typeof value === "number" && isFinite(value);
              };
              var MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER || 9007199254740991;
            }
          ),
          /***/
          "./src/utils/get-self-scope.js": (
            /*!*************************************!*\
              !*** ./src/utils/get-self-scope.js ***!
              \*************************************/
            /*! exports provided: getSelfScope */
            /***/
            function(module2, __webpack_exports__, __webpack_require__) {
              "use strict";
              __webpack_require__.r(__webpack_exports__);
              __webpack_require__.d(__webpack_exports__, "getSelfScope", function() {
                return getSelfScope;
              });
              function getSelfScope() {
                if (typeof window === "undefined") {
                  return self;
                } else {
                  return window;
                }
              }
            }
          ),
          /***/
          "./src/utils/logger.js": (
            /*!*****************************!*\
              !*** ./src/utils/logger.js ***!
              \*****************************/
            /*! exports provided: enableLogs, logger */
            /***/
            function(module2, __webpack_exports__, __webpack_require__) {
              "use strict";
              __webpack_require__.r(__webpack_exports__);
              __webpack_require__.d(__webpack_exports__, "enableLogs", function() {
                return enableLogs;
              });
              __webpack_require__.d(__webpack_exports__, "logger", function() {
                return logger;
              });
              var _get_self_scope__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
                /*! ./get-self-scope */
                "./src/utils/get-self-scope.js"
              );
              function noop() {
              }
              var fakeLogger = {
                trace: noop,
                debug: noop,
                log: noop,
                warn: noop,
                info: noop,
                error: noop
              };
              var exportedLogger = fakeLogger;
              function formatMsg(type, msg) {
                msg = "[" + type + "] > " + msg;
                return msg;
              }
              var global = Object(_get_self_scope__WEBPACK_IMPORTED_MODULE_0__["getSelfScope"])();
              function consolePrintFn(type) {
                var func = global.console[type];
                if (func) {
                  return function() {
                    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                      args[_key] = arguments[_key];
                    }
                    if (args[0]) {
                      args[0] = formatMsg(type, args[0]);
                    }
                    func.apply(global.console, args);
                  };
                }
                return noop;
              }
              function exportLoggerFunctions(debugConfig) {
                for (var _len2 = arguments.length, functions = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
                  functions[_key2 - 1] = arguments[_key2];
                }
                functions.forEach(function(type) {
                  exportedLogger[type] = debugConfig[type] ? debugConfig[type].bind(debugConfig) : consolePrintFn(type);
                });
              }
              var enableLogs = function enableLogs2(debugConfig) {
                if (global.console && debugConfig === true || typeof debugConfig === "object") {
                  exportLoggerFunctions(
                    debugConfig,
                    // Remove out from list here to hard-disable a log-level
                    // 'trace',
                    "debug",
                    "log",
                    "info",
                    "warn",
                    "error"
                  );
                  try {
                    exportedLogger.log();
                  } catch (e) {
                    exportedLogger = fakeLogger;
                  }
                } else {
                  exportedLogger = fakeLogger;
                }
              };
              var logger = exportedLogger;
            }
          )
          /******/
        })["default"]
      );
    });
  }
});

// node_modules/react-hls-player/dist/index.js
var import_react = __toESM(require_react());
var import_hls = __toESM(require_hls());
var __assign = function() {
  __assign = Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p))
          t[p] = s[p];
    }
    return t;
  };
  return __assign.apply(this, arguments);
};
var __rest = function(s, e) {
  var t = {};
  for (var p in s)
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
      t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t[p[i]] = s[p[i]];
    }
  return t;
};
function ReactHlsPlayer(_a) {
  var hlsConfig = _a.hlsConfig, _b = _a.playerRef, playerRef = _b === void 0 ? import_react.default.createRef() : _b, src = _a.src, autoPlay = _a.autoPlay, props = __rest(_a, ["hlsConfig", "playerRef", "src", "autoPlay"]);
  (0, import_react.useEffect)(function() {
    var hls;
    function _initPlayer() {
      if (hls != null) {
        hls.destroy();
      }
      var newHls = new import_hls.default(__assign({ enableWorker: false }, hlsConfig));
      if (playerRef.current != null) {
        newHls.attachMedia(playerRef.current);
      }
      newHls.on(import_hls.default.Events.MEDIA_ATTACHED, function() {
        newHls.loadSource(src);
        newHls.on(import_hls.default.Events.MANIFEST_PARSED, function() {
          var _a2;
          if (autoPlay) {
            (_a2 = playerRef === null || playerRef === void 0 ? void 0 : playerRef.current) === null || _a2 === void 0 ? void 0 : _a2.play().catch(function() {
              return console.log("Unable to autoplay prior to user interaction with the dom.");
            });
          }
        });
      });
      newHls.on(import_hls.default.Events.ERROR, function(event, data) {
        if (data.fatal) {
          switch (data.type) {
            case import_hls.default.ErrorTypes.NETWORK_ERROR:
              newHls.startLoad();
              break;
            case import_hls.default.ErrorTypes.MEDIA_ERROR:
              newHls.recoverMediaError();
              break;
            default:
              _initPlayer();
              break;
          }
        }
      });
      hls = newHls;
    }
    if (import_hls.default.isSupported()) {
      _initPlayer();
    }
    return function() {
      if (hls != null) {
        hls.destroy();
      }
    };
  }, [autoPlay, hlsConfig, playerRef, src]);
  if (import_hls.default.isSupported())
    return import_react.default.createElement("video", __assign({ ref: playerRef }, props));
  return import_react.default.createElement("video", __assign({ ref: playerRef, src, autoPlay }, props));
}
var dist_default = ReactHlsPlayer;
export {
  dist_default as default
};
//# sourceMappingURL=react-hls-player.js.map
